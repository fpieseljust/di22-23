{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Benvinguts!! Benivinguts a la web de Desenvolupament d'Interf\u00edcies. Curs 22/23. IES Jaume II \"El Just\" - Tavernes de la Valldigna","title":"Home"},{"location":"#benvinguts","text":"Benivinguts a la web de Desenvolupament d'Interf\u00edcies. Curs 22/23. IES Jaume II \"El Just\" - Tavernes de la Valldigna","title":"Benvinguts!!"},{"location":"about/","text":"Desenvolupament d'interf\u00e9cies Normativa Estatal -> RD: 450/2010 Auton\u00f2mica -> Curr\u00edculum CV: Ordre 58/2012 IES Jaume II \"El Just\" - Tavernes de la Valldigna Curs 2021-2022 Professor: Ferran Cunyat","title":"About"},{"location":"about/#desenvolupament-dinterfecies","text":"","title":"Desenvolupament d'interf\u00e9cies"},{"location":"about/#normativa","text":"Estatal -> RD: 450/2010 Auton\u00f2mica -> Curr\u00edculum CV: Ordre 58/2012","title":"Normativa"},{"location":"about/#ies-jaume-ii-el-just-tavernes-de-la-valldigna","text":"","title":"IES Jaume II \"El Just\" - Tavernes de la Valldigna"},{"location":"about/#curs-2021-2022","text":"Professor: Ferran Cunyat","title":"Curs 2021-2022"},{"location":"qualificacio/rubrica/","text":"R\u00fabrica per a avaluar pr\u00e0ctiques/projectes, en Disseny D'interf\u00edcies =============================================================================== Criteris a evaluar: Resoluci\u00f3 : utilitzaci\u00f3 dels algoritmes, les estructures de dades, les funcions, les estructures de control .. m\u00e9s adequats. Funcionament : la soluci\u00f3 proposada fa el que s'ha demanat. Regles d'estil: nomenament adequat dels components utilitzats en la resoluci\u00f3 de la pr\u00e0ctica. Les regles d'estil de Python es complixen. Amb esta part recomanem la utilitzaci\u00f3 d'un linter , per exemple, flake8 o pylint. Disseny gr\u00e0fic: interf\u00edcie clara i estructurada d'acord amb les especificacions. Documentaci\u00f3 interna: inclusi\u00f3 de docstrings i comentaris en el codi de la pr\u00e0ctica que ajuden a l'enteniment de la resoluci\u00f3 realitzada. En la unitat de documentaci\u00f3 veurem com tractar tota la documentaci\u00f3 del projecte. Molt b\u00e9 B\u00e9 Deficient Molt deficient Resoluci\u00f3 Utilitza les estructures m\u00e9s adequats per a resoldre l'exercici. Utilitza les estructures necessaris per a resoldre l'exercici, encara que no s\u00f3n les m\u00e9s adequades. Utilitza estructures inadequades per a resoldre l'exercici. Utilitza estructures que no resolen l'exercici. Puntuaci\u00f3 (m\u00e0x. 3) 3 2 1 0 Funcionament El funcionament de l'exercici \u00e9s complet. El funcionament de l\u2019exercici est\u00e0 quasi complet o est\u00e0 complet per\u00f2 t\u00e9 fallades sense import\u00e0ncia. El funcionament de l'exercici t\u00e9 fallades importants. L'exercici no funciona. Puntuaci\u00f3 (m\u00e0x. 2) 2 1 0,5 0 Regles d'estil El nom de components i variables ajuda a entendre el codi, a m\u00e9s, es complixen les regles d'estil de Python. El nom de components i variables ajuda a entendre el codi, per\u00f2 hi ha errades d'estil. El nom de components i variables no ajuda a entendre el codi o no es seguixen les regles d'estil. El nom de components i variables no ajuda a entendre el codi i no es seguixen les regles d'estil. Puntuaci\u00f3 (m\u00e0x. 1) 1 0,5 0,25 0 Disseny gr\u00e0fic El disseny gr\u00e0fic utilitza els components m\u00e9s adequats, \u00e9s clar i estructurat, i a m\u00e9s \u00e9s amigable. El disseny gr\u00e0fic cont\u00e9 alguns components que no s\u00f3n els m\u00e9s adequats, per\u00f2 \u00e9s clar i estructurat. El disseny gr\u00e0fic cont\u00e9 alguns components que no s\u00f3n els m\u00e9s adequats, i a m\u00e9s, no \u00e9s clar ni estructurat. Al disseny gr\u00e0fic li falten alguns components necessaris i utilitza components que no s\u00f3n correctes. Puntuaci\u00f3 (m\u00e0x. 3) 3 2 1 0 Documentaci\u00f3 Aporta documentaci\u00f3 adequada que ajuda a entendre el codi, a executar i implantar l'aplicaci\u00f3. La documentaci\u00f3 aportada \u00e9s la justa per entendre el codi, per executar-lo i implantar-lo. Aporta documentaci\u00f3 insuficient. No aporta documentaci\u00f3. Puntuaci\u00f3 (m\u00e0x. 1) 1 0,5 0,25 0","title":"R\u00fabriques"},{"location":"qualificacio/rubrica/#rubrica-per-a-avaluar-practiquesprojectes-en-disseny-dinterficies","text":"=============================================================================== Criteris a evaluar: Resoluci\u00f3 : utilitzaci\u00f3 dels algoritmes, les estructures de dades, les funcions, les estructures de control .. m\u00e9s adequats. Funcionament : la soluci\u00f3 proposada fa el que s'ha demanat. Regles d'estil: nomenament adequat dels components utilitzats en la resoluci\u00f3 de la pr\u00e0ctica. Les regles d'estil de Python es complixen. Amb esta part recomanem la utilitzaci\u00f3 d'un linter , per exemple, flake8 o pylint. Disseny gr\u00e0fic: interf\u00edcie clara i estructurada d'acord amb les especificacions. Documentaci\u00f3 interna: inclusi\u00f3 de docstrings i comentaris en el codi de la pr\u00e0ctica que ajuden a l'enteniment de la resoluci\u00f3 realitzada. En la unitat de documentaci\u00f3 veurem com tractar tota la documentaci\u00f3 del projecte. Molt b\u00e9 B\u00e9 Deficient Molt deficient Resoluci\u00f3 Utilitza les estructures m\u00e9s adequats per a resoldre l'exercici. Utilitza les estructures necessaris per a resoldre l'exercici, encara que no s\u00f3n les m\u00e9s adequades. Utilitza estructures inadequades per a resoldre l'exercici. Utilitza estructures que no resolen l'exercici. Puntuaci\u00f3 (m\u00e0x. 3) 3 2 1 0 Funcionament El funcionament de l'exercici \u00e9s complet. El funcionament de l\u2019exercici est\u00e0 quasi complet o est\u00e0 complet per\u00f2 t\u00e9 fallades sense import\u00e0ncia. El funcionament de l'exercici t\u00e9 fallades importants. L'exercici no funciona. Puntuaci\u00f3 (m\u00e0x. 2) 2 1 0,5 0 Regles d'estil El nom de components i variables ajuda a entendre el codi, a m\u00e9s, es complixen les regles d'estil de Python. El nom de components i variables ajuda a entendre el codi, per\u00f2 hi ha errades d'estil. El nom de components i variables no ajuda a entendre el codi o no es seguixen les regles d'estil. El nom de components i variables no ajuda a entendre el codi i no es seguixen les regles d'estil. Puntuaci\u00f3 (m\u00e0x. 1) 1 0,5 0,25 0 Disseny gr\u00e0fic El disseny gr\u00e0fic utilitza els components m\u00e9s adequats, \u00e9s clar i estructurat, i a m\u00e9s \u00e9s amigable. El disseny gr\u00e0fic cont\u00e9 alguns components que no s\u00f3n els m\u00e9s adequats, per\u00f2 \u00e9s clar i estructurat. El disseny gr\u00e0fic cont\u00e9 alguns components que no s\u00f3n els m\u00e9s adequats, i a m\u00e9s, no \u00e9s clar ni estructurat. Al disseny gr\u00e0fic li falten alguns components necessaris i utilitza components que no s\u00f3n correctes. Puntuaci\u00f3 (m\u00e0x. 3) 3 2 1 0 Documentaci\u00f3 Aporta documentaci\u00f3 adequada que ajuda a entendre el codi, a executar i implantar l'aplicaci\u00f3. La documentaci\u00f3 aportada \u00e9s la justa per entendre el codi, per executar-lo i implantar-lo. Aporta documentaci\u00f3 insuficient. No aporta documentaci\u00f3. Puntuaci\u00f3 (m\u00e0x. 1) 1 0,5 0,25 0","title":"R\u00fabrica per a avaluar pr\u00e0ctiques/projectes, en Disseny D'interf\u00edcies"},{"location":"unitats/1-python/pr%C3%A0ctiques/1%20-%20PyGame/","text":"Introducci\u00f3 PyGame \u00e9s una llibreria de Python3 pensada per a desenvolupar de forma senzilla jocs amb Python. Anem a utilitzar-la per a desenvolupar un xicotet joc. Ser\u00e0 la primera activitat avaluable del curs. Instal\u00b7laci\u00f3 i configuraci\u00f3 El primer que farem \u00e9s activar el nostre entorn virtual de desenvolupament i instal\u00b7lar la llibreria pygame. Per a aix\u00f2 recordeu que utilitzarem venv tal com ve explicat a la teoria. Dins l'entorn virtual instal\u00b7lem pygame. Bash 1 2 $ source .venv/bin/activate ( .venv ) $ pip install pygame Hola m\u00f3n! del pygame Aquest programa crea una finestra, omple el fons de blanc i dibuixa un cercle blau al mig: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Simple pygame program # Import and initialize the pygame library import pygame pygame . init () # Set up the drawing window screen = pygame . display . set_mode ([ 500 , 500 ]) # Run until the user asks to quit running = True while running : # Did the user click the window close button? for event in pygame . event . get (): if event . type == pygame . QUIT : running = False # Fill the background with white screen . fill (( 255 , 255 , 255 )) # Draw a solid blue circle in the center pygame . draw . circle ( screen , ( 0 , 0 , 255 ), ( 250 , 250 ), 75 ) # Flip the display pygame . display . flip () enem # Done! Time to quit. pygame . quit () Fixem-nos en alguns punts: La l\u00ednia 8 configura la finestra de visualitzaci\u00f3 del programa, amb unes dimensions de 500x500 pixels. Les l\u00ednies 11 i 12 configuren un bucle de joc per controlar quan finalitza el programa. Les l\u00ednies 15 a 17 recullen i gestionen esdeveniments dins del bucle del joc. L'\u00fanic esdeveniment gestionat de moment \u00e9s pygame.QUIT, que es produeix quan l'usuari fa clic al bot\u00f3 de tancament de la finestra. La l\u00ednia 20 omple la finestra d\u2019un color s\u00f2lid. screen.fill() accepta una llista o una tupla que especifica els valors RGB del color. (255, 255, 255), \u00e9s el color blanc. La l\u00ednia 23 dibuixa un cercle a la finestra, utilitzant els par\u00e0metres (finestra on dibuixar, color, posici\u00f3 central i radi) La l\u00ednia 26 actualitza el contingut de la pantalla, que de moment no canvia al llarg del temps. La l\u00ednia 29 ix del joc, sols s'executa quan ix del bucle per l'event QUIT. Aquesta \u00e9s la versi\u00f3 pygame de \"Hola, m\u00f3n\".","title":"Introducci\u00f3"},{"location":"unitats/1-python/pr%C3%A0ctiques/1%20-%20PyGame/#introduccio","text":"PyGame \u00e9s una llibreria de Python3 pensada per a desenvolupar de forma senzilla jocs amb Python. Anem a utilitzar-la per a desenvolupar un xicotet joc. Ser\u00e0 la primera activitat avaluable del curs.","title":"Introducci\u00f3"},{"location":"unitats/1-python/pr%C3%A0ctiques/1%20-%20PyGame/#installacio-i-configuracio","text":"El primer que farem \u00e9s activar el nostre entorn virtual de desenvolupament i instal\u00b7lar la llibreria pygame. Per a aix\u00f2 recordeu que utilitzarem venv tal com ve explicat a la teoria. Dins l'entorn virtual instal\u00b7lem pygame. Bash 1 2 $ source .venv/bin/activate ( .venv ) $ pip install pygame","title":"Instal\u00b7laci\u00f3 i configuraci\u00f3"},{"location":"unitats/1-python/pr%C3%A0ctiques/1%20-%20PyGame/#hola-mon-del-pygame","text":"Aquest programa crea una finestra, omple el fons de blanc i dibuixa un cercle blau al mig: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Simple pygame program # Import and initialize the pygame library import pygame pygame . init () # Set up the drawing window screen = pygame . display . set_mode ([ 500 , 500 ]) # Run until the user asks to quit running = True while running : # Did the user click the window close button? for event in pygame . event . get (): if event . type == pygame . QUIT : running = False # Fill the background with white screen . fill (( 255 , 255 , 255 )) # Draw a solid blue circle in the center pygame . draw . circle ( screen , ( 0 , 0 , 255 ), ( 250 , 250 ), 75 ) # Flip the display pygame . display . flip () enem # Done! Time to quit. pygame . quit () Fixem-nos en alguns punts: La l\u00ednia 8 configura la finestra de visualitzaci\u00f3 del programa, amb unes dimensions de 500x500 pixels. Les l\u00ednies 11 i 12 configuren un bucle de joc per controlar quan finalitza el programa. Les l\u00ednies 15 a 17 recullen i gestionen esdeveniments dins del bucle del joc. L'\u00fanic esdeveniment gestionat de moment \u00e9s pygame.QUIT, que es produeix quan l'usuari fa clic al bot\u00f3 de tancament de la finestra. La l\u00ednia 20 omple la finestra d\u2019un color s\u00f2lid. screen.fill() accepta una llista o una tupla que especifica els valors RGB del color. (255, 255, 255), \u00e9s el color blanc. La l\u00ednia 23 dibuixa un cercle a la finestra, utilitzant els par\u00e0metres (finestra on dibuixar, color, posici\u00f3 central i radi) La l\u00ednia 26 actualitza el contingut de la pantalla, que de moment no canvia al llarg del temps. La l\u00ednia 29 ix del joc, sols s'executa quan ix del bucle per l'event QUIT. Aquesta \u00e9s la versi\u00f3 pygame de \"Hola, m\u00f3n\".","title":"Hola m\u00f3n! del pygame"},{"location":"unitats/1-python/pr%C3%A0ctiques/2%20-%20Disseny/","text":"Disseny del joc Una vegada vist els conceptes b\u00e0sics anem a desenvolupar un xicotet joc a mode d'exemple. L'objectiu del joc \u00e9s evitar obstacles que entren: El jugador comen\u00e7a a la part esquerra de la pantalla. Els obstacles entren a l'atzar per la dreta i es mouen a l'esquerra en l\u00ednia recta. El jugador pot moure's cap a l'esquerra, cap a la dreta, cap amunt o cap avall per evitar els obstacles. El jugador no pot ixir-se'n de la pantalla. El joc finalitza quan el jugador \u00e9s colpejat per un obstacle o quan l'usuari tanca la finestra. Mentre no es produisca a\u00e7\u00f2, el joc continua, pot ser infinit. Importem i inicialitzem el joc Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Import the pygame module import pygame # Import pygame.locals for easier access to key coordinates # Updated to conform to flake8 and black standards from pygame.locals import ( K_UP , K_DOWN , K_LEFT , K_RIGHT , K_ESCAPE , KEYDOWN , QUIT ) # Initialize pygame pygame . init () Utilitzem les constants definides en locals per veure quina tecla s'ha apretat, o si s'ha pulsat sobre l'aspa de tancar el programa. Configurem la pantalla Python 1 2 3 4 5 6 7 # Define constants for the screen width and height SCREEN_WIDTH = 800 SCREEN_HEIGHT = 600 # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) Definim una finestra \u00e9s de 800x600, utilitzant les constants SCREEN_WIDTH i SCREEN_HEIGHT. El m\u00e8tode ens torna una superf\u00edcie que representa les dimensions interiors de la finestra. Aquesta \u00e9s la part de la finestra que podem controlar, mentre que el sistema operatiu controla els l\u00edmits de la finestra i la barra de t\u00edtol. Si executeu aquest programa ara, apareixer\u00e0 una finestra que apareixer\u00e0 breument i desapareixer\u00e0 immediatament. Configuraci\u00f3 del bucle principal del joc Tots els jocs des de Pong fins a Fortnite utilitzen un bucle de joc per controlar-lo. Fa quatre coses molt importants: Processa l'entrada de l'usuari Actualitza l'estat de tots els objectes del joc Actualitza la pantalla i l'\u00e0udio Mant\u00e9 la velocitat del joc Tots els cicles del bucle del joc s\u2019anomenen fotogrames i, com m\u00e9s r\u00e0pid es facen les coses a cada cicle, m\u00e9s r\u00e0pid es desenvolupar\u00e0 el vostre joc. Els fotogrames continuen ocorrent fins que es compleix alguna condici\u00f3 per ixir del joc. Al vostre disseny, hi ha dues condicions que poden acabar amb el bucle del joc: El jugador xoca amb un obstacle. (M\u00e9s endavant, cobrir\u00e0 la detecci\u00f3 de col\u00b7lisions.) El jugador tanca la finestra (esdeveniment QUIT). El primer que fa el bucle del joc \u00e9s processar l'entrada de l'usuari per permetre al jugador moure's per la pantalla. Per tant, necessiteu alguna manera de capturar i processar una gran quantitat d\u2019informacions. Ho farem mitjan\u00e7ant el sistema d'esdeveniments pygame. Processament d'esdeveniments Pr\u00e9mer una tecla, moure el ratol\u00ed o el joystick s\u00f3n algunes de les maneres en qu\u00e8 un usuari pot proporcionar informaci\u00f3. Totes aquestes accions de l'usuari donen lloc a la generaci\u00f3 d'un esdeveniment i poden passar en qualsevol moment. Tots els esdeveniments de Pygame es col\u00b7loquen a la cua d'esdeveniments , la qual es pot accedir i manipular. El tractament que es fa dels esdeveniments s\u2019anomena gestor d\u2019esdeveniments. Per al vostre joc, els tipus d\u2019esdeveniments en qu\u00e8 us centreu s\u00f3n les pulsacions de tecles i el tancament de la finestra. Els esdeveniments de premuda de tecles tenen el tipus d'esdeveniment KEYDOWN. L'esdeveniment de tancament de finestra t\u00e9 el tipus QUIT. Els diferents tipus d'esdeveniments tamb\u00e9 poden tenir associades altres dades. Per exemple, el tipus d'esdeveniment KEYDOWN tamb\u00e9 t\u00e9 una variable anomenada key per indicar quina tecla s'ha premut. Accediu a la llista de tots els esdeveniments actius a la cua cridant amb pygame.event.get() . A continuaci\u00f3, passeu per aquesta llista, inspeccioneu cada tipus d'esdeveniment i tracteu-los: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Variable to keep the main loop running running = True # Main loop while running : # Look at every event in the queue for event in pygame . event . get (): # Did the user hit a key? if event . type == KEYDOWN : # Was it the Escape key? If so, stop the loop. if event . key == K_ESCAPE : running = False # Did the user click the window close button? If so, stop the loop. elif event . type == QUIT : running = False Vegem m\u00e9s a fons aquest bucle principal del joc: S'estableix una variable de control per al bucle del joc. Per a ixir del bucle i del joc, hem d\u2019establir la variable running = False . Recorrem el gestor d'esdeveniments, recollint tots els esdeveniments que hi ha actualment a la cua d'esdeveniments. Si no hi ha esdeveniments, la llista est\u00e0 buida i el gestor no far\u00e0 res. Per a cada esdeveniment de la cua, comprovem el tipus. Si event.type == KEYDOWN , s'ha apretat alguna tecla. Si \u00e9s aix\u00ed, comprovem quina tecla s'ha apretat mirant l'atribut event.key . Si la clau \u00e9s la tecla Esc, indicada per K_ESCAPE, surt del bucle del joc configurant running = False. Es fa una comprovaci\u00f3 similar per al tipus d'esdeveniment QUIT . Aquest esdeveniment nom\u00e9s es produeix quan l'usuari fa clic al bot\u00f3 de tancament de la finestra. L'usuari tamb\u00e9 pot utilitzar qualsevol altra acci\u00f3 del sistema operatiu per tancar la finestra. Quan afegiu aquestes l\u00ednies al codi anterior i l'executeu, veureu una finestra amb una pantalla en blanc o negre. La finestra no desapareixer\u00e0 fins que no premeu la tecla Esc tanqueu la finestra amb el ratol\u00ed o combinaci\u00f3 de tecles Alt + F4 . (Comproveu-ho, per\u00f2 recordeu afegir pygame.display.flip() per a que pinte la pantalla al bucle). Pintant objectes a la pantalla Al programa de mostra, hem dibuixat a la pantalla mitjan\u00e7ant dos m\u00e8todes: screen.fill() per omplir el fons pygame.draw.circle() per dibuixar un cercle Ara veurem una tercera manera de dibuixar a la pantalla: utilitzar una superf\u00edcie Surface . Una superf\u00edcie \u00e9s un objecte rectangular sobre el qual podem dibuixar, com un full de paper en blanc. La pantalla \u00e9s una superf\u00edcie i podeu crear els vostres propis objectes de superf\u00edcie separats de la pantalla. Vegem com funciona: Python 1 2 3 4 5 6 7 8 9 # Fill the screen with white screen . fill (( 255 , 255 , 255 )) # Create a surface and pass in a tuple containing its length and width surf = pygame . Surface (( 50 , 50 )) # Give the surface a color to separate it from the background surf . fill (( 0 , 0 , 0 )) rect = surf . get_rect () A la primera l\u00ednia la pantalla s'omple de blanc. Despr\u00e9s es crea una nova superf\u00edcie de 50 p\u00edxels d'ample, 50 p\u00edxels d'al\u00e7ada i s'assigna a surf . Ara surf \u00e9s una superf\u00edcie igual que la pantalla principal i l'omplim de negre. Accedim al seu rectangle subjacentmitjan\u00e7ant get_rect() per poder-ho utilitzar posteriorment. \u00das de .blit () i .flip () El fet de crear una nova superf\u00edcie no \u00e9s suficient per veure-la a la pantalla. Per fer-ho, cal que col\u00b7loqueu la superf\u00edcie sobre una altra superf\u00edcie. El terme blit significa Block Transfer (Transfer\u00e8ncia de blocs) i .blit() \u00e9s la forma de copiar el contingut d\u2019una superf\u00edcie a una altra. Nom\u00e9s podeu copiar el contingut entre superf\u00edcies, per\u00f2 ja haviem dit que screen \u00e9s una superf\u00edcie. Vegem com dibuixem surf a la pantalla: Python 1 2 3 # This line says \"Draw surf onto the screen at the center\" screen . blit ( surf , ( SCREEN_WIDTH / 2 , SCREEN_HEIGHT / 2 )) pygame . display . flip () La funci\u00f3 blit pren dos arguments: La superf\u00edcie a pintar Les coordenades del v\u00e8rtex top-left Per tant si ho volem pintar exactament al centre de la pantalla hauriem de restar la seua amplada i altura respectivament: Python 1 2 3 4 5 6 7 8 9 # Put the center of surf at the center of the display surf_center = ( ( SCREEN_WIDTH - surf . get_width ()) / 2 , ( SCREEN_HEIGHT - surf . get_height ()) / 2 ) # Draw surf at the new coordinates screen . blit ( surf , surf_center ) pygame . display . flip () Recordeu fer la crida a la funci\u00f3 flip per a repintar el joc.","title":"Disseny del joc"},{"location":"unitats/1-python/pr%C3%A0ctiques/2%20-%20Disseny/#disseny-del-joc","text":"Una vegada vist els conceptes b\u00e0sics anem a desenvolupar un xicotet joc a mode d'exemple. L'objectiu del joc \u00e9s evitar obstacles que entren: El jugador comen\u00e7a a la part esquerra de la pantalla. Els obstacles entren a l'atzar per la dreta i es mouen a l'esquerra en l\u00ednia recta. El jugador pot moure's cap a l'esquerra, cap a la dreta, cap amunt o cap avall per evitar els obstacles. El jugador no pot ixir-se'n de la pantalla. El joc finalitza quan el jugador \u00e9s colpejat per un obstacle o quan l'usuari tanca la finestra. Mentre no es produisca a\u00e7\u00f2, el joc continua, pot ser infinit.","title":"Disseny del joc"},{"location":"unitats/1-python/pr%C3%A0ctiques/2%20-%20Disseny/#importem-i-inicialitzem-el-joc","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Import the pygame module import pygame # Import pygame.locals for easier access to key coordinates # Updated to conform to flake8 and black standards from pygame.locals import ( K_UP , K_DOWN , K_LEFT , K_RIGHT , K_ESCAPE , KEYDOWN , QUIT ) # Initialize pygame pygame . init () Utilitzem les constants definides en locals per veure quina tecla s'ha apretat, o si s'ha pulsat sobre l'aspa de tancar el programa.","title":"Importem i inicialitzem el joc"},{"location":"unitats/1-python/pr%C3%A0ctiques/2%20-%20Disseny/#configurem-la-pantalla","text":"Python 1 2 3 4 5 6 7 # Define constants for the screen width and height SCREEN_WIDTH = 800 SCREEN_HEIGHT = 600 # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) Definim una finestra \u00e9s de 800x600, utilitzant les constants SCREEN_WIDTH i SCREEN_HEIGHT. El m\u00e8tode ens torna una superf\u00edcie que representa les dimensions interiors de la finestra. Aquesta \u00e9s la part de la finestra que podem controlar, mentre que el sistema operatiu controla els l\u00edmits de la finestra i la barra de t\u00edtol. Si executeu aquest programa ara, apareixer\u00e0 una finestra que apareixer\u00e0 breument i desapareixer\u00e0 immediatament.","title":"Configurem la pantalla"},{"location":"unitats/1-python/pr%C3%A0ctiques/2%20-%20Disseny/#configuracio-del-bucle-principal-del-joc","text":"Tots els jocs des de Pong fins a Fortnite utilitzen un bucle de joc per controlar-lo. Fa quatre coses molt importants: Processa l'entrada de l'usuari Actualitza l'estat de tots els objectes del joc Actualitza la pantalla i l'\u00e0udio Mant\u00e9 la velocitat del joc Tots els cicles del bucle del joc s\u2019anomenen fotogrames i, com m\u00e9s r\u00e0pid es facen les coses a cada cicle, m\u00e9s r\u00e0pid es desenvolupar\u00e0 el vostre joc. Els fotogrames continuen ocorrent fins que es compleix alguna condici\u00f3 per ixir del joc. Al vostre disseny, hi ha dues condicions que poden acabar amb el bucle del joc: El jugador xoca amb un obstacle. (M\u00e9s endavant, cobrir\u00e0 la detecci\u00f3 de col\u00b7lisions.) El jugador tanca la finestra (esdeveniment QUIT). El primer que fa el bucle del joc \u00e9s processar l'entrada de l'usuari per permetre al jugador moure's per la pantalla. Per tant, necessiteu alguna manera de capturar i processar una gran quantitat d\u2019informacions. Ho farem mitjan\u00e7ant el sistema d'esdeveniments pygame.","title":"Configuraci\u00f3 del bucle principal del joc"},{"location":"unitats/1-python/pr%C3%A0ctiques/2%20-%20Disseny/#processament-desdeveniments","text":"Pr\u00e9mer una tecla, moure el ratol\u00ed o el joystick s\u00f3n algunes de les maneres en qu\u00e8 un usuari pot proporcionar informaci\u00f3. Totes aquestes accions de l'usuari donen lloc a la generaci\u00f3 d'un esdeveniment i poden passar en qualsevol moment. Tots els esdeveniments de Pygame es col\u00b7loquen a la cua d'esdeveniments , la qual es pot accedir i manipular. El tractament que es fa dels esdeveniments s\u2019anomena gestor d\u2019esdeveniments. Per al vostre joc, els tipus d\u2019esdeveniments en qu\u00e8 us centreu s\u00f3n les pulsacions de tecles i el tancament de la finestra. Els esdeveniments de premuda de tecles tenen el tipus d'esdeveniment KEYDOWN. L'esdeveniment de tancament de finestra t\u00e9 el tipus QUIT. Els diferents tipus d'esdeveniments tamb\u00e9 poden tenir associades altres dades. Per exemple, el tipus d'esdeveniment KEYDOWN tamb\u00e9 t\u00e9 una variable anomenada key per indicar quina tecla s'ha premut. Accediu a la llista de tots els esdeveniments actius a la cua cridant amb pygame.event.get() . A continuaci\u00f3, passeu per aquesta llista, inspeccioneu cada tipus d'esdeveniment i tracteu-los: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Variable to keep the main loop running running = True # Main loop while running : # Look at every event in the queue for event in pygame . event . get (): # Did the user hit a key? if event . type == KEYDOWN : # Was it the Escape key? If so, stop the loop. if event . key == K_ESCAPE : running = False # Did the user click the window close button? If so, stop the loop. elif event . type == QUIT : running = False Vegem m\u00e9s a fons aquest bucle principal del joc: S'estableix una variable de control per al bucle del joc. Per a ixir del bucle i del joc, hem d\u2019establir la variable running = False . Recorrem el gestor d'esdeveniments, recollint tots els esdeveniments que hi ha actualment a la cua d'esdeveniments. Si no hi ha esdeveniments, la llista est\u00e0 buida i el gestor no far\u00e0 res. Per a cada esdeveniment de la cua, comprovem el tipus. Si event.type == KEYDOWN , s'ha apretat alguna tecla. Si \u00e9s aix\u00ed, comprovem quina tecla s'ha apretat mirant l'atribut event.key . Si la clau \u00e9s la tecla Esc, indicada per K_ESCAPE, surt del bucle del joc configurant running = False. Es fa una comprovaci\u00f3 similar per al tipus d'esdeveniment QUIT . Aquest esdeveniment nom\u00e9s es produeix quan l'usuari fa clic al bot\u00f3 de tancament de la finestra. L'usuari tamb\u00e9 pot utilitzar qualsevol altra acci\u00f3 del sistema operatiu per tancar la finestra. Quan afegiu aquestes l\u00ednies al codi anterior i l'executeu, veureu una finestra amb una pantalla en blanc o negre. La finestra no desapareixer\u00e0 fins que no premeu la tecla Esc tanqueu la finestra amb el ratol\u00ed o combinaci\u00f3 de tecles Alt + F4 . (Comproveu-ho, per\u00f2 recordeu afegir pygame.display.flip() per a que pinte la pantalla al bucle).","title":"Processament d'esdeveniments"},{"location":"unitats/1-python/pr%C3%A0ctiques/2%20-%20Disseny/#pintant-objectes-a-la-pantalla","text":"Al programa de mostra, hem dibuixat a la pantalla mitjan\u00e7ant dos m\u00e8todes: screen.fill() per omplir el fons pygame.draw.circle() per dibuixar un cercle Ara veurem una tercera manera de dibuixar a la pantalla: utilitzar una superf\u00edcie Surface . Una superf\u00edcie \u00e9s un objecte rectangular sobre el qual podem dibuixar, com un full de paper en blanc. La pantalla \u00e9s una superf\u00edcie i podeu crear els vostres propis objectes de superf\u00edcie separats de la pantalla. Vegem com funciona: Python 1 2 3 4 5 6 7 8 9 # Fill the screen with white screen . fill (( 255 , 255 , 255 )) # Create a surface and pass in a tuple containing its length and width surf = pygame . Surface (( 50 , 50 )) # Give the surface a color to separate it from the background surf . fill (( 0 , 0 , 0 )) rect = surf . get_rect () A la primera l\u00ednia la pantalla s'omple de blanc. Despr\u00e9s es crea una nova superf\u00edcie de 50 p\u00edxels d'ample, 50 p\u00edxels d'al\u00e7ada i s'assigna a surf . Ara surf \u00e9s una superf\u00edcie igual que la pantalla principal i l'omplim de negre. Accedim al seu rectangle subjacentmitjan\u00e7ant get_rect() per poder-ho utilitzar posteriorment.","title":"Pintant objectes a la pantalla"},{"location":"unitats/1-python/pr%C3%A0ctiques/2%20-%20Disseny/#us-de-blit-i-flip","text":"El fet de crear una nova superf\u00edcie no \u00e9s suficient per veure-la a la pantalla. Per fer-ho, cal que col\u00b7loqueu la superf\u00edcie sobre una altra superf\u00edcie. El terme blit significa Block Transfer (Transfer\u00e8ncia de blocs) i .blit() \u00e9s la forma de copiar el contingut d\u2019una superf\u00edcie a una altra. Nom\u00e9s podeu copiar el contingut entre superf\u00edcies, per\u00f2 ja haviem dit que screen \u00e9s una superf\u00edcie. Vegem com dibuixem surf a la pantalla: Python 1 2 3 # This line says \"Draw surf onto the screen at the center\" screen . blit ( surf , ( SCREEN_WIDTH / 2 , SCREEN_HEIGHT / 2 )) pygame . display . flip () La funci\u00f3 blit pren dos arguments: La superf\u00edcie a pintar Les coordenades del v\u00e8rtex top-left Per tant si ho volem pintar exactament al centre de la pantalla hauriem de restar la seua amplada i altura respectivament: Python 1 2 3 4 5 6 7 8 9 # Put the center of surf at the center of the display surf_center = ( ( SCREEN_WIDTH - surf . get_width ()) / 2 , ( SCREEN_HEIGHT - surf . get_height ()) / 2 ) # Draw surf at the new coordinates screen . blit ( surf , surf_center ) pygame . display . flip () Recordeu fer la crida a la funci\u00f3 flip per a repintar el joc.","title":"\u00das de .blit () i .flip ()"},{"location":"unitats/1-python/pr%C3%A0ctiques/3%20-%20Sprites/","text":"Sprites Al disseny del joc, el jugador comen\u00e7a per l\u2019esquerra i els obstacles entren per la dreta. Podeu representar tots els obstacles amb objectes de la superf\u00edcie per fer tot el dibuix m\u00e9s f\u00e0cil, per\u00f2 com sabeu on dibuixar-los? Com se sap si un obstacle ha xocat amb el jugador? Qu\u00e8 passa quan l'obstacle ix de la pantalla? Qu\u00e8 passa si voleu dibuixar imatges de fons que tamb\u00e9 es moguin? Qu\u00e8 passa si voleu que les vostres imatges siguen animades? Podeu gestionar totes aquestes situacions i molt m\u00e9s amb els sprites . En termes de programaci\u00f3, un sprite \u00e9s una representaci\u00f3 2D d'alguna cosa a la pantalla. Essencialment, \u00e9s una imatge. pygame proporciona una classe Sprite, que est\u00e0 dissenyada per contenir una o diverses representacions gr\u00e0fiques de qualsevol objecte de joc que vulgueu mostrar a la pantalla. Per utilitzar-lo, creeu una nova classe que herede d'Sprite. Aix\u00f2 us permet utilitzar els seus m\u00e8todes heredats. Jugadors A continuaci\u00f3 s\u2019explica com s\u2019utilitzen els objectes Sprite amb el joc actual per definir el jugador. Python 1 2 3 4 5 6 7 8 # Define a Player object by extending pygame.sprite.Sprite # The surface drawn on the screen is now an attribute of 'player' class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . Surface (( 75 , 25 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect () Primer definiu Player ampliant pygame.sprite.Sprite. Despr\u00e9s .__ init __() utilitza .super() per cridar al constructor de la classe pare. A continuaci\u00f3, definim i inicialitzem .surf per mantindre la imatge que voleu mostrar, que actualment \u00e9s un quadre blanc. Tamb\u00e9 definim i inicialitzem .rect, que s'utilitzar\u00e0 m\u00e9s endavant. Per utilitzar aquesta nova classe, heu de crear un objecte nou i canviar tamb\u00e9 el codi de dibuix. Amplieu el bloc de codi seg\u00fcent per veure-ho tot junt: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 # Import the pygame module import pygame # Import pygame.locals for easier access to key coordinates # Updated to conform to flake8 and black standards from pygame.locals import ( K_UP , K_DOWN , K_LEFT , K_RIGHT , K_ESCAPE , KEYDOWN , QUIT , ) # Define constants for the screen width and height SCREEN_WIDTH = 800 SCREEN_HEIGHT = 600 # Define a player object by extending pygame.sprite.Sprite # The surface drawn on the screen is now an attribute of 'player' class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . Surface (( 75 , 25 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect () # Initialize pygame pygame . init () # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) # Instantiate player. Right now, this is just a rectangle. player = Player () # Variable to keep the main loop running running = True # Main loop while running : # for loop through the event queue for event in pygame . event . get (): # Check for KEYDOWN event if event . type == KEYDOWN : # If the Esc key is pressed, then exit the main loop if event . key == K_ESCAPE : running = False # Check for QUIT event. If QUIT, then set running to false. elif event . type == QUIT : running = False # Fill the screen with black screen . fill (( 0 , 0 , 0 )) # Draw the player on the screen #screen.blit(player.surf, (SCREEN_WIDTH/2, SCREEN_HEIGHT/2)) screen . blit ( player . surf , player . rect ) # Update the display pygame . display . flip () Entrada d\u2019usuari Fins ara, hem apr\u00e8s a configurar Pygame i dibuixar objectes a la pantalla. Ara comen\u00e7a la diversi\u00f3. Fareu que el joc es puga controlar mitjan\u00e7ant el teclat. Abans, haviem vist que pygame.event.get() retorna la llista dels esdeveniments de la cua, que analitzem per trobar els seus tipus. B\u00e9, aquesta no \u00e9s l\u2019\u00fanica manera de llegir les tecles. pygame tamb\u00e9 proporciona pygame.event.get_pressed() , que retorna un diccionari que cont\u00e9 tots els esdeveniments KEYDOWN actuals a la cua. Posar-ho al bucle del joc despr\u00e9s del bucle de gesti\u00f3 d'esdeveniments torna un diccionari que cont\u00e9 les tecles apretades al comen\u00e7ament de cada fotograma. A continuaci\u00f3, escrivim un m\u00e8tode a Player per analitzar aquest diccionari. Aix\u00f2 definir\u00e0 el comportament del sprite a partir de les tecles que es premen. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 # Get the set of keys pressed and check for user input pressed_keys = pygame . key . get_pressed () # Move the sprite based on user keypresses def update ( self , pressed_keys ): if pressed_keys [ K_UP ]: self . rect . move_ip ( 0 , - 5 ) if pressed_keys [ K_DOWN ]: self . rect . move_ip ( 0 , 5 ) if pressed_keys [ K_LEFT ]: self . rect . move_ip ( - 5 , 0 ) if pressed_keys [ K_RIGHT ]: self . rect . move_ip ( 5 , 0 ) K_UP, K_DOWN, K_LEFT i K_RIGHT corresponen a les tecles de les fletxes del teclat. Utilitzarem .move_ip() , que significa moure des del punt actual, i reb per par\u00e0metre el n\u00famero de pixels a moure's en horitzontal i en vertical com si es tractara d'un eix de coordenades. A continuaci\u00f3, cridem a .update() cada fotograma per moure el sprite del jugador en resposta a les pulsacions de tecles. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Main loop while running : # for loop through the event queue for event in pygame . event . get (): # Check for KEYDOWN event if event . type == KEYDOWN : # If the Esc key is pressed, then exit the main loop if event . key == K_ESCAPE : running = False # Check for QUIT event. If QUIT, then set running to false. elif event . type == QUIT : running = False # Get all the keys currently pressed pressed_keys = pygame . key . get_pressed () # Update the player sprite based on user keypresses player . update ( pressed_keys ) # Fill the screen with black screen . fill (( 0 , 0 , 0 )) Amb aix\u00f2, ja veiem que el Player es mou tant en horitzontal com en vertical. \u00c9s possible que noteu dos problemes: El rectangle del jugador es mou molt r\u00e0pid. Ho solucionarem m\u00e9s endavant. El rectangle del jugador pot ixir-se'n de la pantalla. Solucionem-ho ara. Per mantenir el jugador a la pantalla, cal afegir la l\u00f2gica per detectar les colisions entre el jugador i els l\u00edmits de la pantalla. Per fer-ho, comprovem si les coordenades del rectangle s\u2019han despla\u00e7at m\u00e9s enll\u00e0 del l\u00edmit de la pantalla. Si \u00e9s aix\u00ed, indiquem al programa que el torne a la vora, quedant la funci\u00f3 update com a continuaci\u00f3 s'indica: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Move the sprite based on user keypresses def update ( self , pressed_keys ): if pressed_keys [ K_UP ]: self . rect . move_ip ( 0 , - 5 ) if pressed_keys [ K_DOWN ]: self . rect . move_ip ( 0 , 5 ) if pressed_keys [ K_LEFT ]: self . rect . move_ip ( - 5 , 0 ) if pressed_keys [ K_RIGHT ]: self . rect . move_ip ( 5 , 0 ) # Keep player on the screen if self . rect . left < 0 : self . rect . left = 0 if self . rect . right > SCREEN_WIDTH : self . rect . right = SCREEN_WIDTH if self . rect . top <= 0 : self . rect . top = 0 if self . rect . bottom >= SCREEN_HEIGHT : self . rect . bottom = SCREEN_HEIGHT Ac\u00ed, en lloc d\u2019utilitzar .move() , nom\u00e9s heu de canviar les coordenades corresponents de .top, .bottom, .left o .right directament. Proveu-ho i veureu que el rectangle del reproductor ja no pot ixir-se'n de la pantalla. Enemics Qu\u00e8 \u00e9s un joc sense enemics? Utilitzarem les mateixes t\u00e8cniques que ja hem apr\u00e8s per crear una classe enemiga b\u00e0sica i, a continuaci\u00f3, crearem moltes inst\u00e0ncies d'aquesta per a que el jugador intente evitar-les. Primer, importeu la llibreria random . A continuaci\u00f3, creeu una nova classe de sprite anomenada Enemy , seguint el mateix patr\u00f3 que utilitzarem per a Player : Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Import random for random numbers import random # Define the enemy object by extending pygame.sprite.Sprite # The surface you draw on the screen is now an attribute of 'enemy' class Enemy ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Enemy , self ) . __init__ () self . surf = pygame . Surface (( 20 , 10 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect ( center = ( random . randint ( SCREEN_WIDTH + 20 , SCREEN_WIDTH + 100 ), random . randint ( 0 , SCREEN_HEIGHT ), ) ) self . speed = random . randint ( 5 , 20 ) # Move the sprite based on speed # Remove the sprite when it passes the left edge of the screen def update ( self ): self . rect . move_ip ( - self . speed , 0 ) if self . rect . right < 0 : self . kill () Hi ha quatre difer\u00e8ncies notables entre Enemic i Jugador: Quan creem un enemic ho fem a una ubicaci\u00f3 aleat\u00f2ria al llarg de la vora dreta de la pantalla. Es troba en una posici\u00f3 entre 20 i 100 p\u00edxels de dist\u00e0ncia de la vora dreta i en algun lloc entre la vora superior i la inferior. De forma que al principi no ser\u00e0 visible i anir\u00e0 apareixent per la vora dreta de la pantalla. Definim una velocitat speed com un n\u00famero aleatori entre 5 i 20. Aix\u00f2 especifica la velocitat amb qu\u00e8 aquest enemic es mou cap al jugador. .update() no necessita arguments, ja que els enemics es mouen autom\u00e0ticament cap a l'esquerra a la velocitat aleat\u00f2ria definida quan es va crear i que ja no canvia. Comprovem si l'enemic s'ha mogut fora de la pantalla al sobrepassar la vora esquerra. Per assegurar-nos que l\u2019enemic estiga completament fora de la pantalla i que no desaparega mentre encara siga visible, comprovem que el costat dret de . rect haja sobrepassat el costat esquerre de la pantalla. Una vegada que l'enemic es troba fora de pantalla, cridem a .kill() per evitar anar consumint m\u00e9s recursos cada vegada. Qu\u00e8 fa .kill() ? Per saber-ho, estudiem els Sprite Groups . Sprite Groups Una altra classe s\u00faper \u00fatil que proporciona Pygame s\u00f3n els Sprite Groups . Es tracta d'un objecte que cont\u00e9 un grup d'objectes Sprite. Aleshores, per qu\u00e8 utilitzar-lo? No podem fer el seguiment dels nostres objectes Sprite en una llista? B\u00e9, podem, per\u00f2 l\u2019avantatge d\u2019utilitzar un grup radica en els m\u00e8todes que exposa. Aquests m\u00e8todes ajuden a detectar si algun enemic ha xocat amb el jugador, cosa que facilita les actualitzacions. Vegem com crear Sprite Group . Creem dos objectes de grup diferents: El primer grup tindr\u00e0 tots els Sprite del joc. El segon grup tindr\u00e0 nom\u00e9s els objectes enemics. A continuaci\u00f3, es mostra el codi: Python 1 2 3 4 5 6 7 8 9 10 11 12 # Create the 'player' player = Player () # Create groups to hold enemy sprites and all sprites # - enemies is used for collision detection and position updates # - all_sprites is used for rendering enemies = pygame . sprite . Group () all_sprites = pygame . sprite . Group () all_sprites . add ( player ) # Variable to keep the main loop running running = True Quan cridem el m\u00e8tode .kill() , el Sprite s\u2019elimina de tots els grups als quals pertany. Aix\u00f2 tamb\u00e9 elimina les refer\u00e8ncies al Sprite, cosa que permet al garbage collector de Python recuperar la mem\u00f2ria quan siga necessari. Ara que teniu un grup all_sprites, podeu canviar la manera com es dibuixen els objectes. En lloc de cridar a .blit() nom\u00e9s amb Player, podem repintar tot sobre all_sprites: Python 1 2 3 4 5 6 7 8 9 # Fill the screen with black screen . fill (( 0 , 0 , 0 )) # Draw all sprites for entity in all_sprites : screen . blit ( entity . surf , entity . rect ) # Flip everything to the display pygame . display . flip () Ara, qualsevol objecte d' all_sprites es redibuixar\u00e0 a tots els fotogrames, ja sigui un enemic o un jugador. Nom\u00e9s hi ha un problema ... No tenim cap enemic. Podriem crear un munt d\u2019enemics al principi del joc, per\u00f2 el joc es tornaria complicad\u00edssim a l'apareixer tots junts. En el seu lloc, explorem com mantenir un subministrament constant d\u2019enemics que arriben a mesura que avance el joc. Esdeveniments personalitzats El disseny demana que apareguen enemics a intervals regulars. Aix\u00f2 significa que, a intervals establerts, hem de fer dues coses: Crea un enemic nou. Afegiu-lo a all_sprites i a enemics. (Sprite Groups) Ja teniu codi que gestiona esdeveniments aleatoris. El bucle d'esdeveniments est\u00e0 dissenyat per buscar esdeveniments aleatoris que es produeixen a cada fotograma i tractar-los adequadament. Per sort, pygame no us limita a utilitzar nom\u00e9s els tipus d\u2019esdeveniments que t\u00e9 predefinits. Podeu definir els vostres propis esdeveniments per gestionar-los segons convinga. Vegem com es crea un esdeveniment personalitzat que es genera cada pocs segons. Podeu crear un esdeveniment personalitzat com es mostra a continuaci\u00f3: Python 1 2 3 4 5 6 7 8 9 10 # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) # Create a custom event for adding a new enemy ADDENEMY = pygame . USEREVENT + 1 pygame . time . set_timer ( ADDENEMY , 250 ) # Instantiate player. Right now, this is just a rectangle. player = Player () pygame defineix els esdeveniments internament com a enters, de manera que cal definir un nou esdeveniment amb un enter \u00fanic. L'\u00faltim esdeveniment reservat a Pygame es diu USEREVENT , de manera que definir ADDENEMY = pygame.USEREVENT + 1 garanteix que siga \u00fanic. A continuaci\u00f3, heu d'insertar aquest nou esdeveniment a la cua d'esdeveniments a intervals regulars durant tot el joc. Necessitem d'alguna forma gestionar el temps, per aix\u00f2 utilitzarem el m\u00f2dul de temps. Disparem el nou esdeveniment ADDENEMY cada 250 mil\u00b7lisegons, o quatre vegades per segon. Per aix\u00f2 farem una crida a .set_timer() fora del bucle del joc, ja que nom\u00e9s necessitem un temporitzador, per\u00f2 es disparar\u00e0 durant tot el joc cada 250 milisegons. Afegim el codi per gestionar el nostre nou esdeveniment. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Main loop while running : # Look at every event in the queue for event in pygame . event . get (): # Did the user hit a key? if event . type == KEYDOWN : # Was it the Escape key? If so, stop the loop. if event . key == K_ESCAPE : running = False # Did the user click the window close button? If so, stop the loop. elif event . type == QUIT : running = False # Add a new enemy? elif event . type == ADDENEMY : # Create the new enemy and add it to sprite groups new_enemy = Enemy () enemies . add ( new_enemy ) all_sprites . add ( new_enemy ) # Get the set of keys pressed and check for user input pressed_keys = pygame . key . get_pressed () player . update ( pressed_keys ) # Update enemy position enemies . update () Sempre que el gestor d'esdeveniments veu el nou esdeveniment ADDENEMY, crea un enemic i l'afegeix a enemies i a all_sprites . Com que Enemy est\u00e0 en all_sprites , es dibuixar\u00e0 a cada fotograma. Tamb\u00e9 heu de cridar a enemies.update() , que actualitza totes les posicions dels enemics. Detecci\u00f3 de col\u00b7lisions El disseny del joc demana que finalitze el joc sempre que un enemic xoque amb el jugador. La comprovaci\u00f3 de col\u00b7lisions \u00e9s una t\u00e8cnica b\u00e0sica de programaci\u00f3 de jocs i, en general, requereix alguns c\u00e0lculs matem\u00e0tics per determinar si dos sprites se superposaran. Aqu\u00ed \u00e9s on resulta \u00fatil un framework com Pygame. Escriure un codi de detecci\u00f3 de col\u00b7lisions \u00e9s tedi\u00f3s, per\u00f2 Pygame t\u00e9 MOLTS m\u00e8todes de detecci\u00f3 de col\u00b7lisions disponibles per utilitzar-los. Per a aquest tutorial, utilitzeu un m\u00e8tode anomenat .spritecollideany() , que detecta qualsevol col\u00b7lisi\u00f3 entre un sprite i els sprites d'un grup. Accepta un Sprite i un Grup com a par\u00e0metres. Comprova les superposicions entre tots els .rect del grup i el .rect de l'sprite. Si \u00e9s aix\u00ed, torna True, \u00e9s a dir si detecta col\u00b7lisi\u00f3. En cas contrari, torna False. Aix\u00f2 s'ajusta perfectament a aquest joc, ja que hem de comprovar si un sol jugador xoca amb un grup d'enemics. Vegem el codi: Python 1 2 3 4 5 6 7 8 9 # Draw all sprites for entity in all_sprites : screen . blit ( entity . surf , entity . rect ) # Check if any enemies have collided with the player if pygame . sprite . spritecollideany ( player , enemies ): # If so, then remove the player and stop the loop player . kill () running = False Es comprova si el jugador ha xocat amb algun enemic. Si \u00e9s aix\u00ed, es crida a player.kill() per eliminar-lo de tots els grups als quals pertany. Com que els \u00fanics objectes que es representen es troben en all_sprites , el jugador ja no es renderitzar\u00e0. Una vegada que el jugador haja perdur, tamb\u00e9 haurem d'eixir del joc, de manera que configureu running = False per ixir del bucle del joc. Velocitat del joc En provar el joc, potser vos haureu adonat que els enemics es mouen massa r\u00e0pid. Si no, tranquils, ja que el joc s'executar\u00e0 a diferents velocitats segons el hardware subjacent, el sistema operatiu, etc. La ra\u00f3 d'aix\u00f2 \u00e9s que el bucle del joc processa els fotogrames tan r\u00e0pidament com el processador i l'entorn ho permeten. Com que tots els sprites es mouen una vegada per fotograma, es poden moure centenars de vegades cada segon. El nombre de fotogrames que es manegen cada segon s\u2019anomena velocitat de fotogrames ( frame rate ), un terme molt utilitzat pels gamers. Aconseguir-ne un adequat \u00e9s la difer\u00e8ncia entre un joc jugable i un altre que no ho \u00e9s. Normalment, volem una freq\u00fc\u00e8ncia de fotogrames el m\u00e9s alta possible, per poder apreciar el major nombre de detalls, per\u00f2, per a aquest joc, cal reduir-lo un poc perqu\u00e8 el joc es puga jugar. Afortunadament, el m\u00f2dul de temps de Python cont\u00e9 un rellotge dissenyat exactament per a aquest prop\u00f2sit. L\u2019\u00fas del rellotge per establir una velocitat de fotogrames reprodu\u00efble requereix nom\u00e9s dues l\u00ednies de codi. El primer crea un rellotge nou abans que comence el bucle del joc. Despr\u00e9s utilitzem la funci\u00f3 .tick() per informar a pygame que el programa ha arribat al final del fotograma. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Setup the clock for a decent framerate clock = pygame . time . Clock () ... # Our main loop while running : ... # Flip everything to the display pygame . display . flip () # Ensure program maintains a rate of 30 frames per second clock . tick ( 30 ) L'argument passat a .tick() estableix la velocitat de fotogrames desitjada. Per fer-ho, es calcula el nombre de mil\u00b7lisegons que ha de tardar cada fotograma, en funci\u00f3 de la velocitat de fotogrames desitjada. A continuaci\u00f3, compara aquest nombre amb el nombre de mil\u00b7lisegons que han passat des de la darrera vegada que es va cridar .tick() . Si no ha passat prou temps, retarda el processament per assegurar-se que mai no supera la velocitat de fotogrames especificada. Si es passa una freq\u00fc\u00e8ncia de fotogrames m\u00e9s xicoteta, transcorrer\u00e0 m\u00e9s temps entre fotogrames, mentre que una freq\u00fc\u00e8ncia de fotogrames m\u00e9s gran proporcionar\u00e0 un joc m\u00e9s suau (i m\u00e9s r\u00e0pid). En aquest moment, tenim un joc totalment funcional i jugable.","title":"Sprites"},{"location":"unitats/1-python/pr%C3%A0ctiques/3%20-%20Sprites/#sprites","text":"Al disseny del joc, el jugador comen\u00e7a per l\u2019esquerra i els obstacles entren per la dreta. Podeu representar tots els obstacles amb objectes de la superf\u00edcie per fer tot el dibuix m\u00e9s f\u00e0cil, per\u00f2 com sabeu on dibuixar-los? Com se sap si un obstacle ha xocat amb el jugador? Qu\u00e8 passa quan l'obstacle ix de la pantalla? Qu\u00e8 passa si voleu dibuixar imatges de fons que tamb\u00e9 es moguin? Qu\u00e8 passa si voleu que les vostres imatges siguen animades? Podeu gestionar totes aquestes situacions i molt m\u00e9s amb els sprites . En termes de programaci\u00f3, un sprite \u00e9s una representaci\u00f3 2D d'alguna cosa a la pantalla. Essencialment, \u00e9s una imatge. pygame proporciona una classe Sprite, que est\u00e0 dissenyada per contenir una o diverses representacions gr\u00e0fiques de qualsevol objecte de joc que vulgueu mostrar a la pantalla. Per utilitzar-lo, creeu una nova classe que herede d'Sprite. Aix\u00f2 us permet utilitzar els seus m\u00e8todes heredats.","title":"Sprites"},{"location":"unitats/1-python/pr%C3%A0ctiques/3%20-%20Sprites/#jugadors","text":"A continuaci\u00f3 s\u2019explica com s\u2019utilitzen els objectes Sprite amb el joc actual per definir el jugador. Python 1 2 3 4 5 6 7 8 # Define a Player object by extending pygame.sprite.Sprite # The surface drawn on the screen is now an attribute of 'player' class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . Surface (( 75 , 25 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect () Primer definiu Player ampliant pygame.sprite.Sprite. Despr\u00e9s .__ init __() utilitza .super() per cridar al constructor de la classe pare. A continuaci\u00f3, definim i inicialitzem .surf per mantindre la imatge que voleu mostrar, que actualment \u00e9s un quadre blanc. Tamb\u00e9 definim i inicialitzem .rect, que s'utilitzar\u00e0 m\u00e9s endavant. Per utilitzar aquesta nova classe, heu de crear un objecte nou i canviar tamb\u00e9 el codi de dibuix. Amplieu el bloc de codi seg\u00fcent per veure-ho tot junt: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 # Import the pygame module import pygame # Import pygame.locals for easier access to key coordinates # Updated to conform to flake8 and black standards from pygame.locals import ( K_UP , K_DOWN , K_LEFT , K_RIGHT , K_ESCAPE , KEYDOWN , QUIT , ) # Define constants for the screen width and height SCREEN_WIDTH = 800 SCREEN_HEIGHT = 600 # Define a player object by extending pygame.sprite.Sprite # The surface drawn on the screen is now an attribute of 'player' class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . Surface (( 75 , 25 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect () # Initialize pygame pygame . init () # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) # Instantiate player. Right now, this is just a rectangle. player = Player () # Variable to keep the main loop running running = True # Main loop while running : # for loop through the event queue for event in pygame . event . get (): # Check for KEYDOWN event if event . type == KEYDOWN : # If the Esc key is pressed, then exit the main loop if event . key == K_ESCAPE : running = False # Check for QUIT event. If QUIT, then set running to false. elif event . type == QUIT : running = False # Fill the screen with black screen . fill (( 0 , 0 , 0 )) # Draw the player on the screen #screen.blit(player.surf, (SCREEN_WIDTH/2, SCREEN_HEIGHT/2)) screen . blit ( player . surf , player . rect ) # Update the display pygame . display . flip ()","title":"Jugadors"},{"location":"unitats/1-python/pr%C3%A0ctiques/3%20-%20Sprites/#entrada-dusuari","text":"Fins ara, hem apr\u00e8s a configurar Pygame i dibuixar objectes a la pantalla. Ara comen\u00e7a la diversi\u00f3. Fareu que el joc es puga controlar mitjan\u00e7ant el teclat. Abans, haviem vist que pygame.event.get() retorna la llista dels esdeveniments de la cua, que analitzem per trobar els seus tipus. B\u00e9, aquesta no \u00e9s l\u2019\u00fanica manera de llegir les tecles. pygame tamb\u00e9 proporciona pygame.event.get_pressed() , que retorna un diccionari que cont\u00e9 tots els esdeveniments KEYDOWN actuals a la cua. Posar-ho al bucle del joc despr\u00e9s del bucle de gesti\u00f3 d'esdeveniments torna un diccionari que cont\u00e9 les tecles apretades al comen\u00e7ament de cada fotograma. A continuaci\u00f3, escrivim un m\u00e8tode a Player per analitzar aquest diccionari. Aix\u00f2 definir\u00e0 el comportament del sprite a partir de les tecles que es premen. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 # Get the set of keys pressed and check for user input pressed_keys = pygame . key . get_pressed () # Move the sprite based on user keypresses def update ( self , pressed_keys ): if pressed_keys [ K_UP ]: self . rect . move_ip ( 0 , - 5 ) if pressed_keys [ K_DOWN ]: self . rect . move_ip ( 0 , 5 ) if pressed_keys [ K_LEFT ]: self . rect . move_ip ( - 5 , 0 ) if pressed_keys [ K_RIGHT ]: self . rect . move_ip ( 5 , 0 ) K_UP, K_DOWN, K_LEFT i K_RIGHT corresponen a les tecles de les fletxes del teclat. Utilitzarem .move_ip() , que significa moure des del punt actual, i reb per par\u00e0metre el n\u00famero de pixels a moure's en horitzontal i en vertical com si es tractara d'un eix de coordenades. A continuaci\u00f3, cridem a .update() cada fotograma per moure el sprite del jugador en resposta a les pulsacions de tecles. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Main loop while running : # for loop through the event queue for event in pygame . event . get (): # Check for KEYDOWN event if event . type == KEYDOWN : # If the Esc key is pressed, then exit the main loop if event . key == K_ESCAPE : running = False # Check for QUIT event. If QUIT, then set running to false. elif event . type == QUIT : running = False # Get all the keys currently pressed pressed_keys = pygame . key . get_pressed () # Update the player sprite based on user keypresses player . update ( pressed_keys ) # Fill the screen with black screen . fill (( 0 , 0 , 0 )) Amb aix\u00f2, ja veiem que el Player es mou tant en horitzontal com en vertical. \u00c9s possible que noteu dos problemes: El rectangle del jugador es mou molt r\u00e0pid. Ho solucionarem m\u00e9s endavant. El rectangle del jugador pot ixir-se'n de la pantalla. Solucionem-ho ara. Per mantenir el jugador a la pantalla, cal afegir la l\u00f2gica per detectar les colisions entre el jugador i els l\u00edmits de la pantalla. Per fer-ho, comprovem si les coordenades del rectangle s\u2019han despla\u00e7at m\u00e9s enll\u00e0 del l\u00edmit de la pantalla. Si \u00e9s aix\u00ed, indiquem al programa que el torne a la vora, quedant la funci\u00f3 update com a continuaci\u00f3 s'indica: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Move the sprite based on user keypresses def update ( self , pressed_keys ): if pressed_keys [ K_UP ]: self . rect . move_ip ( 0 , - 5 ) if pressed_keys [ K_DOWN ]: self . rect . move_ip ( 0 , 5 ) if pressed_keys [ K_LEFT ]: self . rect . move_ip ( - 5 , 0 ) if pressed_keys [ K_RIGHT ]: self . rect . move_ip ( 5 , 0 ) # Keep player on the screen if self . rect . left < 0 : self . rect . left = 0 if self . rect . right > SCREEN_WIDTH : self . rect . right = SCREEN_WIDTH if self . rect . top <= 0 : self . rect . top = 0 if self . rect . bottom >= SCREEN_HEIGHT : self . rect . bottom = SCREEN_HEIGHT Ac\u00ed, en lloc d\u2019utilitzar .move() , nom\u00e9s heu de canviar les coordenades corresponents de .top, .bottom, .left o .right directament. Proveu-ho i veureu que el rectangle del reproductor ja no pot ixir-se'n de la pantalla.","title":"Entrada d\u2019usuari"},{"location":"unitats/1-python/pr%C3%A0ctiques/3%20-%20Sprites/#enemics","text":"Qu\u00e8 \u00e9s un joc sense enemics? Utilitzarem les mateixes t\u00e8cniques que ja hem apr\u00e8s per crear una classe enemiga b\u00e0sica i, a continuaci\u00f3, crearem moltes inst\u00e0ncies d'aquesta per a que el jugador intente evitar-les. Primer, importeu la llibreria random . A continuaci\u00f3, creeu una nova classe de sprite anomenada Enemy , seguint el mateix patr\u00f3 que utilitzarem per a Player : Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Import random for random numbers import random # Define the enemy object by extending pygame.sprite.Sprite # The surface you draw on the screen is now an attribute of 'enemy' class Enemy ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Enemy , self ) . __init__ () self . surf = pygame . Surface (( 20 , 10 )) self . surf . fill (( 255 , 255 , 255 )) self . rect = self . surf . get_rect ( center = ( random . randint ( SCREEN_WIDTH + 20 , SCREEN_WIDTH + 100 ), random . randint ( 0 , SCREEN_HEIGHT ), ) ) self . speed = random . randint ( 5 , 20 ) # Move the sprite based on speed # Remove the sprite when it passes the left edge of the screen def update ( self ): self . rect . move_ip ( - self . speed , 0 ) if self . rect . right < 0 : self . kill () Hi ha quatre difer\u00e8ncies notables entre Enemic i Jugador: Quan creem un enemic ho fem a una ubicaci\u00f3 aleat\u00f2ria al llarg de la vora dreta de la pantalla. Es troba en una posici\u00f3 entre 20 i 100 p\u00edxels de dist\u00e0ncia de la vora dreta i en algun lloc entre la vora superior i la inferior. De forma que al principi no ser\u00e0 visible i anir\u00e0 apareixent per la vora dreta de la pantalla. Definim una velocitat speed com un n\u00famero aleatori entre 5 i 20. Aix\u00f2 especifica la velocitat amb qu\u00e8 aquest enemic es mou cap al jugador. .update() no necessita arguments, ja que els enemics es mouen autom\u00e0ticament cap a l'esquerra a la velocitat aleat\u00f2ria definida quan es va crear i que ja no canvia. Comprovem si l'enemic s'ha mogut fora de la pantalla al sobrepassar la vora esquerra. Per assegurar-nos que l\u2019enemic estiga completament fora de la pantalla i que no desaparega mentre encara siga visible, comprovem que el costat dret de . rect haja sobrepassat el costat esquerre de la pantalla. Una vegada que l'enemic es troba fora de pantalla, cridem a .kill() per evitar anar consumint m\u00e9s recursos cada vegada. Qu\u00e8 fa .kill() ? Per saber-ho, estudiem els Sprite Groups .","title":"Enemics"},{"location":"unitats/1-python/pr%C3%A0ctiques/3%20-%20Sprites/#sprite-groups","text":"Una altra classe s\u00faper \u00fatil que proporciona Pygame s\u00f3n els Sprite Groups . Es tracta d'un objecte que cont\u00e9 un grup d'objectes Sprite. Aleshores, per qu\u00e8 utilitzar-lo? No podem fer el seguiment dels nostres objectes Sprite en una llista? B\u00e9, podem, per\u00f2 l\u2019avantatge d\u2019utilitzar un grup radica en els m\u00e8todes que exposa. Aquests m\u00e8todes ajuden a detectar si algun enemic ha xocat amb el jugador, cosa que facilita les actualitzacions. Vegem com crear Sprite Group . Creem dos objectes de grup diferents: El primer grup tindr\u00e0 tots els Sprite del joc. El segon grup tindr\u00e0 nom\u00e9s els objectes enemics. A continuaci\u00f3, es mostra el codi: Python 1 2 3 4 5 6 7 8 9 10 11 12 # Create the 'player' player = Player () # Create groups to hold enemy sprites and all sprites # - enemies is used for collision detection and position updates # - all_sprites is used for rendering enemies = pygame . sprite . Group () all_sprites = pygame . sprite . Group () all_sprites . add ( player ) # Variable to keep the main loop running running = True Quan cridem el m\u00e8tode .kill() , el Sprite s\u2019elimina de tots els grups als quals pertany. Aix\u00f2 tamb\u00e9 elimina les refer\u00e8ncies al Sprite, cosa que permet al garbage collector de Python recuperar la mem\u00f2ria quan siga necessari. Ara que teniu un grup all_sprites, podeu canviar la manera com es dibuixen els objectes. En lloc de cridar a .blit() nom\u00e9s amb Player, podem repintar tot sobre all_sprites: Python 1 2 3 4 5 6 7 8 9 # Fill the screen with black screen . fill (( 0 , 0 , 0 )) # Draw all sprites for entity in all_sprites : screen . blit ( entity . surf , entity . rect ) # Flip everything to the display pygame . display . flip () Ara, qualsevol objecte d' all_sprites es redibuixar\u00e0 a tots els fotogrames, ja sigui un enemic o un jugador. Nom\u00e9s hi ha un problema ... No tenim cap enemic. Podriem crear un munt d\u2019enemics al principi del joc, per\u00f2 el joc es tornaria complicad\u00edssim a l'apareixer tots junts. En el seu lloc, explorem com mantenir un subministrament constant d\u2019enemics que arriben a mesura que avance el joc.","title":"Sprite Groups"},{"location":"unitats/1-python/pr%C3%A0ctiques/3%20-%20Sprites/#esdeveniments-personalitzats","text":"El disseny demana que apareguen enemics a intervals regulars. Aix\u00f2 significa que, a intervals establerts, hem de fer dues coses: Crea un enemic nou. Afegiu-lo a all_sprites i a enemics. (Sprite Groups) Ja teniu codi que gestiona esdeveniments aleatoris. El bucle d'esdeveniments est\u00e0 dissenyat per buscar esdeveniments aleatoris que es produeixen a cada fotograma i tractar-los adequadament. Per sort, pygame no us limita a utilitzar nom\u00e9s els tipus d\u2019esdeveniments que t\u00e9 predefinits. Podeu definir els vostres propis esdeveniments per gestionar-los segons convinga. Vegem com es crea un esdeveniment personalitzat que es genera cada pocs segons. Podeu crear un esdeveniment personalitzat com es mostra a continuaci\u00f3: Python 1 2 3 4 5 6 7 8 9 10 # Create the screen object # The size is determined by the constant SCREEN_WIDTH and SCREEN_HEIGHT screen = pygame . display . set_mode (( SCREEN_WIDTH , SCREEN_HEIGHT )) # Create a custom event for adding a new enemy ADDENEMY = pygame . USEREVENT + 1 pygame . time . set_timer ( ADDENEMY , 250 ) # Instantiate player. Right now, this is just a rectangle. player = Player () pygame defineix els esdeveniments internament com a enters, de manera que cal definir un nou esdeveniment amb un enter \u00fanic. L'\u00faltim esdeveniment reservat a Pygame es diu USEREVENT , de manera que definir ADDENEMY = pygame.USEREVENT + 1 garanteix que siga \u00fanic. A continuaci\u00f3, heu d'insertar aquest nou esdeveniment a la cua d'esdeveniments a intervals regulars durant tot el joc. Necessitem d'alguna forma gestionar el temps, per aix\u00f2 utilitzarem el m\u00f2dul de temps. Disparem el nou esdeveniment ADDENEMY cada 250 mil\u00b7lisegons, o quatre vegades per segon. Per aix\u00f2 farem una crida a .set_timer() fora del bucle del joc, ja que nom\u00e9s necessitem un temporitzador, per\u00f2 es disparar\u00e0 durant tot el joc cada 250 milisegons. Afegim el codi per gestionar el nostre nou esdeveniment. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Main loop while running : # Look at every event in the queue for event in pygame . event . get (): # Did the user hit a key? if event . type == KEYDOWN : # Was it the Escape key? If so, stop the loop. if event . key == K_ESCAPE : running = False # Did the user click the window close button? If so, stop the loop. elif event . type == QUIT : running = False # Add a new enemy? elif event . type == ADDENEMY : # Create the new enemy and add it to sprite groups new_enemy = Enemy () enemies . add ( new_enemy ) all_sprites . add ( new_enemy ) # Get the set of keys pressed and check for user input pressed_keys = pygame . key . get_pressed () player . update ( pressed_keys ) # Update enemy position enemies . update () Sempre que el gestor d'esdeveniments veu el nou esdeveniment ADDENEMY, crea un enemic i l'afegeix a enemies i a all_sprites . Com que Enemy est\u00e0 en all_sprites , es dibuixar\u00e0 a cada fotograma. Tamb\u00e9 heu de cridar a enemies.update() , que actualitza totes les posicions dels enemics.","title":"Esdeveniments personalitzats"},{"location":"unitats/1-python/pr%C3%A0ctiques/3%20-%20Sprites/#deteccio-de-collisions","text":"El disseny del joc demana que finalitze el joc sempre que un enemic xoque amb el jugador. La comprovaci\u00f3 de col\u00b7lisions \u00e9s una t\u00e8cnica b\u00e0sica de programaci\u00f3 de jocs i, en general, requereix alguns c\u00e0lculs matem\u00e0tics per determinar si dos sprites se superposaran. Aqu\u00ed \u00e9s on resulta \u00fatil un framework com Pygame. Escriure un codi de detecci\u00f3 de col\u00b7lisions \u00e9s tedi\u00f3s, per\u00f2 Pygame t\u00e9 MOLTS m\u00e8todes de detecci\u00f3 de col\u00b7lisions disponibles per utilitzar-los. Per a aquest tutorial, utilitzeu un m\u00e8tode anomenat .spritecollideany() , que detecta qualsevol col\u00b7lisi\u00f3 entre un sprite i els sprites d'un grup. Accepta un Sprite i un Grup com a par\u00e0metres. Comprova les superposicions entre tots els .rect del grup i el .rect de l'sprite. Si \u00e9s aix\u00ed, torna True, \u00e9s a dir si detecta col\u00b7lisi\u00f3. En cas contrari, torna False. Aix\u00f2 s'ajusta perfectament a aquest joc, ja que hem de comprovar si un sol jugador xoca amb un grup d'enemics. Vegem el codi: Python 1 2 3 4 5 6 7 8 9 # Draw all sprites for entity in all_sprites : screen . blit ( entity . surf , entity . rect ) # Check if any enemies have collided with the player if pygame . sprite . spritecollideany ( player , enemies ): # If so, then remove the player and stop the loop player . kill () running = False Es comprova si el jugador ha xocat amb algun enemic. Si \u00e9s aix\u00ed, es crida a player.kill() per eliminar-lo de tots els grups als quals pertany. Com que els \u00fanics objectes que es representen es troben en all_sprites , el jugador ja no es renderitzar\u00e0. Una vegada que el jugador haja perdur, tamb\u00e9 haurem d'eixir del joc, de manera que configureu running = False per ixir del bucle del joc.","title":"Detecci\u00f3 de col\u00b7lisions"},{"location":"unitats/1-python/pr%C3%A0ctiques/3%20-%20Sprites/#velocitat-del-joc","text":"En provar el joc, potser vos haureu adonat que els enemics es mouen massa r\u00e0pid. Si no, tranquils, ja que el joc s'executar\u00e0 a diferents velocitats segons el hardware subjacent, el sistema operatiu, etc. La ra\u00f3 d'aix\u00f2 \u00e9s que el bucle del joc processa els fotogrames tan r\u00e0pidament com el processador i l'entorn ho permeten. Com que tots els sprites es mouen una vegada per fotograma, es poden moure centenars de vegades cada segon. El nombre de fotogrames que es manegen cada segon s\u2019anomena velocitat de fotogrames ( frame rate ), un terme molt utilitzat pels gamers. Aconseguir-ne un adequat \u00e9s la difer\u00e8ncia entre un joc jugable i un altre que no ho \u00e9s. Normalment, volem una freq\u00fc\u00e8ncia de fotogrames el m\u00e9s alta possible, per poder apreciar el major nombre de detalls, per\u00f2, per a aquest joc, cal reduir-lo un poc perqu\u00e8 el joc es puga jugar. Afortunadament, el m\u00f2dul de temps de Python cont\u00e9 un rellotge dissenyat exactament per a aquest prop\u00f2sit. L\u2019\u00fas del rellotge per establir una velocitat de fotogrames reprodu\u00efble requereix nom\u00e9s dues l\u00ednies de codi. El primer crea un rellotge nou abans que comence el bucle del joc. Despr\u00e9s utilitzem la funci\u00f3 .tick() per informar a pygame que el programa ha arribat al final del fotograma. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Setup the clock for a decent framerate clock = pygame . time . Clock () ... # Our main loop while running : ... # Flip everything to the display pygame . display . flip () # Ensure program maintains a rate of 30 frames per second clock . tick ( 30 ) L'argument passat a .tick() estableix la velocitat de fotogrames desitjada. Per fer-ho, es calcula el nombre de mil\u00b7lisegons que ha de tardar cada fotograma, en funci\u00f3 de la velocitat de fotogrames desitjada. A continuaci\u00f3, compara aquest nombre amb el nombre de mil\u00b7lisegons que han passat des de la darrera vegada que es va cridar .tick() . Si no ha passat prou temps, retarda el processament per assegurar-se que mai no supera la velocitat de fotogrames especificada. Si es passa una freq\u00fc\u00e8ncia de fotogrames m\u00e9s xicoteta, transcorrer\u00e0 m\u00e9s temps entre fotogrames, mentre que una freq\u00fc\u00e8ncia de fotogrames m\u00e9s gran proporcionar\u00e0 un joc m\u00e9s suau (i m\u00e9s r\u00e0pid). En aquest moment, tenim un joc totalment funcional i jugable.","title":"Velocitat del joc"},{"location":"unitats/1-python/pr%C3%A0ctiques/4%20-%20Imatges/","text":"Imatges dels Sprites Molt b\u00e9, tens un joc, per\u00f2 siguem sincers ... L'aspecte no \u00e9s massa amigable. El jugador i els enemics s\u00f3n nom\u00e9s blocs blancs sobre fons negre. Va ser una revoluci\u00f3 quan va apar\u00e8ixer el Pong el 1972, per\u00f2 ha quedat antiquat. Anem a substituir aquests rectangles blancs per unes imatges que faran el joc m\u00e9s amigable. Anem a carregar una imatge d'un avi\u00f3 per al jugador i alguns m\u00edssils per als enemics, encara que podeu utilitzar altres per personalitzar el vostre joc. Alteraci\u00f3 dels constructors d'objectes Abans d\u2019utilitzar imatges per representar el jugador i els sprites enemics, hem de fer alguns canvis als seus constructors. El codi seg\u00fcent substitueix el codi utilitzat anteriorment. Python 1 2 3 4 5 6 class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . image . load ( \"resources/jet.png\" ) . convert () self . surf . set_colorkey (( 255 , 255 , 255 ), RLEACCEL ) self . rect = self . surf . get_rect () Amb pygame.image.load() carreguem una imatge del disc. Li passem com a argument el path a l'arxiu. Retorna una superf\u00edcie i la crida .convert() optimitza la superf\u00edcie, fent que les futures crides al m\u00e8tode .blit() siguen m\u00e9s r\u00e0pides. Amb .set_colorkey() indiquem quin color es far\u00e0 transparent. En aquest cas, triem el blanc, perqu\u00e8 \u00e9s el color de fons de la imatge. La constant RLEACCEL \u00e9s un par\u00e0metre opcional que ajuda a renderitzar pygame m\u00e9s r\u00e0pidament en pantalles no accelerades. Per poder utilitzar esta constant, necessitem importar-la a la declaraci\u00f3 d\u2019importaci\u00f3 de pygame.locals del principi del codi. No hem de canviar res m\u00e9s, la imatge continua sent una superf\u00edcie, tret que ara hi ha una imatge pintada. Farem el mateix al constructor d'enemic, esta vegada carregant la imatge resources/missile.png . Afegir imatges de fons Afegirem ara uns n\u00favols com a imatges de fons, utilitzant els mateixos passos que per a Player i Enemy: Creem la classe Cloud. Afegim la imatge d\u2019un n\u00favol. Creem un m\u00e8tode .update() que mou el n\u00favol cap a la part esquerra de la pantalla 5 p\u00edxels en cada fotograma. Creem un gestor i un esdeveniment personalitzats per crear objectes de n\u00favol nous a un interval de temps definit de 1000ms. Afegim els objectes de n\u00favols creats a un grup nou anomenat n\u00favols. Actualitzem i dibuixem els n\u00favols al bucle principal del joc. Tingueu en compte que cada n\u00favol i enemic nous s\u2019afegeixen a all_sprites , mentre que els n\u00favols ho fan al grup clouds i els enemics a enemies . Perqu\u00e8? El renderitzat (repintat) es fa amb all_sprites. Les actualitzacions de posici\u00f3 es fan a n\u00favols i enemics. La detecci\u00f3 de col\u00b7lisions es fa entre el jugador i enemics, per\u00f2 no amb n\u00favols, ja que un avi\u00f3 pot atrevessar n\u00favols sense problemes. Per \u00faltim canvieu el color de fons del negre a (135, 206, 250).","title":"Imatges"},{"location":"unitats/1-python/pr%C3%A0ctiques/4%20-%20Imatges/#imatges-dels-sprites","text":"Molt b\u00e9, tens un joc, per\u00f2 siguem sincers ... L'aspecte no \u00e9s massa amigable. El jugador i els enemics s\u00f3n nom\u00e9s blocs blancs sobre fons negre. Va ser una revoluci\u00f3 quan va apar\u00e8ixer el Pong el 1972, per\u00f2 ha quedat antiquat. Anem a substituir aquests rectangles blancs per unes imatges que faran el joc m\u00e9s amigable. Anem a carregar una imatge d'un avi\u00f3 per al jugador i alguns m\u00edssils per als enemics, encara que podeu utilitzar altres per personalitzar el vostre joc.","title":"Imatges dels Sprites"},{"location":"unitats/1-python/pr%C3%A0ctiques/4%20-%20Imatges/#alteracio-dels-constructors-dobjectes","text":"Abans d\u2019utilitzar imatges per representar el jugador i els sprites enemics, hem de fer alguns canvis als seus constructors. El codi seg\u00fcent substitueix el codi utilitzat anteriorment. Python 1 2 3 4 5 6 class Player ( pygame . sprite . Sprite ): def __init__ ( self ): super ( Player , self ) . __init__ () self . surf = pygame . image . load ( \"resources/jet.png\" ) . convert () self . surf . set_colorkey (( 255 , 255 , 255 ), RLEACCEL ) self . rect = self . surf . get_rect () Amb pygame.image.load() carreguem una imatge del disc. Li passem com a argument el path a l'arxiu. Retorna una superf\u00edcie i la crida .convert() optimitza la superf\u00edcie, fent que les futures crides al m\u00e8tode .blit() siguen m\u00e9s r\u00e0pides. Amb .set_colorkey() indiquem quin color es far\u00e0 transparent. En aquest cas, triem el blanc, perqu\u00e8 \u00e9s el color de fons de la imatge. La constant RLEACCEL \u00e9s un par\u00e0metre opcional que ajuda a renderitzar pygame m\u00e9s r\u00e0pidament en pantalles no accelerades. Per poder utilitzar esta constant, necessitem importar-la a la declaraci\u00f3 d\u2019importaci\u00f3 de pygame.locals del principi del codi. No hem de canviar res m\u00e9s, la imatge continua sent una superf\u00edcie, tret que ara hi ha una imatge pintada. Farem el mateix al constructor d'enemic, esta vegada carregant la imatge resources/missile.png .","title":"Alteraci\u00f3 dels constructors d'objectes"},{"location":"unitats/1-python/pr%C3%A0ctiques/4%20-%20Imatges/#afegir-imatges-de-fons","text":"Afegirem ara uns n\u00favols com a imatges de fons, utilitzant els mateixos passos que per a Player i Enemy: Creem la classe Cloud. Afegim la imatge d\u2019un n\u00favol. Creem un m\u00e8tode .update() que mou el n\u00favol cap a la part esquerra de la pantalla 5 p\u00edxels en cada fotograma. Creem un gestor i un esdeveniment personalitzats per crear objectes de n\u00favol nous a un interval de temps definit de 1000ms. Afegim els objectes de n\u00favols creats a un grup nou anomenat n\u00favols. Actualitzem i dibuixem els n\u00favols al bucle principal del joc. Tingueu en compte que cada n\u00favol i enemic nous s\u2019afegeixen a all_sprites , mentre que els n\u00favols ho fan al grup clouds i els enemics a enemies . Perqu\u00e8? El renderitzat (repintat) es fa amb all_sprites. Les actualitzacions de posici\u00f3 es fan a n\u00favols i enemics. La detecci\u00f3 de col\u00b7lisions es fa entre el jugador i enemics, per\u00f2 no amb n\u00favols, ja que un avi\u00f3 pot atrevessar n\u00favols sense problemes. Per \u00faltim canvieu el color de fons del negre a (135, 206, 250).","title":"Afegir imatges de fons"},{"location":"unitats/1-python/pr%C3%A0ctiques/5%20-%20So/","text":"Efectes de so Fins ara ens hem centrat en el joc i els aspectes visuals del mateix. Ara anem a veure com incorporar sons. pygame proporciona un mesclador per gestionar totes les activitats relacionades amb el so. Utilitzar\u00e0 les classes i m\u00e8todes d\u2019aquest m\u00f2dul per proporcionar m\u00fasica de fons i efectes de so per a diverses accions. El nom de mesclador fa refer\u00e8ncia al fet que el m\u00f2dul barreja diversos sons en un tot cohesionat. Mitjan\u00e7ant el subm\u00f2dul de m\u00fasica, podeu reproduir fitxers de so individuals en diversos formats. Tota la reproducci\u00f3 es produeix en segon pla, de manera que mentre es reprodueix un so, el m\u00e8tode s'executa en paral\u00b7lel i torna el control immediatament al punt on s'ha fet la crida. Inicialitzaci\u00f3 L'\u00fas del mesclador comen\u00e7a amb la seua inicialitzaci\u00f3 pygame.mixer.init() . Si no volem canviar els valors per defecte, no cal passar-li arguments. S'ha d'inicialitzar el mesclador abans que el pygame. Python 1 2 3 4 5 # Setup for sounds. Defaults are good. pygame . mixer . init () # Initialize pygame pygame . init () M\u00fasica de fons Una vegada inicialitzat el sistema, podeu configurar els vostres sons i m\u00fasica de fons com es mostra a continuaci\u00f3. Python 1 2 3 4 5 6 7 8 9 # Load and play background music pygame . mixer . music . load ( \"Apoxode_-_Electric_1.ogg\" ) pygame . mixer . music . play ( loops =- 1 ) # Load all sound files # Sound sources: Jon Fincher move_up_sound = pygame . mixer . Sound ( \"Rising_putter.ogg\" ) move_down_sound = pygame . mixer . Sound ( \"Falling_putter.ogg\" ) collision_sound = pygame . mixer . Sound ( \"Collision.ogg\" ) Carreguen un clip de so de fons i comencen a reproduir-lo. Podeu dir al clip de so que es reproduisca en bucle i que no acabe mai establint el par\u00e0metre loop = -1 . Sons d'esdeveniments Despr\u00e9s carreguen tres sons que farem servir per a diversos efectes de so. Els dos primers s\u00f3n sons ascendents i descendents, que es reprodueixen quan el jugador es mou cap amunt o cap avall. L\u2019\u00faltim \u00e9s el so que s\u2019utilitza sempre que hi ha una col\u00b7lisi\u00f3. Tamb\u00e9 podeu afegir altres sons, com ara un so per a la creaci\u00f3 d'un enemic o un so final per a la finalitzaci\u00f3 del joc. Llavors, com s\u2019utilitzen els efectes de so? Volem reproduir cada so quan es produeixi un esdeveniment determinat. Per exemple, quan l'avi\u00f3 es mou cap amunt, volem reproduir move_up_sound. Per tant, afegiu una crida a .play() sempre que gestioneu este l'esdeveniment. Per a una col\u00b7lisi\u00f3 entre el jugador i un enemic, reprodu\u00efu el so Collisions.ogg . Utilitzeu el m\u00e8tode stop() quan vulgau parar un so que encara s'est\u00e0 reproduint i no voleu que es mescle amb un nou. Fi del joc Finalment, quan acabe el joc, tots els sons haurien de parar-se. Per fer-ho, afegiu les l\u00ednies seg\u00fcents al final del programa despr\u00e9s del bucle: Python 1 2 3 # All done! Stop and quit the mixer. pygame . mixer . music . stop () pygame . mixer . quit () T\u00e8cnicament, aquestes \u00faltimes l\u00ednies no s\u00f3n necess\u00e0ries, ja que el programa finalitza i els recursos s'alliberen. No obstant aix\u00f2, si m\u00e9s endavant decidiu afegir una pantalla d'introducci\u00f3 o una pantalla d'eixida al vostre joc, \u00e9s possible que hi haja m\u00e9s codi executat-se despr\u00e9s que finalitze el joc.","title":"Sons"},{"location":"unitats/1-python/pr%C3%A0ctiques/5%20-%20So/#efectes-de-so","text":"Fins ara ens hem centrat en el joc i els aspectes visuals del mateix. Ara anem a veure com incorporar sons. pygame proporciona un mesclador per gestionar totes les activitats relacionades amb el so. Utilitzar\u00e0 les classes i m\u00e8todes d\u2019aquest m\u00f2dul per proporcionar m\u00fasica de fons i efectes de so per a diverses accions. El nom de mesclador fa refer\u00e8ncia al fet que el m\u00f2dul barreja diversos sons en un tot cohesionat. Mitjan\u00e7ant el subm\u00f2dul de m\u00fasica, podeu reproduir fitxers de so individuals en diversos formats. Tota la reproducci\u00f3 es produeix en segon pla, de manera que mentre es reprodueix un so, el m\u00e8tode s'executa en paral\u00b7lel i torna el control immediatament al punt on s'ha fet la crida.","title":"Efectes de so"},{"location":"unitats/1-python/pr%C3%A0ctiques/5%20-%20So/#inicialitzacio","text":"L'\u00fas del mesclador comen\u00e7a amb la seua inicialitzaci\u00f3 pygame.mixer.init() . Si no volem canviar els valors per defecte, no cal passar-li arguments. S'ha d'inicialitzar el mesclador abans que el pygame. Python 1 2 3 4 5 # Setup for sounds. Defaults are good. pygame . mixer . init () # Initialize pygame pygame . init ()","title":"Inicialitzaci\u00f3"},{"location":"unitats/1-python/pr%C3%A0ctiques/5%20-%20So/#musica-de-fons","text":"Una vegada inicialitzat el sistema, podeu configurar els vostres sons i m\u00fasica de fons com es mostra a continuaci\u00f3. Python 1 2 3 4 5 6 7 8 9 # Load and play background music pygame . mixer . music . load ( \"Apoxode_-_Electric_1.ogg\" ) pygame . mixer . music . play ( loops =- 1 ) # Load all sound files # Sound sources: Jon Fincher move_up_sound = pygame . mixer . Sound ( \"Rising_putter.ogg\" ) move_down_sound = pygame . mixer . Sound ( \"Falling_putter.ogg\" ) collision_sound = pygame . mixer . Sound ( \"Collision.ogg\" ) Carreguen un clip de so de fons i comencen a reproduir-lo. Podeu dir al clip de so que es reproduisca en bucle i que no acabe mai establint el par\u00e0metre loop = -1 .","title":"M\u00fasica de fons"},{"location":"unitats/1-python/pr%C3%A0ctiques/5%20-%20So/#sons-desdeveniments","text":"Despr\u00e9s carreguen tres sons que farem servir per a diversos efectes de so. Els dos primers s\u00f3n sons ascendents i descendents, que es reprodueixen quan el jugador es mou cap amunt o cap avall. L\u2019\u00faltim \u00e9s el so que s\u2019utilitza sempre que hi ha una col\u00b7lisi\u00f3. Tamb\u00e9 podeu afegir altres sons, com ara un so per a la creaci\u00f3 d'un enemic o un so final per a la finalitzaci\u00f3 del joc. Llavors, com s\u2019utilitzen els efectes de so? Volem reproduir cada so quan es produeixi un esdeveniment determinat. Per exemple, quan l'avi\u00f3 es mou cap amunt, volem reproduir move_up_sound. Per tant, afegiu una crida a .play() sempre que gestioneu este l'esdeveniment. Per a una col\u00b7lisi\u00f3 entre el jugador i un enemic, reprodu\u00efu el so Collisions.ogg . Utilitzeu el m\u00e8tode stop() quan vulgau parar un so que encara s'est\u00e0 reproduint i no voleu que es mescle amb un nou.","title":"Sons d'esdeveniments"},{"location":"unitats/1-python/pr%C3%A0ctiques/5%20-%20So/#fi-del-joc","text":"Finalment, quan acabe el joc, tots els sons haurien de parar-se. Per fer-ho, afegiu les l\u00ednies seg\u00fcents al final del programa despr\u00e9s del bucle: Python 1 2 3 # All done! Stop and quit the mixer. pygame . mixer . music . stop () pygame . mixer . quit () T\u00e8cnicament, aquestes \u00faltimes l\u00ednies no s\u00f3n necess\u00e0ries, ja que el programa finalitza i els recursos s'alliberen. No obstant aix\u00f2, si m\u00e9s endavant decidiu afegir una pantalla d'introducci\u00f3 o una pantalla d'eixida al vostre joc, \u00e9s possible que hi haja m\u00e9s codi executat-se despr\u00e9s que finalitze el joc.","title":"Fi del joc"},{"location":"unitats/1-python/pr%C3%A0ctiques/6%20-%20Conclusi%C3%B3/","text":"Conclusi\u00f3 Al llarg d\u2019aquesta pr\u00e0ctica, hem apr\u00e8s els fonaments de la programaci\u00f3 de jocs amb pygame. Concretament: Implementar bucles d'esdeveniments Dibuixar elements a la pantalla Reproduir efectes de so i m\u00fasica Gestionar l'entrada de l'usuari Per fer-ho, hem utilitzat un subconjunt dels m\u00f2duls Pygame, inclosos els m\u00f2duls de visualitzaci\u00f3, mesclador i m\u00fasica, hora, imatge i esdeveniment. Tamb\u00e9 hem utilitzat diverses classes, inclosos Rect, Surface, Sound i Sprite. Per\u00f2 aix\u00f2 nom\u00e9s \u00e9s una xicoteta part del que pot fer Pygame. Consulteu la documentaci\u00f3 oficial de Pygame per obtenir una llista completa de m\u00f2duls i classes disponibles.","title":"Conclusi\u00f3"},{"location":"unitats/1-python/pr%C3%A0ctiques/6%20-%20Conclusi%C3%B3/#conclusio","text":"Al llarg d\u2019aquesta pr\u00e0ctica, hem apr\u00e8s els fonaments de la programaci\u00f3 de jocs amb pygame. Concretament: Implementar bucles d'esdeveniments Dibuixar elements a la pantalla Reproduir efectes de so i m\u00fasica Gestionar l'entrada de l'usuari Per fer-ho, hem utilitzat un subconjunt dels m\u00f2duls Pygame, inclosos els m\u00f2duls de visualitzaci\u00f3, mesclador i m\u00fasica, hora, imatge i esdeveniment. Tamb\u00e9 hem utilitzat diverses classes, inclosos Rect, Surface, Sound i Sprite. Per\u00f2 aix\u00f2 nom\u00e9s \u00e9s una xicoteta part del que pot fer Pygame. Consulteu la documentaci\u00f3 oficial de Pygame per obtenir una llista completa de m\u00f2duls i classes disponibles.","title":"Conclusi\u00f3"},{"location":"unitats/1-python/pr%C3%A0ctiques/tasques/1%20-%20Obligatori/","text":"Part obligat\u00f2ria. Pr\u00e0ctica. (30%) Seguix la pr\u00e0ctica pas a pas i construeix el codi del joc. Per fer-ho seguix el mateix ordre que es va explicant al llarg de la pr\u00e0ctica i ves provant els canvis que vas introduint.","title":"Part obligat\u00f2ria (30%)"},{"location":"unitats/1-python/pr%C3%A0ctiques/tasques/1%20-%20Obligatori/#part-obligatoria-practica-30","text":"Seguix la pr\u00e0ctica pas a pas i construeix el codi del joc. Per fer-ho seguix el mateix ordre que es va explicant al llarg de la pr\u00e0ctica i ves provant els canvis que vas introduint.","title":"Part obligat\u00f2ria. Pr\u00e0ctica. (30%)"},{"location":"unitats/1-python/pr%C3%A0ctiques/tasques/2%20-%20Projecte/","text":"Part d'ampliaci\u00f3. Projecte. (70%) En esta segona part pots escollir entre dues opcions: Primera opci\u00f3 . Amplia la funcionalitat del joc dels avions: La primera ampliaci\u00f3 proposada \u00e9s un sistema de puntuacions que ser\u00e0 visible a la pantalla del joc. Cada vegada que s'esquive un m\u00edssil i aquest sobrepasse la part esquerra de la pantalla, es sumaran 10 punts al marcador. La segona ampliaci\u00f3 ser\u00e0 que el joc anir\u00e0 canviant cada 20 segons entre el dia i la nit , \u00e9s a dir, el fons canviar\u00e0 del blau del dia al negre de la nit autom\u00e0ticament. La tercera ampliaci\u00f3 ser\u00e0 un sistema de nivells . Cada vegada que el jugador supere un m\u00faltiple de 500 punts, el joc canviar\u00e0 a un nivell superior, comen\u00e7ant la partida en el nivell 1. A m\u00e9s, el nivell ser\u00e0 visible en la pantalla, al costat de la puntuaci\u00f3. La quarta ampliaci\u00f3 ser\u00e0 que la dificultat del joc anir\u00e0 creixent amb els nivells. Al principi del joc, es crearan enemics cada 500ms i la seua velocitat ser\u00e0 un n\u00famero aleatori entre 1 i 10. En el segon nivell, la velocitat de creaci\u00f3 seran 450 ms i les velocitats aniran entre 3 i 12. La idea \u00e9s parametritzar els valors segons el nivell, per exemple, per a la velocitat de creaci\u00f3 podria ser: \\[v_c = 100 + (450 - 50 * nivell)\\] \\[v_e = random(2 * nivell, 10 + 3 * nivell)\\] On \\(v_c\\) \u00e9s la velocitat de creaci\u00f3 d'enemics On \\(v_e\\) \u00e9s la velocitat de despla\u00e7ament dels enemics Fes que la puntuaci\u00f3, en cas de ser un nou r\u00e8cord, es guarde en un document de text anomenat punt_max.txt en la mateixa carpeta on est\u00e0 el codi del joc. Per a saber si \u00e9s un nou r\u00e8cord, quan es carrega el joc, haur\u00e0 de llegir el document i extraure la puntuaci\u00f3 m\u00e0xima. Afegeix una pantalla de benvinguda on es done la benvinguda al joc. A m\u00e9s, ha de mostrar el r\u00e8cord fins al moment i esperar fins que es polse la tecla p, moment en que es passar\u00e0 a la pantalla de joc. Fes una pantalla final on s'indique que la partida ha finalitzat, mostre la puntuaci\u00f3 i el nivell al que s'ha arribat, i en cas de ser r\u00e8cord, ho indique i felicite el jugador. Proposeu una funcionalitat extra al joc per fer-lo m\u00e9s interessant. Qualsevol funcionalitat que resulte interessant ser\u00e0 valorada positivament. Segona opci\u00f3 . Proposa la creaci\u00f3 d'un joc del teu gust del tipus que hem desenvolupat en la pr\u00e0ctica. Pots pensar en jocs tipus el Pong, el Tetris, ... Si agafes aquesta opci\u00f3 conta-li-la al professor abans de comen\u00e7ar a desenvolupar perqu\u00e8 et done l'aprovaci\u00f3 de la idea, ja que pot implicar una dificultat massa elevada o massa baixa. El joc hauria d'incloure tots els tractaments que hem anat desenvolupant durant la pr\u00e0ctica.","title":"Part d'ampliaci\u00f3 - projecte (70%)"},{"location":"unitats/1-python/pr%C3%A0ctiques/tasques/2%20-%20Projecte/#part-dampliacio-projecte-70","text":"En esta segona part pots escollir entre dues opcions: Primera opci\u00f3 . Amplia la funcionalitat del joc dels avions: La primera ampliaci\u00f3 proposada \u00e9s un sistema de puntuacions que ser\u00e0 visible a la pantalla del joc. Cada vegada que s'esquive un m\u00edssil i aquest sobrepasse la part esquerra de la pantalla, es sumaran 10 punts al marcador. La segona ampliaci\u00f3 ser\u00e0 que el joc anir\u00e0 canviant cada 20 segons entre el dia i la nit , \u00e9s a dir, el fons canviar\u00e0 del blau del dia al negre de la nit autom\u00e0ticament. La tercera ampliaci\u00f3 ser\u00e0 un sistema de nivells . Cada vegada que el jugador supere un m\u00faltiple de 500 punts, el joc canviar\u00e0 a un nivell superior, comen\u00e7ant la partida en el nivell 1. A m\u00e9s, el nivell ser\u00e0 visible en la pantalla, al costat de la puntuaci\u00f3. La quarta ampliaci\u00f3 ser\u00e0 que la dificultat del joc anir\u00e0 creixent amb els nivells. Al principi del joc, es crearan enemics cada 500ms i la seua velocitat ser\u00e0 un n\u00famero aleatori entre 1 i 10. En el segon nivell, la velocitat de creaci\u00f3 seran 450 ms i les velocitats aniran entre 3 i 12. La idea \u00e9s parametritzar els valors segons el nivell, per exemple, per a la velocitat de creaci\u00f3 podria ser: \\[v_c = 100 + (450 - 50 * nivell)\\] \\[v_e = random(2 * nivell, 10 + 3 * nivell)\\] On \\(v_c\\) \u00e9s la velocitat de creaci\u00f3 d'enemics On \\(v_e\\) \u00e9s la velocitat de despla\u00e7ament dels enemics Fes que la puntuaci\u00f3, en cas de ser un nou r\u00e8cord, es guarde en un document de text anomenat punt_max.txt en la mateixa carpeta on est\u00e0 el codi del joc. Per a saber si \u00e9s un nou r\u00e8cord, quan es carrega el joc, haur\u00e0 de llegir el document i extraure la puntuaci\u00f3 m\u00e0xima. Afegeix una pantalla de benvinguda on es done la benvinguda al joc. A m\u00e9s, ha de mostrar el r\u00e8cord fins al moment i esperar fins que es polse la tecla p, moment en que es passar\u00e0 a la pantalla de joc. Fes una pantalla final on s'indique que la partida ha finalitzat, mostre la puntuaci\u00f3 i el nivell al que s'ha arribat, i en cas de ser r\u00e8cord, ho indique i felicite el jugador. Proposeu una funcionalitat extra al joc per fer-lo m\u00e9s interessant. Qualsevol funcionalitat que resulte interessant ser\u00e0 valorada positivament. Segona opci\u00f3 . Proposa la creaci\u00f3 d'un joc del teu gust del tipus que hem desenvolupat en la pr\u00e0ctica. Pots pensar en jocs tipus el Pong, el Tetris, ... Si agafes aquesta opci\u00f3 conta-li-la al professor abans de comen\u00e7ar a desenvolupar perqu\u00e8 et done l'aprovaci\u00f3 de la idea, ja que pot implicar una dificultat massa elevada o massa baixa. El joc hauria d'incloure tots els tractaments que hem anat desenvolupant durant la pr\u00e0ctica.","title":"Part d'ampliaci\u00f3. Projecte. (70%)"},{"location":"unitats/1-python/pr%C3%A0ctiques/tasques/3%20-%20Qualificaci%C3%B3/","text":"Qualificaci\u00f3 Per a qualificar aquesta primera unitat, es valorar\u00e0 un 30% la part de pr\u00e0ctica obligat\u00f2ria i un 70% la part del projecte o ampliaci\u00f3. Per a la part del projecte s'utilitzar\u00e0 una r\u00fabrica que es posar\u00e0 a disposici\u00f3 dels alumnes abans de comen\u00e7ar el desenvolupament. D'esta forma, l'alumne podr\u00e0 saber anticipadament, els aspectes que es tindran en compte a l'hora de corregir. (Sols per a alumnes del presencial) A m\u00e9s, es realitzar\u00e0 una coavaluaci\u00f3. Per a fer a\u00e7\u00f2, cada alumne exposar\u00e0 en un per\u00edode breu, al voltant de 5 minuts el seu projecte, i la resta d'alumnes l'avaluaran.","title":"Qualificaci\u00f3"},{"location":"unitats/1-python/pr%C3%A0ctiques/tasques/3%20-%20Qualificaci%C3%B3/#qualificacio","text":"Per a qualificar aquesta primera unitat, es valorar\u00e0 un 30% la part de pr\u00e0ctica obligat\u00f2ria i un 70% la part del projecte o ampliaci\u00f3. Per a la part del projecte s'utilitzar\u00e0 una r\u00fabrica que es posar\u00e0 a disposici\u00f3 dels alumnes abans de comen\u00e7ar el desenvolupament. D'esta forma, l'alumne podr\u00e0 saber anticipadament, els aspectes que es tindran en compte a l'hora de corregir. (Sols per a alumnes del presencial) A m\u00e9s, es realitzar\u00e0 una coavaluaci\u00f3. Per a fer a\u00e7\u00f2, cada alumne exposar\u00e0 en un per\u00edode breu, al voltant de 5 minuts el seu projecte, i la resta d'alumnes l'avaluaran.","title":"Qualificaci\u00f3"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/","text":"Introducci\u00f3 a Python Comen\u00e7ant amb Python Qu\u00e8 \u00e9s Python? Python \u00e9s un llenguatge de prop\u00f2sit general, al igual que Java o C. El seu \u00fas ha augmentat durant els \u00faltims temps gr\u00e0cies a: La seua flexibilitat i simplicitat, que el fan f\u00e0cil d'aprendre El seu \u00fas extens en camps com el \"Data Science\", la IA i l'aprenentatge de programaci\u00f3. Llenguatge d'scripting d'alt nivell. Multiplataforma. Gran quantitat i varietat de llibreries. Web frameworks, clients correu, gestors de contingut, concurr\u00e8ncia, generaci\u00f3 de documents, gr\u00e0fics, intel\u00b7lig\u00e8ncia artificial, ... Lliure!! Mant\u00e9s per la Python Software Foundation Execuci\u00f3 de Python Perqu\u00e8 Python El llenguatge de programaci\u00f3 Python \u00e9s una opci\u00f3 cada vegada m\u00e9s utilitzada per principiants com per desenvolupadors experimentats. Flexible i vers\u00e0til, Python t\u00e9 punts forts en scripts, automatitzaci\u00f3, an\u00e0lisi de dades, aprenentatge autom\u00e0tic i desenvolupament de back-end. Publicat per primera vegada el 1991 amb un nom inspirat en el grup de com\u00e8dia brit\u00e0nic Monty Python, l\u2019equip de desenvolupament volia fer de Python un llenguatge divertit d\u2019utilitzar. C \u00e9s el llenguatge de programaci\u00f3 m\u00e9s popular a l\u2019\u00edndex TIOBE, mentre que Python \u00e9s el llenguatge m\u00e9s buscat a l\u2019\u00edndex PYPL. Python i Java segueixen de prop a C al TIOBE. A PYPL, la difer\u00e8ncia \u00e9s m\u00e9s gran, ja que Python, que ocupa el primer lloc, supera en un 12% a Java, que ocupa el segon lloc. Aquest curs, aprendrem a utilitzar Python i el framework Qt per desenvolupar aplicacions amb interf\u00edcie d'usuari. Instal\u00b7laci\u00f3 de Python 3 Anem a instal\u00b7lar a l'Ubuntu 20.04 un entorn de programaci\u00f3 Python 3, encara que valdr\u00e0 per a qualsevol distribuci\u00f3 basada en Debian Linux, com \u00e9s el cas. En cas d'utilitzar Windows o MacOS, busqueu la forma d'instal\u00b7lar-lo. Requisits previs Per poder instal\u00b7lar, haureu de tindre un usuari amb privilegis sudo en l'Ubuntu 20.04. Primer pas - Configurant Python 3 Ubuntu 20.04 ja inclou Python 3 preinstal\u00b7lat. Per assegurar-nos que les nostres versions estan actualitzades, actualitzem els repositoris i actualitzem el sistema amb l'ordre apt: Bash 1 2 $ sudo apt update $ sudo apt -y upgrade L'opci\u00f3 -y confirmar\u00e0 que estem d'acord per instal\u00b7lar totes les actualitzacions, per\u00f2, segons la vostra versi\u00f3 de Linux, \u00e9s possible que h\u00e0giu de confirmar les sol\u00b7licituds addicionals. Una vegada finalitzat el proc\u00e9s, podem comprovar la versi\u00f3 de Python 3 que s\u2019instal\u00b7la al sistema escrivint: Bash 1 2 $ python3 -V Python 3 .8.10 El terminal vos indicar\u00e0 el n\u00famero de versi\u00f3. No es tracta de l'\u00faltima versi\u00f3 estable de Python (3.9.7), per\u00f2 si de la \u00faltima disponibles als repositoris d'Ubuntu. Per gestionar paquets de programari per a Python, instal\u00b7leu pip, una eina que instal\u00b7lar\u00e0 i gestionar\u00e0 paquets de programaci\u00f3 que \u00e9s possible que vulguem utilitzar en els nostres projectes de desenvolupament. Bash 1 $ sudo apt install -y python3-pip Ara podrem utilitzar pip3 per instal\u00b7lar paquets de Python3. Bash 1 $ pip3 install \"paquet\" A m\u00e9s, instl\u00b7larem algunes llibreries necess\u00e0ries per a la construcci\u00f3 dels nostres m\u00f2duls i extensions. Bash 1 $ sudo apt install -y build-essential libssl-dev libffi-dev python3-dev Segon pas - Configurem un entorn virtual de desenvolupament Els entorns virtuals ens permeten tenir un espai a\u00efllat per a desenvolupament de projectes Python, cosa que garanteix que cadascun dels vostres projectes puga tindre el seu propi conjunt de depend\u00e8ncies que no interrompin cap dels vostres altres projectes. Configurar un entorn de programaci\u00f3 proporciona un major control sobre els projectes de Python i sobre com es gestionen les diferents versions dels paquets. Aix\u00f2 \u00e9s especialment important quan es treballa amb paquets de tercers. Podeu configurar tants entorns de programaci\u00f3 Python com vulgueu. Cada entorn \u00e9s b\u00e0sicament un directori que cont\u00e9 uns quants scripts per fer-lo actuar com a entorn a\u00efllat de la resta de programes i llibreries de l'ordinador. Tot i que hi ha algunes maneres d\u2019aconseguir un entorn de programaci\u00f3 a Python, farem servir el m\u00f2dul venv, que forma part de la biblioteca est\u00e0ndard de Python 3. Instal\u00b7lem venv escrivint: Bash 1 $ sudo apt install -y python3-venv Amb a\u00e7\u00f2, estem preparats per crear entorns virtuals (virtual environments) . Trieu en quin directori volem situar els nostres entorns de programaci\u00f3 Python o b\u00e9 creeu un directori nou amb mkdir: Bash 1 2 $ mkdir environments $ cd environments Una vegada esteu al directori on voleu que es creen els entorns, podeu crear un entorn executant l'ordre seg\u00fcent: Bash 1 $ python3 -m venv my_env Essencialment, pyvenv crea un nou directori que cont\u00e9 alguns elements: Bash 1 bin include lib lib64 pyvenv.cfg share Junts, aquests fitxers funcionen per assegurar-vos que els vostres projectes estiguen a\u00efllats, de manera que els fitxers del sistema i els fitxers de projecte no es mesclen i entren en conflicte. Aquesta \u00e9s una bona pr\u00e0ctica per al control de versions i per garantir que cadascun dels vostres projectes tinga acc\u00e9s als paquets particulars que necessita. Per utilitzar aquest entorn, l'heu d'activar, cosa que podeu aconseguir escrivint l'ordre seg\u00fcent que crida a l'script d'activaci\u00f3: Bash 1 $ source my_env/bin/activate El vostre indicador d\u2019ordres ara tindr\u00e0 el prefix amb el nom del vostre entorn, en aquest cas s\u2019anomena my_env. Depenent de la versi\u00f3 de Debian Linux que utilitzeu, el vostre prefix pot apar\u00e8ixer de manera diferent, per\u00f2 el nom del vostre entorn entre par\u00e8ntesis hauria de ser el primer que veieu a la vostra l\u00ednia: Aquest prefix ens permet saber que l\u2019entorn my_env est\u00e0 actiu actualment, \u00e9s a dir, que quan creem programes aqu\u00ed, nom\u00e9s utilitzaran la configuraci\u00f3 i els paquets d\u2019aquest entorn concret. Nota: a l\u2019entorn virtual, podeu utilitzar l\u2019ordre python en lloc de python3 i pip en lloc de pip3 si ho preferiu. Si utilitzeu Python 3 a la vostra m\u00e0quina fora d\u2019un entorn, haureu d\u2019utilitzar exclusivament les ordres python3 i pip3. Despr\u00e9s de seguir aquests passos, el vostre entorn virtual ja es pot utilitzar. Per a desactivar l'entorn virtual, simplement tanquem la consola o utilitzem l'ordre deactivate . Deapareixer\u00e0 el nom de l'entorn virtual abans del prompt. Modes d'execuci\u00f3 Interactiva a trav\u00e9s de l'int\u00e8rpret Bash 1 2 3 4 5 ~$ python3 Python 3 .7.3 ( default, Jul 25 2020 , 13 :03:44 ) [ GCC 8 .3.0 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> Execuci\u00f3 d'un fitxer Python Bash 1 2 ~$ python3 hola_mon.py Hola m\u00f3n Execuci\u00f3 d'un script Bash 1 2 3 4 5 6 7 8 9 hola_mon.py --- #!/usr/bin/env python3 print ( \"Hola m\u00f3n\" ) --- ~$ chmod u+x hola_mon.py ~$ ./hola_mon.py Hola m\u00f3n Des d'un Entorn de Desenvolupament IDE Activitat 1 Implementa el \"Hola m\u00f3n!\" i executa-lo de les quatre formes possibles. Paraules reservades i identificadors Paraules reservades No es poden utilitzar coma identificador de variables ni nom de funcions, ja que s'utilitzen per a definir la sintaxi i l'estructura d'un programa. Les paraules reservades s\u00f3n: False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield Per a obtindre la llista completa des de l'int\u00e8rpret: Python 1 2 >>> import keyword >>> print ( keyword . kwlist ) Identificadors Per convenci\u00f3, els noms de les variables i funcions han de ser: combinacions de lletres min\u00fascules i n\u00fameros comen\u00e7ar per lletra descriptius (excepte en bucles o se sol utilitzar i i j ) amb paraules separades per gui\u00f3 baix Per exemple: nom_usuari, numero_telefon, cognom1, sumar(), ... Recorda que Python \u00e9s un llenguatge case sensitive . Per tant Var i var no s\u00f3n el mateix identificador. Instruccions i sagnat Instruccions L'int\u00e8rpret de Python va executant l\u00ednia a l\u00ednia cada instrucci\u00f3. Si volem que una instrucci\u00f3 ocupe diverses l\u00ednies ho hem d'indicar amb el car\u00e0cter \\. Per exemple: Python 1 2 3 4 5 >>> a = 1 + 2 + 3 + \\ ... 4 + 5 + 6 + \\ ... 7 + 8 + 9 >>> print ( a ) 45 La continuaci\u00f3 de l\u00ednia \u00e9s implicita dins de par\u00e8ntesis (), corxets [] i claus {}. Python 1 2 3 colors = [ 'red' , 'blue' , 'green' ] Tamb\u00e9 podem posar diverses sent\u00e8ncies en una l\u00ednia: Python 1 a = 1 ; b = 2 ; c = 3 Sagnat La majoria de llenguatges de programaci\u00f3 utilitzen les claus {} per a definir blocs de codi. En canvi, Python utilitza el sagnat (identation). Un bloc de codi (cos d'una funci\u00f3, bucle, etc.) comen\u00e7a amb sagnat i acaba amb la primera l\u00ednia sense sagnat. Dep\u00e8n de vosaltres la quantitat de sagnat, per\u00f2 ha de ser coherent en tot el bloc. Generalment, s\u2019utilitzen quatre espais en blanc per a sagnat i es prefereixen a les tabulacions. El resultat \u00e9s un codi net i clar. Exemple: Python 1 2 3 4 for i in range ( 1 , 11 ): print ( i ) if i == 5 : break Un sagnat incorrecte llan\u00e7a un IndentationError . Comentaris Els comentaris s\u00f3n molt importants en escriure un programa. Descriuen el que passa dins d\u2019un programa, de manera que una persona que mira el codi font no tinga dificultats per entendre'l. A m\u00e9s, \u00e9s possible que oblideu els detalls clau d'implementaci\u00f3 del programa que acabeu d\u2019escriure. Per tant, invertir temps per explicar aquests conceptes en forma de comentaris sempre \u00e9s fruct\u00edfer . A Python, fem servir el s\u00edmbol coixinet (#) per comen\u00e7ar a escriure un comentari. S'est\u00e9n fins al car\u00e0cter de l\u00ednia nova. No cal que el comentari estiga a principi de l\u00ednia, pot estar en mig. Per fer comentaris multil\u00ednia, podem utilitzar el coixinet a principi de cada l\u00ednia. Tamb\u00e9 podem fer servir les cometes dobles o simples tres vegades. Exemple: Python 1 2 ''' Comentari multil\u00ednia''' Docstrings Una docstring \u00e9s una abreviatura de text de documentaci\u00f3. La documentaci\u00f3 de Python s\u00f3n els textos que apareixen just despr\u00e9s de la definici\u00f3 d'una funci\u00f3, m\u00e8tode, classe o m\u00f2dul. S'utilitzen cometes triples durant l'escriptura de la documentaci\u00f3. Per exemple: Python 1 2 3 def doble ( num ): \"\"\"Funci\u00f3 per duplicar el valor\"\"\" return 2 * num La documentaci\u00f3 s\u2019associa a l\u2019objecte com a atribut doc . Per tant, podem accedir a la documentaci\u00f3 de la funci\u00f3 anterior amb les seg\u00fcents l\u00ednies de codi: Python 1 2 3 4 def doble ( num ): \"\"\"Funci\u00f3 per duplicar el valor\"\"\" return 2 * num print ( doble . __ doc__ ) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def suma_binaria ( a , b ): ''' Torna la suma de dos enters en binari. Par\u00e0metres: a (int): Un enter b (int): Altre enter Torna: suma_binaria (str): String amb els digits binaris de la suma ''' suma_binaria = bin ( a + b )[ 2 :] return suma_binaria print ( suma_binaria . __doc__ ) Variables, constants i tipus Variables En Python, quan declarem una variable i li assignem un valor, realment estem creant un objecte i assignant un valor per refer\u00e8ncia. Python 1 2 3 4 5 6 >>> num = 10 >>> type ( num ) < class ' int '> >>> num = 10.0 >>> type ( num ) < class ' float '> Podem inicialitzar m\u00faltiples variables en una mateixa l\u00ednia, ja siga amb el mateix valor o diferent. Python 1 2 a , b , c = 5 , 3.2 , \"Hola\" x = y = z = \"iguals\" Constants A Python no existeixen les constants a l'estil de static final de Java, sin\u00f3 que simplement es defineix una variable que no es modifica el valor. Normalment es definixen en un m\u00f2dul a banda, utilitzant maj\u00fascules i gui\u00f3 baix si \u00e9s necessari, que s'importa a l'arxiu principal. Python 1 2 3 4 5 6 7 8 9 10 constants . py --- PI = 3.14 main . py --- import constants.py radi = 5 perimetre = 2 * constants . PI * radi print ( perimetre ) Tipus L'assignaci\u00f3 de tipus \u00e9s din\u00e0mica i pot canviar, per aix\u00f2 no declarem els tipus de les variables. Per determinar el tipus d'un objecte, fem servir el m\u00e8tode type() . Els tipus d'objecte definits a Python3 s\u00f3n: 1. Num\u00e8rics: 1.1. Integer Python 1 2 3 4 a = 0b1010 #Binary b = 100 #Decimal c = 0o310 #Octal d = 0x12c #Hexadecimal 1.2. Float Python 1 2 float_1 = 10.5 float_2 = 1.5e2 1.3. Complex Python 1 x = 3 + 4 j Strings Python 1 nom = 'Ferran Cunyat' Els principals m\u00e8todes sobre un string s\u00f3n capitalize(), count(), find(), format(), lower(), replace(), split(), title(), translate(), upper() . Boolean Python 1 2 3 4 x = ( 1 == True ) # True pren el valor num\u00e8ric 1, mentre que False el 0 y = ( 1 == False ) a = True + 4 b = False + 10 Especials (None) S'utilitza per no donar-li valor a una variable. Python 1 2 3 >>> x = None >>> type ( x ) < class ' NoneType '> Col\u00b7leccions Llista S\u00f3n una seq\u00fc\u00e8ncia d'elements, no necess\u00e0riament del mateix tipus, encara que normalment si que ho s\u00f3n. Es definix amb corxets i els elements separats per comes. Podem accedir a un element o un rang i \u00e9s mutable. Python 1 2 3 4 5 6 >>> a = [ 5 , 10 , 15 , 20 , 25 , 30 , 45 , 40 ] >>> print ( a ) [ 5 , 10 , 15 , 20 , 25 , 30 , 45 , 40 ] >>> a [ 3 ] = \"Ferran\" >>> print ( a [: 4 ]) [ 5 , 10 , 15 , 'Ferran' ] Algunes de les principals funcions que podem aplicar sobre llistes s\u00f3n apend(), clear(), copy(), extend(), insert(), remove(), reverse() . Tupla S\u00f3n una seq\u00fc\u00e8ncia d'elements, no necess\u00e0riament del mateix tipus, per\u00f2 esta vegada immutable. Python 1 2 3 4 5 >>> tupla = ( 2 , 'hola' ) >>> tupla [ 1 ] = 'clavel' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment Rang Seq\u00fc\u00e8ncia immutable de n\u00fameros, generalment utilitzada per a iterar sobre for o generar llistes r\u00e0pidament. Python 1 2 >>> list ( range ( 0 , 30 , 5 )) [ 0 , 5 , 10 , 15 , 20 , 25 ] 3 . Conjunt (Set) Col\u00b7lecci\u00f3 desordenada d'elements \u00fanics. Ja que \u00e9s una llista desordenada, no la podem indexar i per tant accedir als elements segons la seua posici\u00f3. Python 1 2 3 4 5 6 7 8 >>> a = { 2 , 2 , 5 , 5 , 4 , 10 , 1 , 0 } >>> print ( a ) { 0 , 1 , 2 , 4 , 5 , 10 } >>> a [ 1 ] Traceback ( most recent call last ): File \"<string>\" , line 301 , in runcode File \"<interactive input>\" , line 1 , in < module > TypeError : 'set' object does not support indexing Diccionari Diccionari \u00e9s una col\u00b7lecci\u00f3 no ordenada de parells valor-clau. Generalment s\u2019utilitza quan tenim una gran quantitat de dades. Els diccionaris estan optimitzats per recuperar dades. Hem de con\u00e8ixer la clau per recuperar el valor. A Python, els diccionaris es defineixen entre claus {} i cada element \u00e9s un parell que adopta la forma de clau:valor. La clau i el valor poden ser de qualsevol tipus. Python 1 2 3 4 5 6 7 8 9 10 11 >>> d = { 1 : 'valor' , 'clau' : 2 } >>> print ( type ( d )) < class ' dict '> >>> print ( \"d[1] = \" , d [ 1 ]); d [ 1 ] = valor >>> print ( \"d['clau'] = \" , d [ 'clau' ]); d [ 'clau' ] = 2 >>> print ( \"d[2] = \" , d [ 2 ]); Traceback ( most recent call last ): File \"<stdin>\" , line 2 , in < module > KeyError : 2 Activitat 2 Fixa't en el seg\u00fcent fragment de codi: Python 1 2 3 4 5 6 7 8 9 >>> s = [ 1 , 2 ] >>> r = s [:] >>> s [ 0 ] = 2 >>> print ( s ) [ 2 , 2 ] >>> print ( r ) ??? >>> print ( s ) ??? Quina ser\u00e0 l'eixida? Per qu\u00e9? Python 1 2 3 4 5 6 >>> r = s >>> s [ 0 ] = 5 >>> print ( r ) ??? >>> print ( s ) ??? I ara? Per qu\u00e9? Conversi\u00f3 entre tipus Conversi\u00f3 impl\u00edcita S\u00f3n conversions que fa el mateix llenguatge autom\u00e0ticament. Per exemple: Python 1 2 3 4 5 6 7 8 9 10 num_int = 123 num_flo = 1.23 num_nou = num_int + num_flo print ( \"num_int \u00e9s de tipus:\" , type ( num_int )) print ( \"num_flo \u00e9s de tipus:\" , type ( num_flo )) print ( \"Valor de num_nou:\" , num_nou ) print ( \"num_nou \u00e9s de tipus:\" , type ( num_nou )) Conversi\u00f3 expl\u00edcita Utilitzem funcions predefinides per a for\u00e7ar la conversi\u00f3 int(), float(), str(), ... . Activitat 3 Quin \u00e9s el resultat d'executar el seg\u00fcent fragment de codi? Python 1 2 3 >>> enter = 123 >>> cadena = \"456\" >>> suma = enter + cadena Definix dues variables, una per a fer la suma entera (579) i l'altra per a concatrenar com a text (123456). Entrada, eixida i import Entrada Ja hem vist que per a introduir informaci\u00f3 per teclat utilitzem la funci\u00f3 input([prompt]) . Eixida Per a imprimir per ella utilitzarem la funci\u00f3 print() . Moltes vegades s'utilitza en combinaci\u00f3 amb la funci\u00f3 format() dels strings. Python 1 2 3 4 5 >>> x = 5 ; y = 10 >>> print ( 'El valor d \\' x \u00e9s {} i el de y \u00e9s {} ' . format ( x , y )) >>> # Fixeu-se que hem escapat el caracter ' El valor d 'x \u00e9s 5 i el de y \u00e9s 10 >>> print ( 'Hola {nom} , {salutacio} ' . format ( salutacio = 'Bon dia' , nom = 'Pau' )) Activitat 4 Implementa el programa \"Hola m\u00f3n\" utilitzant la funci\u00f3 format. Import Quan volem fer \u00fas del codi d'un altre m\u00f2dul (.py), l'hem d'importar al programa actual amb import . Python 1 2 >>> import math >>> print ( math . pi ) Tamb\u00e9 podem importar sols alguna de les funcions o atributs amb from Python 1 >>> from math import pi En importar un m\u00f2dul, Python analitza diversos llocs definits a sys.path. \u00c9s una llista de les ubicacions on buscar el m\u00f2dul. Python 1 2 3 >>> import sys >>> sys . path [ '' , '/usr/lib/python37.zip' , '/usr/lib/python3.7' , '/usr/lib/python3.7/lib-dynload' , '/home/ferran/.local/lib/python3.7/site-packages' , '/usr/local/lib/python3.7/dist-packages' , '/usr/lib/python3/dist-packages' ] Per a importar d'una altra carpeta, ho fem amb from paquet import modul . Pots posar ubicacions absolutes o relatives. Si volem importar un codi d'una ubicaci\u00f3 que no est\u00e0 al path. Python 1 2 >>> import sys >>> sys . path . append ( '/path/a/la/carpeta' ) Espai de noms i \u00e0mbit de variables Noms En Python, tot s\u00f3n objectes, incl\u00fas les funcions. Un nom \u00e9s la forma d'accedir als objectes, i amb la funci\u00f3 id() podem veure la seua ubicaci\u00f3 en mem\u00f2ria. Per exemple: Python 1 2 3 4 5 >>> a = 2 >>> print ( 'id(2) =' , id ( 2 )) id ( 2 ) = 9062656 >>> print ( 'id(a) =' , id ( a )) d ( a ) = 9062656 Activitat 5 Quin creus que ser\u00e0 el resultat a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 >>> a = 2 >>> print ( 'id(a) =' , id ( a )) >>> a = a + 1 >>> print ( 'id(a) =' , id ( a )) >>> print ( 'id(3) =' , id ( 3 )) >>> b = 2 >>> print ( 'id(b) =' , id ( b )) >>> print ( 'id(2) =' , id ( 2 )) Espais de noms (namespaces) Els espais de noms a Python, s\u00f3n una col\u00b7lecci\u00f3 de noms. Diferents espais de noms poden coexistir, per\u00f2 estan completament a\u00efllats. Quan iniciem Python, es crea un espai de noms amb totes les funcions que l'int\u00e8rpret reconeix, espai de noms predefinit . Aquesta \u00e9s la ra\u00f3 per la qual funcions integrades com id (), print () etc. sempre estan disponibles per a nosaltres des de qualsevol part del programa. En canvi, cada m\u00f2dul crea el seu propi espai de noms global . Aquests espais de noms estan a\u00efllats entre ells. Per tant, podem donar el mateix nom a objectes de m\u00f2duls diferents sense que entren en conflicte. Els m\u00f2duls poden contindre funcions i classes. Quan es crida una funci\u00f3, es crea un espai de noms local que t\u00e9 noms propis definits. Similar, \u00e9s el cas de la classe. El seg\u00fcent diagrama pot ajudar a aclarir aquest concepte. \u00c0mbit de les variables Tot i que hi ha diversos espais de noms definits, \u00e9s possible que no puguem accedir a tots ells des de totes les parts del programa. El concepte d\u2019\u00e0mbit entra en joc. Sempre hi ha almenys tres \u00e0mbits definits. \u00c0mbit local a la funci\u00f3 amb nom locals \u00c0mbit del m\u00f2dul que t\u00e9 noms globals \u00c0mbit m\u00e9s extern que t\u00e9 noms predefinits Quan es fa una refer\u00e8ncia dins d'una funci\u00f3, el nom es busca a l'espai de noms local, despr\u00e9s a l'espai de noms global i finalment a l'espai de noms predefinit. Si hi ha una funci\u00f3 dins d\u2019una altra funci\u00f3, s\u2019anida un nou \u00e0mbit dins de l'\u00e0mbit local. Activitat 6 Quin ser\u00e0 el resultat mostrat per consola a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def funcio_externa (): a = 20 def funcio_interna (): a = 30 print ( 'a =' , a ) funcio_interna () print ( 'a =' , a ) a = 10 funcio_externa () print ( 'a =' , a ) Activitat 7 Quin ser\u00e0 el resultat mostrat per consola a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def funcio_externa (): global a a = 20 def funcio_interna (): global a a = 30 print ( 'a =' , a ) funcio_interna () print ( 'a =' , a ) a = 10 funcio_externa () print ( 'a =' , a )","title":"Introducci\u00f3"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#introduccio-a-python","text":"","title":"Introducci\u00f3 a Python"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#comencant-amb-python","text":"","title":"Comen\u00e7ant amb Python"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#que-es-python","text":"Python \u00e9s un llenguatge de prop\u00f2sit general, al igual que Java o C. El seu \u00fas ha augmentat durant els \u00faltims temps gr\u00e0cies a: La seua flexibilitat i simplicitat, que el fan f\u00e0cil d'aprendre El seu \u00fas extens en camps com el \"Data Science\", la IA i l'aprenentatge de programaci\u00f3. Llenguatge d'scripting d'alt nivell. Multiplataforma. Gran quantitat i varietat de llibreries. Web frameworks, clients correu, gestors de contingut, concurr\u00e8ncia, generaci\u00f3 de documents, gr\u00e0fics, intel\u00b7lig\u00e8ncia artificial, ... Lliure!! Mant\u00e9s per la Python Software Foundation","title":"Qu\u00e8 \u00e9s Python?"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#execucio-de-python","text":"","title":"Execuci\u00f3 de Python"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#perque-python","text":"El llenguatge de programaci\u00f3 Python \u00e9s una opci\u00f3 cada vegada m\u00e9s utilitzada per principiants com per desenvolupadors experimentats. Flexible i vers\u00e0til, Python t\u00e9 punts forts en scripts, automatitzaci\u00f3, an\u00e0lisi de dades, aprenentatge autom\u00e0tic i desenvolupament de back-end. Publicat per primera vegada el 1991 amb un nom inspirat en el grup de com\u00e8dia brit\u00e0nic Monty Python, l\u2019equip de desenvolupament volia fer de Python un llenguatge divertit d\u2019utilitzar. C \u00e9s el llenguatge de programaci\u00f3 m\u00e9s popular a l\u2019\u00edndex TIOBE, mentre que Python \u00e9s el llenguatge m\u00e9s buscat a l\u2019\u00edndex PYPL. Python i Java segueixen de prop a C al TIOBE. A PYPL, la difer\u00e8ncia \u00e9s m\u00e9s gran, ja que Python, que ocupa el primer lloc, supera en un 12% a Java, que ocupa el segon lloc. Aquest curs, aprendrem a utilitzar Python i el framework Qt per desenvolupar aplicacions amb interf\u00edcie d'usuari.","title":"Perqu\u00e8 Python"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#installacio-de-python-3","text":"Anem a instal\u00b7lar a l'Ubuntu 20.04 un entorn de programaci\u00f3 Python 3, encara que valdr\u00e0 per a qualsevol distribuci\u00f3 basada en Debian Linux, com \u00e9s el cas. En cas d'utilitzar Windows o MacOS, busqueu la forma d'instal\u00b7lar-lo.","title":"Instal\u00b7laci\u00f3 de Python 3"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#requisits-previs","text":"Per poder instal\u00b7lar, haureu de tindre un usuari amb privilegis sudo en l'Ubuntu 20.04.","title":"Requisits previs"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#primer-pas-configurant-python-3","text":"Ubuntu 20.04 ja inclou Python 3 preinstal\u00b7lat. Per assegurar-nos que les nostres versions estan actualitzades, actualitzem els repositoris i actualitzem el sistema amb l'ordre apt: Bash 1 2 $ sudo apt update $ sudo apt -y upgrade L'opci\u00f3 -y confirmar\u00e0 que estem d'acord per instal\u00b7lar totes les actualitzacions, per\u00f2, segons la vostra versi\u00f3 de Linux, \u00e9s possible que h\u00e0giu de confirmar les sol\u00b7licituds addicionals. Una vegada finalitzat el proc\u00e9s, podem comprovar la versi\u00f3 de Python 3 que s\u2019instal\u00b7la al sistema escrivint: Bash 1 2 $ python3 -V Python 3 .8.10 El terminal vos indicar\u00e0 el n\u00famero de versi\u00f3. No es tracta de l'\u00faltima versi\u00f3 estable de Python (3.9.7), per\u00f2 si de la \u00faltima disponibles als repositoris d'Ubuntu. Per gestionar paquets de programari per a Python, instal\u00b7leu pip, una eina que instal\u00b7lar\u00e0 i gestionar\u00e0 paquets de programaci\u00f3 que \u00e9s possible que vulguem utilitzar en els nostres projectes de desenvolupament. Bash 1 $ sudo apt install -y python3-pip Ara podrem utilitzar pip3 per instal\u00b7lar paquets de Python3. Bash 1 $ pip3 install \"paquet\" A m\u00e9s, instl\u00b7larem algunes llibreries necess\u00e0ries per a la construcci\u00f3 dels nostres m\u00f2duls i extensions. Bash 1 $ sudo apt install -y build-essential libssl-dev libffi-dev python3-dev","title":"Primer pas - Configurant Python 3"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#segon-pas-configurem-un-entorn-virtual-de-desenvolupament","text":"Els entorns virtuals ens permeten tenir un espai a\u00efllat per a desenvolupament de projectes Python, cosa que garanteix que cadascun dels vostres projectes puga tindre el seu propi conjunt de depend\u00e8ncies que no interrompin cap dels vostres altres projectes. Configurar un entorn de programaci\u00f3 proporciona un major control sobre els projectes de Python i sobre com es gestionen les diferents versions dels paquets. Aix\u00f2 \u00e9s especialment important quan es treballa amb paquets de tercers. Podeu configurar tants entorns de programaci\u00f3 Python com vulgueu. Cada entorn \u00e9s b\u00e0sicament un directori que cont\u00e9 uns quants scripts per fer-lo actuar com a entorn a\u00efllat de la resta de programes i llibreries de l'ordinador. Tot i que hi ha algunes maneres d\u2019aconseguir un entorn de programaci\u00f3 a Python, farem servir el m\u00f2dul venv, que forma part de la biblioteca est\u00e0ndard de Python 3. Instal\u00b7lem venv escrivint: Bash 1 $ sudo apt install -y python3-venv Amb a\u00e7\u00f2, estem preparats per crear entorns virtuals (virtual environments) . Trieu en quin directori volem situar els nostres entorns de programaci\u00f3 Python o b\u00e9 creeu un directori nou amb mkdir: Bash 1 2 $ mkdir environments $ cd environments Una vegada esteu al directori on voleu que es creen els entorns, podeu crear un entorn executant l'ordre seg\u00fcent: Bash 1 $ python3 -m venv my_env Essencialment, pyvenv crea un nou directori que cont\u00e9 alguns elements: Bash 1 bin include lib lib64 pyvenv.cfg share Junts, aquests fitxers funcionen per assegurar-vos que els vostres projectes estiguen a\u00efllats, de manera que els fitxers del sistema i els fitxers de projecte no es mesclen i entren en conflicte. Aquesta \u00e9s una bona pr\u00e0ctica per al control de versions i per garantir que cadascun dels vostres projectes tinga acc\u00e9s als paquets particulars que necessita. Per utilitzar aquest entorn, l'heu d'activar, cosa que podeu aconseguir escrivint l'ordre seg\u00fcent que crida a l'script d'activaci\u00f3: Bash 1 $ source my_env/bin/activate El vostre indicador d\u2019ordres ara tindr\u00e0 el prefix amb el nom del vostre entorn, en aquest cas s\u2019anomena my_env. Depenent de la versi\u00f3 de Debian Linux que utilitzeu, el vostre prefix pot apar\u00e8ixer de manera diferent, per\u00f2 el nom del vostre entorn entre par\u00e8ntesis hauria de ser el primer que veieu a la vostra l\u00ednia: Aquest prefix ens permet saber que l\u2019entorn my_env est\u00e0 actiu actualment, \u00e9s a dir, que quan creem programes aqu\u00ed, nom\u00e9s utilitzaran la configuraci\u00f3 i els paquets d\u2019aquest entorn concret. Nota: a l\u2019entorn virtual, podeu utilitzar l\u2019ordre python en lloc de python3 i pip en lloc de pip3 si ho preferiu. Si utilitzeu Python 3 a la vostra m\u00e0quina fora d\u2019un entorn, haureu d\u2019utilitzar exclusivament les ordres python3 i pip3. Despr\u00e9s de seguir aquests passos, el vostre entorn virtual ja es pot utilitzar. Per a desactivar l'entorn virtual, simplement tanquem la consola o utilitzem l'ordre deactivate . Deapareixer\u00e0 el nom de l'entorn virtual abans del prompt.","title":"Segon pas - Configurem un entorn virtual de desenvolupament"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#modes-dexecucio","text":"Interactiva a trav\u00e9s de l'int\u00e8rpret Bash 1 2 3 4 5 ~$ python3 Python 3 .7.3 ( default, Jul 25 2020 , 13 :03:44 ) [ GCC 8 .3.0 ] on linux Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> Execuci\u00f3 d'un fitxer Python Bash 1 2 ~$ python3 hola_mon.py Hola m\u00f3n Execuci\u00f3 d'un script Bash 1 2 3 4 5 6 7 8 9 hola_mon.py --- #!/usr/bin/env python3 print ( \"Hola m\u00f3n\" ) --- ~$ chmod u+x hola_mon.py ~$ ./hola_mon.py Hola m\u00f3n Des d'un Entorn de Desenvolupament IDE","title":"Modes d'execuci\u00f3"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#activitat-1","text":"Implementa el \"Hola m\u00f3n!\" i executa-lo de les quatre formes possibles.","title":"Activitat 1"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#paraules-reservades-i-identificadors","text":"","title":"Paraules reservades i identificadors"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#paraules-reservades","text":"No es poden utilitzar coma identificador de variables ni nom de funcions, ja que s'utilitzen per a definir la sintaxi i l'estructura d'un programa. Les paraules reservades s\u00f3n: False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if or yield Per a obtindre la llista completa des de l'int\u00e8rpret: Python 1 2 >>> import keyword >>> print ( keyword . kwlist )","title":"Paraules reservades"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#identificadors","text":"Per convenci\u00f3, els noms de les variables i funcions han de ser: combinacions de lletres min\u00fascules i n\u00fameros comen\u00e7ar per lletra descriptius (excepte en bucles o se sol utilitzar i i j ) amb paraules separades per gui\u00f3 baix Per exemple: nom_usuari, numero_telefon, cognom1, sumar(), ... Recorda que Python \u00e9s un llenguatge case sensitive . Per tant Var i var no s\u00f3n el mateix identificador.","title":"Identificadors"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#instruccions-i-sagnat","text":"","title":"Instruccions i sagnat"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#instruccions","text":"L'int\u00e8rpret de Python va executant l\u00ednia a l\u00ednia cada instrucci\u00f3. Si volem que una instrucci\u00f3 ocupe diverses l\u00ednies ho hem d'indicar amb el car\u00e0cter \\. Per exemple: Python 1 2 3 4 5 >>> a = 1 + 2 + 3 + \\ ... 4 + 5 + 6 + \\ ... 7 + 8 + 9 >>> print ( a ) 45 La continuaci\u00f3 de l\u00ednia \u00e9s implicita dins de par\u00e8ntesis (), corxets [] i claus {}. Python 1 2 3 colors = [ 'red' , 'blue' , 'green' ] Tamb\u00e9 podem posar diverses sent\u00e8ncies en una l\u00ednia: Python 1 a = 1 ; b = 2 ; c = 3","title":"Instruccions"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#sagnat","text":"La majoria de llenguatges de programaci\u00f3 utilitzen les claus {} per a definir blocs de codi. En canvi, Python utilitza el sagnat (identation). Un bloc de codi (cos d'una funci\u00f3, bucle, etc.) comen\u00e7a amb sagnat i acaba amb la primera l\u00ednia sense sagnat. Dep\u00e8n de vosaltres la quantitat de sagnat, per\u00f2 ha de ser coherent en tot el bloc. Generalment, s\u2019utilitzen quatre espais en blanc per a sagnat i es prefereixen a les tabulacions. El resultat \u00e9s un codi net i clar. Exemple: Python 1 2 3 4 for i in range ( 1 , 11 ): print ( i ) if i == 5 : break Un sagnat incorrecte llan\u00e7a un IndentationError .","title":"Sagnat"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#comentaris","text":"Els comentaris s\u00f3n molt importants en escriure un programa. Descriuen el que passa dins d\u2019un programa, de manera que una persona que mira el codi font no tinga dificultats per entendre'l. A m\u00e9s, \u00e9s possible que oblideu els detalls clau d'implementaci\u00f3 del programa que acabeu d\u2019escriure. Per tant, invertir temps per explicar aquests conceptes en forma de comentaris sempre \u00e9s fruct\u00edfer . A Python, fem servir el s\u00edmbol coixinet (#) per comen\u00e7ar a escriure un comentari. S'est\u00e9n fins al car\u00e0cter de l\u00ednia nova. No cal que el comentari estiga a principi de l\u00ednia, pot estar en mig. Per fer comentaris multil\u00ednia, podem utilitzar el coixinet a principi de cada l\u00ednia. Tamb\u00e9 podem fer servir les cometes dobles o simples tres vegades. Exemple: Python 1 2 ''' Comentari multil\u00ednia'''","title":"Comentaris"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#docstrings","text":"Una docstring \u00e9s una abreviatura de text de documentaci\u00f3. La documentaci\u00f3 de Python s\u00f3n els textos que apareixen just despr\u00e9s de la definici\u00f3 d'una funci\u00f3, m\u00e8tode, classe o m\u00f2dul. S'utilitzen cometes triples durant l'escriptura de la documentaci\u00f3. Per exemple: Python 1 2 3 def doble ( num ): \"\"\"Funci\u00f3 per duplicar el valor\"\"\" return 2 * num La documentaci\u00f3 s\u2019associa a l\u2019objecte com a atribut doc . Per tant, podem accedir a la documentaci\u00f3 de la funci\u00f3 anterior amb les seg\u00fcents l\u00ednies de codi: Python 1 2 3 4 def doble ( num ): \"\"\"Funci\u00f3 per duplicar el valor\"\"\" return 2 * num print ( doble . __ doc__ ) Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def suma_binaria ( a , b ): ''' Torna la suma de dos enters en binari. Par\u00e0metres: a (int): Un enter b (int): Altre enter Torna: suma_binaria (str): String amb els digits binaris de la suma ''' suma_binaria = bin ( a + b )[ 2 :] return suma_binaria print ( suma_binaria . __doc__ )","title":"Docstrings"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#variables-constants-i-tipus","text":"","title":"Variables, constants i tipus"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#variables","text":"En Python, quan declarem una variable i li assignem un valor, realment estem creant un objecte i assignant un valor per refer\u00e8ncia. Python 1 2 3 4 5 6 >>> num = 10 >>> type ( num ) < class ' int '> >>> num = 10.0 >>> type ( num ) < class ' float '> Podem inicialitzar m\u00faltiples variables en una mateixa l\u00ednia, ja siga amb el mateix valor o diferent. Python 1 2 a , b , c = 5 , 3.2 , \"Hola\" x = y = z = \"iguals\"","title":"Variables"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#constants","text":"A Python no existeixen les constants a l'estil de static final de Java, sin\u00f3 que simplement es defineix una variable que no es modifica el valor. Normalment es definixen en un m\u00f2dul a banda, utilitzant maj\u00fascules i gui\u00f3 baix si \u00e9s necessari, que s'importa a l'arxiu principal. Python 1 2 3 4 5 6 7 8 9 10 constants . py --- PI = 3.14 main . py --- import constants.py radi = 5 perimetre = 2 * constants . PI * radi print ( perimetre )","title":"Constants"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#tipus","text":"L'assignaci\u00f3 de tipus \u00e9s din\u00e0mica i pot canviar, per aix\u00f2 no declarem els tipus de les variables. Per determinar el tipus d'un objecte, fem servir el m\u00e8tode type() . Els tipus d'objecte definits a Python3 s\u00f3n: 1. Num\u00e8rics: 1.1. Integer Python 1 2 3 4 a = 0b1010 #Binary b = 100 #Decimal c = 0o310 #Octal d = 0x12c #Hexadecimal 1.2. Float Python 1 2 float_1 = 10.5 float_2 = 1.5e2 1.3. Complex Python 1 x = 3 + 4 j Strings Python 1 nom = 'Ferran Cunyat' Els principals m\u00e8todes sobre un string s\u00f3n capitalize(), count(), find(), format(), lower(), replace(), split(), title(), translate(), upper() . Boolean Python 1 2 3 4 x = ( 1 == True ) # True pren el valor num\u00e8ric 1, mentre que False el 0 y = ( 1 == False ) a = True + 4 b = False + 10 Especials (None) S'utilitza per no donar-li valor a una variable. Python 1 2 3 >>> x = None >>> type ( x ) < class ' NoneType '> Col\u00b7leccions Llista S\u00f3n una seq\u00fc\u00e8ncia d'elements, no necess\u00e0riament del mateix tipus, encara que normalment si que ho s\u00f3n. Es definix amb corxets i els elements separats per comes. Podem accedir a un element o un rang i \u00e9s mutable. Python 1 2 3 4 5 6 >>> a = [ 5 , 10 , 15 , 20 , 25 , 30 , 45 , 40 ] >>> print ( a ) [ 5 , 10 , 15 , 20 , 25 , 30 , 45 , 40 ] >>> a [ 3 ] = \"Ferran\" >>> print ( a [: 4 ]) [ 5 , 10 , 15 , 'Ferran' ] Algunes de les principals funcions que podem aplicar sobre llistes s\u00f3n apend(), clear(), copy(), extend(), insert(), remove(), reverse() . Tupla S\u00f3n una seq\u00fc\u00e8ncia d'elements, no necess\u00e0riament del mateix tipus, per\u00f2 esta vegada immutable. Python 1 2 3 4 5 >>> tupla = ( 2 , 'hola' ) >>> tupla [ 1 ] = 'clavel' Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : 'tuple' object does not support item assignment Rang Seq\u00fc\u00e8ncia immutable de n\u00fameros, generalment utilitzada per a iterar sobre for o generar llistes r\u00e0pidament. Python 1 2 >>> list ( range ( 0 , 30 , 5 )) [ 0 , 5 , 10 , 15 , 20 , 25 ] 3 . Conjunt (Set) Col\u00b7lecci\u00f3 desordenada d'elements \u00fanics. Ja que \u00e9s una llista desordenada, no la podem indexar i per tant accedir als elements segons la seua posici\u00f3. Python 1 2 3 4 5 6 7 8 >>> a = { 2 , 2 , 5 , 5 , 4 , 10 , 1 , 0 } >>> print ( a ) { 0 , 1 , 2 , 4 , 5 , 10 } >>> a [ 1 ] Traceback ( most recent call last ): File \"<string>\" , line 301 , in runcode File \"<interactive input>\" , line 1 , in < module > TypeError : 'set' object does not support indexing Diccionari Diccionari \u00e9s una col\u00b7lecci\u00f3 no ordenada de parells valor-clau. Generalment s\u2019utilitza quan tenim una gran quantitat de dades. Els diccionaris estan optimitzats per recuperar dades. Hem de con\u00e8ixer la clau per recuperar el valor. A Python, els diccionaris es defineixen entre claus {} i cada element \u00e9s un parell que adopta la forma de clau:valor. La clau i el valor poden ser de qualsevol tipus. Python 1 2 3 4 5 6 7 8 9 10 11 >>> d = { 1 : 'valor' , 'clau' : 2 } >>> print ( type ( d )) < class ' dict '> >>> print ( \"d[1] = \" , d [ 1 ]); d [ 1 ] = valor >>> print ( \"d['clau'] = \" , d [ 'clau' ]); d [ 'clau' ] = 2 >>> print ( \"d[2] = \" , d [ 2 ]); Traceback ( most recent call last ): File \"<stdin>\" , line 2 , in < module > KeyError : 2","title":"Tipus"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#activitat-2","text":"Fixa't en el seg\u00fcent fragment de codi: Python 1 2 3 4 5 6 7 8 9 >>> s = [ 1 , 2 ] >>> r = s [:] >>> s [ 0 ] = 2 >>> print ( s ) [ 2 , 2 ] >>> print ( r ) ??? >>> print ( s ) ??? Quina ser\u00e0 l'eixida? Per qu\u00e9? Python 1 2 3 4 5 6 >>> r = s >>> s [ 0 ] = 5 >>> print ( r ) ??? >>> print ( s ) ??? I ara? Per qu\u00e9?","title":"Activitat 2"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#conversio-entre-tipus","text":"","title":"Conversi\u00f3 entre tipus"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#conversio-implicita","text":"S\u00f3n conversions que fa el mateix llenguatge autom\u00e0ticament. Per exemple: Python 1 2 3 4 5 6 7 8 9 10 num_int = 123 num_flo = 1.23 num_nou = num_int + num_flo print ( \"num_int \u00e9s de tipus:\" , type ( num_int )) print ( \"num_flo \u00e9s de tipus:\" , type ( num_flo )) print ( \"Valor de num_nou:\" , num_nou ) print ( \"num_nou \u00e9s de tipus:\" , type ( num_nou ))","title":"Conversi\u00f3 impl\u00edcita"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#conversio-explicita","text":"Utilitzem funcions predefinides per a for\u00e7ar la conversi\u00f3 int(), float(), str(), ... .","title":"Conversi\u00f3 expl\u00edcita"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#activitat-3","text":"Quin \u00e9s el resultat d'executar el seg\u00fcent fragment de codi? Python 1 2 3 >>> enter = 123 >>> cadena = \"456\" >>> suma = enter + cadena Definix dues variables, una per a fer la suma entera (579) i l'altra per a concatrenar com a text (123456).","title":"Activitat 3"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#entrada-eixida-i-import","text":"","title":"Entrada, eixida i import"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#entrada","text":"Ja hem vist que per a introduir informaci\u00f3 per teclat utilitzem la funci\u00f3 input([prompt]) .","title":"Entrada"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#eixida","text":"Per a imprimir per ella utilitzarem la funci\u00f3 print() . Moltes vegades s'utilitza en combinaci\u00f3 amb la funci\u00f3 format() dels strings. Python 1 2 3 4 5 >>> x = 5 ; y = 10 >>> print ( 'El valor d \\' x \u00e9s {} i el de y \u00e9s {} ' . format ( x , y )) >>> # Fixeu-se que hem escapat el caracter ' El valor d 'x \u00e9s 5 i el de y \u00e9s 10 >>> print ( 'Hola {nom} , {salutacio} ' . format ( salutacio = 'Bon dia' , nom = 'Pau' ))","title":"Eixida"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#activitat-4","text":"Implementa el programa \"Hola m\u00f3n\" utilitzant la funci\u00f3 format.","title":"Activitat 4"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#import","text":"Quan volem fer \u00fas del codi d'un altre m\u00f2dul (.py), l'hem d'importar al programa actual amb import . Python 1 2 >>> import math >>> print ( math . pi ) Tamb\u00e9 podem importar sols alguna de les funcions o atributs amb from Python 1 >>> from math import pi En importar un m\u00f2dul, Python analitza diversos llocs definits a sys.path. \u00c9s una llista de les ubicacions on buscar el m\u00f2dul. Python 1 2 3 >>> import sys >>> sys . path [ '' , '/usr/lib/python37.zip' , '/usr/lib/python3.7' , '/usr/lib/python3.7/lib-dynload' , '/home/ferran/.local/lib/python3.7/site-packages' , '/usr/local/lib/python3.7/dist-packages' , '/usr/lib/python3/dist-packages' ] Per a importar d'una altra carpeta, ho fem amb from paquet import modul . Pots posar ubicacions absolutes o relatives. Si volem importar un codi d'una ubicaci\u00f3 que no est\u00e0 al path. Python 1 2 >>> import sys >>> sys . path . append ( '/path/a/la/carpeta' )","title":"Import"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#espai-de-noms-i-ambit-de-variables","text":"","title":"Espai de noms i \u00e0mbit de variables"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#noms","text":"En Python, tot s\u00f3n objectes, incl\u00fas les funcions. Un nom \u00e9s la forma d'accedir als objectes, i amb la funci\u00f3 id() podem veure la seua ubicaci\u00f3 en mem\u00f2ria. Per exemple: Python 1 2 3 4 5 >>> a = 2 >>> print ( 'id(2) =' , id ( 2 )) id ( 2 ) = 9062656 >>> print ( 'id(a) =' , id ( a )) d ( a ) = 9062656","title":"Noms"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#activitat-5","text":"Quin creus que ser\u00e0 el resultat a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 >>> a = 2 >>> print ( 'id(a) =' , id ( a )) >>> a = a + 1 >>> print ( 'id(a) =' , id ( a )) >>> print ( 'id(3) =' , id ( 3 )) >>> b = 2 >>> print ( 'id(b) =' , id ( b )) >>> print ( 'id(2) =' , id ( 2 ))","title":"Activitat 5"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#espais-de-noms-namespaces","text":"Els espais de noms a Python, s\u00f3n una col\u00b7lecci\u00f3 de noms. Diferents espais de noms poden coexistir, per\u00f2 estan completament a\u00efllats. Quan iniciem Python, es crea un espai de noms amb totes les funcions que l'int\u00e8rpret reconeix, espai de noms predefinit . Aquesta \u00e9s la ra\u00f3 per la qual funcions integrades com id (), print () etc. sempre estan disponibles per a nosaltres des de qualsevol part del programa. En canvi, cada m\u00f2dul crea el seu propi espai de noms global . Aquests espais de noms estan a\u00efllats entre ells. Per tant, podem donar el mateix nom a objectes de m\u00f2duls diferents sense que entren en conflicte. Els m\u00f2duls poden contindre funcions i classes. Quan es crida una funci\u00f3, es crea un espai de noms local que t\u00e9 noms propis definits. Similar, \u00e9s el cas de la classe. El seg\u00fcent diagrama pot ajudar a aclarir aquest concepte.","title":"Espais de noms (namespaces)"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#ambit-de-les-variables","text":"Tot i que hi ha diversos espais de noms definits, \u00e9s possible que no puguem accedir a tots ells des de totes les parts del programa. El concepte d\u2019\u00e0mbit entra en joc. Sempre hi ha almenys tres \u00e0mbits definits. \u00c0mbit local a la funci\u00f3 amb nom locals \u00c0mbit del m\u00f2dul que t\u00e9 noms globals \u00c0mbit m\u00e9s extern que t\u00e9 noms predefinits Quan es fa una refer\u00e8ncia dins d'una funci\u00f3, el nom es busca a l'espai de noms local, despr\u00e9s a l'espai de noms global i finalment a l'espai de noms predefinit. Si hi ha una funci\u00f3 dins d\u2019una altra funci\u00f3, s\u2019anida un nou \u00e0mbit dins de l'\u00e0mbit local.","title":"\u00c0mbit de les variables"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#activitat-6","text":"Quin ser\u00e0 el resultat mostrat per consola a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def funcio_externa (): a = 20 def funcio_interna (): a = 30 print ( 'a =' , a ) funcio_interna () print ( 'a =' , a ) a = 10 funcio_externa () print ( 'a =' , a )","title":"Activitat 6"},{"location":"unitats/1-python/teoria/1%20-%20Introducci%C3%B3/#activitat-7","text":"Quin ser\u00e0 el resultat mostrat per consola a l'executar el seg\u00fcent fragment de codi? Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def funcio_externa (): global a a = 20 def funcio_interna (): global a a = 30 print ( 'a =' , a ) funcio_interna () print ( 'a =' , a ) a = 10 funcio_externa () print ( 'a =' , a )","title":"Activitat 7"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/","text":"Control de fluxe If ... else Python 1 2 3 4 5 6 7 num = int ( input ( \"N\u00famero: \" )) if num > 0 : print ( \"Positiu\" ) elif num == 0 : print ( \"Zero\" ) else : print ( \"Negatiu\" ) For No existeix un for a l'estil de C o Java. Am\u00e9s podem afegir un else al final de bucle. Python 1 2 3 4 5 6 7 8 9 10 nums = [ 6 , 5 , 3 , 8 , 4 , 2 , 5 , 4 , 11 ] suma = 0 for val in nums : suma = suma + val else : print ( \"Hem acabat de sumar\" ) print ( \"La suma \u00e9s\" , suma ) Podem combinar el bucle for amb la funci\u00f3 range(principi, fi, pas) . Activitat 8 Fes una aplicaci\u00f3 que imprimisca els n\u00fameros imparells entre l'1 i el 100. Activitat 9 Fes una aplicaci\u00f3 que donada la seg\u00fcent llista, imprimisca els seus membres: aficions = ['esports', 'cine', 'teatre'] While Python 1 2 3 4 5 6 7 contador = 0 while contador < 3 : print ( \"Dins del while\" ) contador = contador + 1 else : print ( \"Fora del bucle\" ) Break i continue S'utilitzen igual que a Java. El continue passa a la seg\u00fcent iteraci\u00f3, mentre que el break ix del bucle. En cas de bucles anidats, ix del bucle intern. Switch - Case Fins a la versi\u00f3 3.10, python no implementava el switch-case d'altres llenguatges i s'havia d'utilitzar un bloc d'if-elseif: Python 1 2 3 4 5 6 7 8 9 10 11 12 edat = 120 if age > 90 : print ( \"Esta festa \u00e9s sols per a joves.\" ) elif age < 0 : print ( \"Encara no has nascut!!\" ) elif age >= 18 : print ( \"Endavant!!\" ) else : \"Ers massa jove per entrar a esta festa\" # Output: Esta festa \u00e9s sols per a joves. O definir una funci\u00f3 que executara aquesta funcionalitat: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def switch ( lang ): if lang == \"JavaScript\" : return \"Ser\u00e0s programador web.\" elif lang == \"PHP\" : return \"Ser\u00e0s programador de backend.\" elif lang == \"Python\" : return \"Ser\u00e0s cient\u00edfic de dades.\" elif lang == \"Solidity\" : return \"Ser\u00e0s desenvolupador de Blockchain.\" elif lang == \"Dart\" : return \"Ser\u00e0s desenvolupador d'aplicacions m\u00f2bils.\" print ( switch ( \"JavaScript\" )) print ( switch ( \"Python\" )) print ( switch ( \"Dart\" )) \"\"\" Eixida: Ser\u00e0s programador web. Ser\u00e0s cient\u00edfic de dades. Ser\u00e0s desenvolupador d'aplicacions m\u00f2bils \"\"\" A partir de la versi\u00f3 3.10, Python disposa de les paraules reservades match-case : Python 1 2 3 4 5 6 7 8 9 match terme : case patr\u00f3 - 1 : acci\u00f3 - 1 case patr\u00f3 - 2 : acci\u00f3 - 2 case patr\u00f3 - 3 : acci\u00f3 - 3 case _ : acci\u00f3 - per - defecte Exemple Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lang = input ( \"Quin llenguatge de programaci\u00f3 vols aprendre? \" ) match lang : case \"JavaScript\" : print ( \"Ser\u00e0s programador web.\" ) case \"Python\" : print ( \"Ser\u00e0s cient\u00edfic de dades.\" ) case \"PHP\" : print ( \"Ser\u00e0s programador de backend.\" ) case \"Solidity\" : print ( \"Ser\u00e0s desenvolupador de Blockchain.\" ) case \"Dart\" : print ( \"er\u00e0s desenvolupador d'aplicacions m\u00f2bils.\" ) case _ : print ( \"L'idioma no importa, el que importa \u00e9s resoldre problemes.\" )","title":"Control de fluxe"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/#control-de-fluxe","text":"","title":"Control de fluxe"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/#if-else","text":"Python 1 2 3 4 5 6 7 num = int ( input ( \"N\u00famero: \" )) if num > 0 : print ( \"Positiu\" ) elif num == 0 : print ( \"Zero\" ) else : print ( \"Negatiu\" )","title":"If ... else"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/#for","text":"No existeix un for a l'estil de C o Java. Am\u00e9s podem afegir un else al final de bucle. Python 1 2 3 4 5 6 7 8 9 10 nums = [ 6 , 5 , 3 , 8 , 4 , 2 , 5 , 4 , 11 ] suma = 0 for val in nums : suma = suma + val else : print ( \"Hem acabat de sumar\" ) print ( \"La suma \u00e9s\" , suma ) Podem combinar el bucle for amb la funci\u00f3 range(principi, fi, pas) .","title":"For"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/#activitat-8","text":"Fes una aplicaci\u00f3 que imprimisca els n\u00fameros imparells entre l'1 i el 100.","title":"Activitat 8"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/#activitat-9","text":"Fes una aplicaci\u00f3 que donada la seg\u00fcent llista, imprimisca els seus membres: aficions = ['esports', 'cine', 'teatre']","title":"Activitat 9"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/#while","text":"Python 1 2 3 4 5 6 7 contador = 0 while contador < 3 : print ( \"Dins del while\" ) contador = contador + 1 else : print ( \"Fora del bucle\" )","title":"While"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/#break-i-continue","text":"S'utilitzen igual que a Java. El continue passa a la seg\u00fcent iteraci\u00f3, mentre que el break ix del bucle. En cas de bucles anidats, ix del bucle intern.","title":"Break i continue"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/#switch-case","text":"Fins a la versi\u00f3 3.10, python no implementava el switch-case d'altres llenguatges i s'havia d'utilitzar un bloc d'if-elseif: Python 1 2 3 4 5 6 7 8 9 10 11 12 edat = 120 if age > 90 : print ( \"Esta festa \u00e9s sols per a joves.\" ) elif age < 0 : print ( \"Encara no has nascut!!\" ) elif age >= 18 : print ( \"Endavant!!\" ) else : \"Ers massa jove per entrar a esta festa\" # Output: Esta festa \u00e9s sols per a joves. O definir una funci\u00f3 que executara aquesta funcionalitat: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def switch ( lang ): if lang == \"JavaScript\" : return \"Ser\u00e0s programador web.\" elif lang == \"PHP\" : return \"Ser\u00e0s programador de backend.\" elif lang == \"Python\" : return \"Ser\u00e0s cient\u00edfic de dades.\" elif lang == \"Solidity\" : return \"Ser\u00e0s desenvolupador de Blockchain.\" elif lang == \"Dart\" : return \"Ser\u00e0s desenvolupador d'aplicacions m\u00f2bils.\" print ( switch ( \"JavaScript\" )) print ( switch ( \"Python\" )) print ( switch ( \"Dart\" )) \"\"\" Eixida: Ser\u00e0s programador web. Ser\u00e0s cient\u00edfic de dades. Ser\u00e0s desenvolupador d'aplicacions m\u00f2bils \"\"\" A partir de la versi\u00f3 3.10, Python disposa de les paraules reservades match-case : Python 1 2 3 4 5 6 7 8 9 match terme : case patr\u00f3 - 1 : acci\u00f3 - 1 case patr\u00f3 - 2 : acci\u00f3 - 2 case patr\u00f3 - 3 : acci\u00f3 - 3 case _ : acci\u00f3 - per - defecte","title":"Switch - Case"},{"location":"unitats/1-python/teoria/2%20-%20Control%20de%20fluxe/#exemple","text":"Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 lang = input ( \"Quin llenguatge de programaci\u00f3 vols aprendre? \" ) match lang : case \"JavaScript\" : print ( \"Ser\u00e0s programador web.\" ) case \"Python\" : print ( \"Ser\u00e0s cient\u00edfic de dades.\" ) case \"PHP\" : print ( \"Ser\u00e0s programador de backend.\" ) case \"Solidity\" : print ( \"Ser\u00e0s desenvolupador de Blockchain.\" ) case \"Dart\" : print ( \"er\u00e0s desenvolupador d'aplicacions m\u00f2bils.\" ) case _ : print ( \"L'idioma no importa, el que importa \u00e9s resoldre problemes.\" )","title":"Exemple"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/","text":"Funcions Definici\u00f3 de funcions Python 1 2 3 def nom_funcio ( par\u00e0metres ): \"\"\"docstring\"\"\" instruccions ( s ) Nota: Recordeu l\u00e0mbit de les variables, ja que hi haur\u00e0 variables locals a la funci\u00f3. Arguments Valors per defecte Els arguments de les funcions poden tindre un valor per defecte. En cas de no assignar-li un valor per defecte, necessitem fer la crida passant-li el valor de l'argument. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def saluda ( nom = \"desconegut\" , msg = \"Benvingut!\" ): \"\"\" Funci\u00f3 per saludar a un usuari Entrada: nom=\"desconegut\": String, nom de l'usuari msg=\"Benvingut!\": String, missatge de salutaci\u00f3 Si no li proporcionem valors en la crida, utilitzar\u00e0 els valors per defecte \"\"\" print ( \"Hola\" , nom + '.' , msg ) La crida a la funci\u00f3 la podem fer sense arguments, amb un o amb dos. \u00c9s una forma de fer una sobrec\u00e0rrega de m\u00e8todes de forma molt r\u00e0pida. Python 1 2 3 4 5 saluda ( \"Tom\u00e0s\" , \"Qu\u00e8 fas?\" ) saluda ( \"Pau\" ) saluda () saluda ( msg = \"\" , nom = \"Artur\" ) saluda ( msg = \"\" , \"Artur\" ) Nombre arbitrari d'arguments Si no sabem a priori quants arguments rebr\u00e0 la funci\u00f3, podem utilitzar el car\u00e0cter \"*\" en la definici\u00f3 de la funci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def saluda ( * noms ): \"\"\" Funci\u00f3 per saludar a un conjunt d'usuaris Entrada: noms: llistat de noms \"\"\" for nom in noms : print ( \"Hola\" , nom ) saluda ( \"Alex\" , \"Guillem\" , \"Javier\" ) Funcions recursives La recursi\u00f3 \u00e9s el proc\u00e9s de definir alguna cosa en termes d'eixa mateixa cosa. Aleshores, una funci\u00f3 recursiva \u00e9s aquella que es crida a s\u00ed mateix. S'ha d'anar molt en compte en crear correctament la condici\u00f3 d'eixida de la funci\u00f3, ja que d'altra forma entrariem en bucle infinit. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def factorial ( x ): \"\"\"Funci\u00f3 per a calcular el fatorial d'un enter. Entrada: - x: int, el nombre del que volem calcular el factorial Eixida: - x!: int, factorial d'x \"\"\" if x == 1 : return 1 else : return ( x * factorial ( x - 1 )) num = int ( input ( \"N\u00famero: \" )) print ( num , \"! =\" , factorial ( num )) Funcions an\u00f2nimes Les funcions an\u00f2nimes o funcions lambda , s\u00f3n funcions sense nom. Poden tindre un nombre indeterminat d'arguments, per\u00f2 sols una expressi\u00f3, que ser\u00e0 avaluada i retornat el seu resultat. Python 1 2 3 quadrat = lambda x : x ** 2 print ( quadrat ( 5 )) Normalment les funcions lambda s'utilitzen en combinaci\u00f3 amb altres funcions com filter(), map(), etc. La funci\u00f3 map() rep com a arguments una funci\u00f3 i una llista, i torna una llista del mateix tamany on cada element \u00e9s el resultat d'aplicar la funci\u00f3 sobre l'element que ocupa la mateixa posici\u00f3 a la llista original. La funci\u00f3 filter() , rep una funci\u00f3 i una llista com a arguments, i torna com a resultat una llista amb els elements que avaluen a True la funci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 llista = [ 1 , 5 , 4 , 6 , 8 , 11 , 3 , 12 ] nova_llista = list ( map ( lambda x : x ** 2 , llista )) print ( nova_llista ) \"\"\" Eixida: [1, 25, 16, 36, 64, 121, 9, 144] \"\"\" Activitat 10 Definix una llista i utilitzant filter, que la separe en dues llistes, una amb els elements parells i l'altra amb els senars. Packages Igual que la informaci\u00f3 al disc dur est\u00e0 organitzada en carpetes i subcarpetes, un programa en Python es pot organitzar en paquets, sub paquets i m\u00f2duls. A\u00e7\u00f2 fa un programa m\u00e9s f\u00e0cil de gestionar i conceptualment m\u00e9s clar. Una carpeta ha de contindre un arxiu anomenat __init__.py. Este arxiu pot estar buit o no, per\u00f2 normalment cont\u00e9 codi d'inicialitzaci\u00f3. Per a importar un m\u00f2dul d'un paquet utilitzariem import o from ... import . Python 1 2 import Game.Level.start from Game.Level import start","title":"Funcions"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/#funcions","text":"","title":"Funcions"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/#definicio-de-funcions","text":"Python 1 2 3 def nom_funcio ( par\u00e0metres ): \"\"\"docstring\"\"\" instruccions ( s ) Nota: Recordeu l\u00e0mbit de les variables, ja que hi haur\u00e0 variables locals a la funci\u00f3.","title":"Definici\u00f3 de funcions"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/#arguments","text":"","title":"Arguments"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/#valors-per-defecte","text":"Els arguments de les funcions poden tindre un valor per defecte. En cas de no assignar-li un valor per defecte, necessitem fer la crida passant-li el valor de l'argument. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def saluda ( nom = \"desconegut\" , msg = \"Benvingut!\" ): \"\"\" Funci\u00f3 per saludar a un usuari Entrada: nom=\"desconegut\": String, nom de l'usuari msg=\"Benvingut!\": String, missatge de salutaci\u00f3 Si no li proporcionem valors en la crida, utilitzar\u00e0 els valors per defecte \"\"\" print ( \"Hola\" , nom + '.' , msg ) La crida a la funci\u00f3 la podem fer sense arguments, amb un o amb dos. \u00c9s una forma de fer una sobrec\u00e0rrega de m\u00e8todes de forma molt r\u00e0pida. Python 1 2 3 4 5 saluda ( \"Tom\u00e0s\" , \"Qu\u00e8 fas?\" ) saluda ( \"Pau\" ) saluda () saluda ( msg = \"\" , nom = \"Artur\" ) saluda ( msg = \"\" , \"Artur\" )","title":"Valors per defecte"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/#nombre-arbitrari-darguments","text":"Si no sabem a priori quants arguments rebr\u00e0 la funci\u00f3, podem utilitzar el car\u00e0cter \"*\" en la definici\u00f3 de la funci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 def saluda ( * noms ): \"\"\" Funci\u00f3 per saludar a un conjunt d'usuaris Entrada: noms: llistat de noms \"\"\" for nom in noms : print ( \"Hola\" , nom ) saluda ( \"Alex\" , \"Guillem\" , \"Javier\" )","title":"Nombre arbitrari d'arguments"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/#funcions-recursives","text":"La recursi\u00f3 \u00e9s el proc\u00e9s de definir alguna cosa en termes d'eixa mateixa cosa. Aleshores, una funci\u00f3 recursiva \u00e9s aquella que es crida a s\u00ed mateix. S'ha d'anar molt en compte en crear correctament la condici\u00f3 d'eixida de la funci\u00f3, ja que d'altra forma entrariem en bucle infinit. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def factorial ( x ): \"\"\"Funci\u00f3 per a calcular el fatorial d'un enter. Entrada: - x: int, el nombre del que volem calcular el factorial Eixida: - x!: int, factorial d'x \"\"\" if x == 1 : return 1 else : return ( x * factorial ( x - 1 )) num = int ( input ( \"N\u00famero: \" )) print ( num , \"! =\" , factorial ( num ))","title":"Funcions recursives"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/#funcions-anonimes","text":"Les funcions an\u00f2nimes o funcions lambda , s\u00f3n funcions sense nom. Poden tindre un nombre indeterminat d'arguments, per\u00f2 sols una expressi\u00f3, que ser\u00e0 avaluada i retornat el seu resultat. Python 1 2 3 quadrat = lambda x : x ** 2 print ( quadrat ( 5 )) Normalment les funcions lambda s'utilitzen en combinaci\u00f3 amb altres funcions com filter(), map(), etc. La funci\u00f3 map() rep com a arguments una funci\u00f3 i una llista, i torna una llista del mateix tamany on cada element \u00e9s el resultat d'aplicar la funci\u00f3 sobre l'element que ocupa la mateixa posici\u00f3 a la llista original. La funci\u00f3 filter() , rep una funci\u00f3 i una llista com a arguments, i torna com a resultat una llista amb els elements que avaluen a True la funci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 llista = [ 1 , 5 , 4 , 6 , 8 , 11 , 3 , 12 ] nova_llista = list ( map ( lambda x : x ** 2 , llista )) print ( nova_llista ) \"\"\" Eixida: [1, 25, 16, 36, 64, 121, 9, 144] \"\"\"","title":"Funcions an\u00f2nimes"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/#activitat-10","text":"Definix una llista i utilitzant filter, que la separe en dues llistes, una amb els elements parells i l'altra amb els senars.","title":"Activitat 10"},{"location":"unitats/1-python/teoria/3%20-%20Funcions/#packages","text":"Igual que la informaci\u00f3 al disc dur est\u00e0 organitzada en carpetes i subcarpetes, un programa en Python es pot organitzar en paquets, sub paquets i m\u00f2duls. A\u00e7\u00f2 fa un programa m\u00e9s f\u00e0cil de gestionar i conceptualment m\u00e9s clar. Una carpeta ha de contindre un arxiu anomenat __init__.py. Este arxiu pot estar buit o no, per\u00f2 normalment cont\u00e9 codi d'inicialitzaci\u00f3. Per a importar un m\u00f2dul d'un paquet utilitzariem import o from ... import . Python 1 2 import Game.Level.start from Game.Level import start","title":"Packages"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/","text":"Tractament de fitxers Fitxers Entrada eixida utilitzant fitxers Per a llegir o escriure en un fitxer, primer l\u2019hem d\u2019obrir. Quan acabem, s\u2019ha de tancar perqu\u00e8 s\u2019alliberen els recursos relacionats amb el fitxer. Per tant, a Python, utilitzem la seg\u00fcent seq\u00fc\u00e8ncia d'operacions per traballar amb fitxers: Obrir un fitxer Llegir o escriure Tancar el fitxer Open Per obrir un fitxer utilitzem la funci\u00f3 open() . Python 1 2 >>> f = open ( \"test.txt\" ) # arxiu en el mateix directori >>> f = open ( \"C:/Python38/README.txt\" ) # path sencer A m\u00e9s, podem especificar el mode d'apertura i la codificaci\u00f3. Mode Descripci\u00f3 r lectura w escriptura x creaci\u00f3 exclusiva (falla si ja existeix) a afegir al final, el crea si no existeix t mode lectura de text (per defecte) b mode binari + actualitzaci\u00f3 (lectura i escriptura ) Python 1 2 >>> f = open ( \"test.txt\" , 'w' ) # obert per a escriptura >>> f = open ( \"test.txt\" , mode = 'r' , encoding = 'utf-8' ) Warning \u00c9s important que tingau en compte que quan l'int\u00e8rpret de python s'executa, ho fa des del directori del qu\u00e8 s'ha llan\u00e7at(el podeu obtindre mitjan\u00e7ant os.getcwd() ), per aix\u00f2 la c\u00e0rrega de fitxers en rutes relatives en funcions tipus open , load , etc potser vos d\u00f3ne un error indicant que no el troba. f = open(\"ruta relativa/arxiu.txt\") S'han d'evitar les rutes absolutes . El que podeu fer per evitar estos errors \u00e9s obtindre la ruta des del fitxer font de la seg\u00fcent forma: Python 1 2 3 ruta_base = os . path . dirname ( __file__ ) ruta_a_recurs = os . path . join ( ruta_base , \"arxiu.txt\" ) f = open ( ruta_a_recurs ) Close Python utilitza un garbage collector per netejar objectes sense refer\u00e8ncies, per\u00f2 no hem de confiar per tancar el fitxer. Python 1 2 3 4 5 try : f = open ( \"test.txt\" , encoding = 'utf-8' ) # operacions sobre l'arxiu finally : f . close () Altra possibilitat \u00e9s amb with . En este cas no hem de tancar-lo expl\u00edcitament. Python 1 2 with open ( \"test.txt\" , encoding = 'utf-8' ) as f : # operacions sobre l'arxiu Escriptura Per a escriure, necessitem haver-lo obert amb les opcions w, a o x. Compte amb l'opci\u00f3 w, perqu\u00e8 sobreescriu els arxius. Python 1 2 3 4 with open ( \"test.txt\" , 'w' , encoding = 'utf-8' ) as f : f . write ( \"Primer arxiu \\n \" ) f . write ( \"Este arxiu \\n \" ) f . write ( \"cont\u00e9 tres l\u00ednies \\n \" ) Lectura Utilitzarem el m\u00e8tode read() per a llegir. La funci\u00f3 tell() ens diu en quina posici\u00f3 tenim el cursor i amb seek() el podem modificar. Python 1 2 3 4 5 6 7 8 9 10 11 12 >>> f = open ( \"test.txt\" , 'r' , encoding = 'utf-8' ) >>> f . read ( 6 ) 'Primer' >>> f . read ( 6 ) ' arxiu' >>> f . read () # llig fins al final ' \\n Este arxiu \\n cont\u00e9 tres l\u00ednies \\n ' >>> f . read () # posteriors lectures tornen la cadena buida '' Python 1 2 3 4 5 6 7 8 9 10 >>> f . tell () 45 >>> f . seek ( 0 ) 0 >>> print ( f . read ()) Primer arxiu Este arxiu cont\u00e9 tres l\u00ednies Tamb\u00e9 podem utilitzar la funci\u00f3 readline() per a llegir una l\u00ednia, o readlines() per a que ens torne una llista de l\u00ednies llegides. Activitat 11 Crea una aplicaci\u00f3 que vaja llegint operacions d'un fitxer \"operacions.txt\" que contindr\u00e0 una operaci\u00f3 per l\u00ednia. Per exemple: 4 + 4 Haur\u00e0 de guardar els resultats en un altre arxiu \"resultats.txt\". Per exemple: 4 + 4 = 8 Utilitza funcions an\u00f2nimes per a implementar les operacions de suma, resta, multiplicaci\u00f3 i divisi\u00f3, que seran les \u00faniques operacions reconegudes per la nostra aplicaci\u00f3. Directoris Si hi ha una gran quantitat de fitxers i directoris amb els que tractar, disposem del m\u00f2dul os (operating system), que ens proporciona m\u00e8todes per al seu tractament. Per a veure el directori de treball, utilitzem getcwd() . Python 1 2 3 >>> import os >>> os . getcwd () Per a canviar de directori, chdir() . Python 1 >>> os . chdir ( '/home/ferran' ) Per a llistar els directoris ens servim de listdir() . Python 1 >>> os . listdir ( '/home' ) Per crear un directori usem mkdir() . Python 1 >>> os . mkdir ( 'Nova_carpeta' ) Si volem renombrar un directori. Python 1 >>> os . rename ( 'Nova_carpeta' , 'Vella_carpeta' ) Per a eliminar un arxiu utilitzarem remove() . Si el que volem eliminar \u00e9s una carpeta buida rmdir() . Python 1 2 >>> os . remove ( 'arxiu.txt' ) >>> os . rmdir ( 'Vella_carpeta' ) En el cas que la carpeta no estiga buida, hem d'importar el m\u00f2dul shutil i utilitzar la funci\u00f3 rmtree() . Python 1 2 >>> import shutil >>> shutil . rmtree ( 'Carpeta' )","title":"Tractament de fitxers"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/#tractament-de-fitxers","text":"","title":"Tractament de fitxers"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/#fitxers","text":"","title":"Fitxers"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/#entrada-eixida-utilitzant-fitxers","text":"Per a llegir o escriure en un fitxer, primer l\u2019hem d\u2019obrir. Quan acabem, s\u2019ha de tancar perqu\u00e8 s\u2019alliberen els recursos relacionats amb el fitxer. Per tant, a Python, utilitzem la seg\u00fcent seq\u00fc\u00e8ncia d'operacions per traballar amb fitxers: Obrir un fitxer Llegir o escriure Tancar el fitxer","title":"Entrada eixida utilitzant fitxers"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/#open","text":"Per obrir un fitxer utilitzem la funci\u00f3 open() . Python 1 2 >>> f = open ( \"test.txt\" ) # arxiu en el mateix directori >>> f = open ( \"C:/Python38/README.txt\" ) # path sencer A m\u00e9s, podem especificar el mode d'apertura i la codificaci\u00f3. Mode Descripci\u00f3 r lectura w escriptura x creaci\u00f3 exclusiva (falla si ja existeix) a afegir al final, el crea si no existeix t mode lectura de text (per defecte) b mode binari + actualitzaci\u00f3 (lectura i escriptura ) Python 1 2 >>> f = open ( \"test.txt\" , 'w' ) # obert per a escriptura >>> f = open ( \"test.txt\" , mode = 'r' , encoding = 'utf-8' ) Warning \u00c9s important que tingau en compte que quan l'int\u00e8rpret de python s'executa, ho fa des del directori del qu\u00e8 s'ha llan\u00e7at(el podeu obtindre mitjan\u00e7ant os.getcwd() ), per aix\u00f2 la c\u00e0rrega de fitxers en rutes relatives en funcions tipus open , load , etc potser vos d\u00f3ne un error indicant que no el troba. f = open(\"ruta relativa/arxiu.txt\") S'han d'evitar les rutes absolutes . El que podeu fer per evitar estos errors \u00e9s obtindre la ruta des del fitxer font de la seg\u00fcent forma: Python 1 2 3 ruta_base = os . path . dirname ( __file__ ) ruta_a_recurs = os . path . join ( ruta_base , \"arxiu.txt\" ) f = open ( ruta_a_recurs )","title":"Open"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/#close","text":"Python utilitza un garbage collector per netejar objectes sense refer\u00e8ncies, per\u00f2 no hem de confiar per tancar el fitxer. Python 1 2 3 4 5 try : f = open ( \"test.txt\" , encoding = 'utf-8' ) # operacions sobre l'arxiu finally : f . close () Altra possibilitat \u00e9s amb with . En este cas no hem de tancar-lo expl\u00edcitament. Python 1 2 with open ( \"test.txt\" , encoding = 'utf-8' ) as f : # operacions sobre l'arxiu","title":"Close"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/#escriptura","text":"Per a escriure, necessitem haver-lo obert amb les opcions w, a o x. Compte amb l'opci\u00f3 w, perqu\u00e8 sobreescriu els arxius. Python 1 2 3 4 with open ( \"test.txt\" , 'w' , encoding = 'utf-8' ) as f : f . write ( \"Primer arxiu \\n \" ) f . write ( \"Este arxiu \\n \" ) f . write ( \"cont\u00e9 tres l\u00ednies \\n \" )","title":"Escriptura"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/#lectura","text":"Utilitzarem el m\u00e8tode read() per a llegir. La funci\u00f3 tell() ens diu en quina posici\u00f3 tenim el cursor i amb seek() el podem modificar. Python 1 2 3 4 5 6 7 8 9 10 11 12 >>> f = open ( \"test.txt\" , 'r' , encoding = 'utf-8' ) >>> f . read ( 6 ) 'Primer' >>> f . read ( 6 ) ' arxiu' >>> f . read () # llig fins al final ' \\n Este arxiu \\n cont\u00e9 tres l\u00ednies \\n ' >>> f . read () # posteriors lectures tornen la cadena buida '' Python 1 2 3 4 5 6 7 8 9 10 >>> f . tell () 45 >>> f . seek ( 0 ) 0 >>> print ( f . read ()) Primer arxiu Este arxiu cont\u00e9 tres l\u00ednies Tamb\u00e9 podem utilitzar la funci\u00f3 readline() per a llegir una l\u00ednia, o readlines() per a que ens torne una llista de l\u00ednies llegides.","title":"Lectura"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/#activitat-11","text":"Crea una aplicaci\u00f3 que vaja llegint operacions d'un fitxer \"operacions.txt\" que contindr\u00e0 una operaci\u00f3 per l\u00ednia. Per exemple: 4 + 4 Haur\u00e0 de guardar els resultats en un altre arxiu \"resultats.txt\". Per exemple: 4 + 4 = 8 Utilitza funcions an\u00f2nimes per a implementar les operacions de suma, resta, multiplicaci\u00f3 i divisi\u00f3, que seran les \u00faniques operacions reconegudes per la nostra aplicaci\u00f3.","title":"Activitat 11"},{"location":"unitats/1-python/teoria/4%20-%20Fitxers/#directoris","text":"Si hi ha una gran quantitat de fitxers i directoris amb els que tractar, disposem del m\u00f2dul os (operating system), que ens proporciona m\u00e8todes per al seu tractament. Per a veure el directori de treball, utilitzem getcwd() . Python 1 2 3 >>> import os >>> os . getcwd () Per a canviar de directori, chdir() . Python 1 >>> os . chdir ( '/home/ferran' ) Per a llistar els directoris ens servim de listdir() . Python 1 >>> os . listdir ( '/home' ) Per crear un directori usem mkdir() . Python 1 >>> os . mkdir ( 'Nova_carpeta' ) Si volem renombrar un directori. Python 1 >>> os . rename ( 'Nova_carpeta' , 'Vella_carpeta' ) Per a eliminar un arxiu utilitzarem remove() . Si el que volem eliminar \u00e9s una carpeta buida rmdir() . Python 1 2 >>> os . remove ( 'arxiu.txt' ) >>> os . rmdir ( 'Vella_carpeta' ) En el cas que la carpeta no estiga buida, hem d'importar el m\u00f2dul shutil i utilitzar la funci\u00f3 rmtree() . Python 1 2 >>> import shutil >>> shutil . rmtree ( 'Carpeta' )","title":"Directoris"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/","text":"Errors i excepcions Podem cometre errors mentre programem. Estos errors es poden classificar b\u00e0sicament en dos tipus: Errors de sintaxi Errors en la l\u00f2gica (Excepcions) Els erros de sintaxi es produixen abans de l'execuci\u00f3, mentre que els erros l\u00f2gics es produixen en temps d'execuci\u00f3. Excepcions Algun exemple d'excepci\u00f3 s\u00f3n els seg\u00fcents: Quan intentem obrir un fitxer (per llegir) que no existeix (FileNotFoundError) Quan intentem dividir un nombre per zero (ZeroDivisionError) Quan intentem importar un m\u00f2dul que no existeix (ImportError). Sempre que es produeixen aquests tipus d\u2019errors d\u2019execuci\u00f3, Python crea un objecte d\u2019excepci\u00f3. Si no el tractem, interrumpeix l'execuci\u00f3 i imprimeix una tra\u00e7a de l'error juntament amb alguns detalls sobre per qu\u00e8 ha produ\u00eft aquest error. Excepcions definides en Python Per a consultar totes les excepcions definides podem utilitzar: Python 1 >>> print ( dir ( locals ()[ '__builtins__' ])) ArithmeticError AssertionError AttributeError BaseException BlockingIOError BrokenPipeError BufferError ChildProcessError ConnectionAbortedError ConnectionError ConnectionRefusedError ConnectionResetError EOFError EnvironmentError Exception FileExistsError FileNotFoundError FloatingPointError GeneratorExit IOError ImportError IndentationError IndexError InterruptedError IsADirectoryError KeyError LookupError MemoryError ModuleNotFoundError NameError NotADirectoryError NotImplementedError OSError OverflowError PermissionError ProcessLookupError RecursionError ReferenceError RuntimeError StopAsyncIteration SyntaxError SystemError TabError TimeoutError TypeError UnboundLocalError UnicodeDecodeError UnicodeEncodeError UnicodeError UnicodeTranslateError ValueError Com funcionen les excepcions Python llan\u00e7a una d'aquestes excepcions en executar una instrucci\u00f3 que provoca un error. Quan es produeixen aquestes excepcions, l'int\u00e8rpret de Python det\u00e9n l'execuci\u00f3 del proc\u00e9s actual i el passa al proc\u00e9s que ha fet la crida, fins que alg\u00fa la tracte. Si ning\u00fan proc\u00e9s la tracta, el programa es detendr\u00e0. Per exemple, considerem un programa en qu\u00e8 tenim una funci\u00f3 A que crida a la funci\u00f3 B, que al seu torn crida a la funci\u00f3 C. Si es produeix una excepci\u00f3 a la funci\u00f3 C per\u00f2 no es tracta a C, l\u2019excepci\u00f3 passa a B i despr\u00e9s a A. Si no es gestiona mai, es mostrar\u00e0 un missatge d'error i el nostre programa s'aturar\u00e0 de sobte. Capturant excepcions en Python A Python, les excepcions es poden gestionar mitjan\u00e7ant una sent\u00e8ncia try. L'operaci\u00f3 cr\u00edtica que pot generar una excepci\u00f3 es col\u00b7loca dins de la cl\u00e0usula try . El codi que gestiona les excepcions s\u2019escriu a la cl\u00e0usula except i s'executar\u00e0 en produ\u00efr-se. Per tant, podem escollir quines operacions es realitzaran una vegada que haguem capturat l'excepci\u00f3. Exemple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # importem el m\u00f2dul sys per veure el tipus d'excepci\u00f3 import sys randomList = [ 'a' , 0 , 2 ] for element in randomList : try : print ( \"Element val \" , element ) r = 1 / int ( element ) break except : print ( \"Oops! Excepci\u00f3 capturada -->\" , sys . exc_info ()[ 0 ]) print ( \"Seg\u00fcent iteraci\u00f3\" ) print () print ( \"L'invers de \" , element , \"\u00e9s\" , r ) Com totes les excepcions hereden de la superclasse Exception, podem reescriure el programa com: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # importem el m\u00f2dul sys per veure el tipus d'excepci\u00f3 import sys randomList = [ 'a' , 0 , 2 ] for element in randomList : try : print ( \"Element val \" , element ) r = 1 / int ( element ) break except Exception as e : print ( \"Oops! Excepci\u00f3 capturada -->\" , e . __class__ ) print ( \"Seg\u00fcent iteraci\u00f3\" ) print () print ( \"L'invers de \" , element , \"\u00e9s\" , r ) A l'exemple anterior, no hem utilitzat cap excepci\u00f3 espec\u00edfica a la cl\u00e0usula except. No \u00e9s una bona pr\u00e0ctica de programaci\u00f3, ja que capturar\u00e0 totes les excepcions i gestionar\u00e0 tots els casos de la mateixa manera. Podem especificar quines excepcions hauria de capturar una cl\u00e0usula except. Una cl\u00e0usula try pot tindre un nombre indeterminat de cl\u00e0usules except per gestionar diferents excepcions, per\u00f2, nom\u00e9s s'executar\u00e0 una en cas que es produeixi una excepci\u00f3. Podem utilitzar una tupla de valors per especificar diverses excepcions en una cl\u00e0usula except. Exemple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 try : # fer alguna cosa pass except ValueError : # manegem ValueError pass except ( TypeError , ZeroDivisionError ): # manegem m\u00faltiples excepcions # TypeError i ZeroDivisionError pass except : # manegem totes les altres excepcions pass Try ... except ... finally La sent\u00e8ncia try de Python pot tindre una cl\u00e0usula final opcional. Aquesta cl\u00e0usula s\u2019executa independentment de si es produix una excepci\u00f3 o no i s\u2019utilitza generalment per alliberar recursos. Per exemple, podem estar connectats a un centre de dades remot a trav\u00e9s de la xarxa o treballar amb un fitxer o una interf\u00edcie gr\u00e0fica d'usuari (GUI). En totes aquestes circumst\u00e0ncies, hem de netejar recursos abans que el programa ature la seua execuci\u00f3, tant si ho fa de forma controlada com si es para bruscament. Aquestes accions (tancar un fitxer, GUI o desconnectar de la xarxa) es realitzen normalment a la cl\u00e0usula final. Exemple: Python 1 2 3 4 5 try : f = open ( \"test.txt\" , encoding = 'utf-8' ) # operacions amb el fitxer finally : f . close () Llan\u00e7ant excepcions en Python Les excepcions es generen normalment quan es produeixen errors en temps d'execuci\u00f3, per\u00f2 tamb\u00e9 podem generar/llan\u00e7ar excepcions manualment mitjan\u00e7ant la paraula reservada raise . Opcionalment, podem passar arguments a l\u2019excepci\u00f3 per aclarir per qu\u00e8 s\u2019ha generat aquesta excepci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 11 import sys try : nombre = int ( input ( \"Dona'm un n\u00famero positiu: \" )) if nombre <= 0 : raise ValueError ( str ( nombre ) + \" no \u00e9s un n\u00famero positiu!\" ) 1 / 0 except ValueError as ve : print ( \"Excepci\u00f3 capturada:\" , ve ) except : print ( \"Unexpected error:\" , sys . exc_info ()[ 0 ]) raise Assert Amb la paraula reservada assert llancem una excepci\u00f3 sempre i quan l'expressi\u00f3 que la segueix s'avalua a Fals . Si s'avalua a True , es continua l'execuci\u00f3 del programa de forma seq\u00fcencial. Python 1 2 3 4 5 6 7 8 9 try : num = int ( input ( \"Introdueix un nombre positiu: \" )) assert num > 0 except AssertionError : print ( \"AssertionError: No \u00e9s positiu!\" ) except ValueError : print ( \"ValueError: No has introd\u00eft un n\u00famero!\" ) else : print ( \"\u00c9s positiu\" ) Excepcions definides per l'usuari De vegades necessitem definir excepcions que no estan disponibles a Python quan es d\u00f3na alguna condici\u00f3. En este cas, hem de crear les nostres propies excepcions. Per a fer-ho, hem de definir noves classes que hereden de Exception , ja siga directa o indirectament. Esta nova excepci\u00f3 que hem creat tamb\u00e9 podr\u00e0 ser llan\u00e7ada amb raise . Python 1 2 3 4 5 6 7 8 9 10 11 12 >>> class CustomError ( Exception ): ... pass >>> raise CustomError Traceback ( most recent call last ): ... __main__ . CustomError >>> raise CustomError ( \"S'ha produ\u00eft un error\" ) Traceback ( most recent call last ): ... __main__ . CustomError : S 'ha produ\u00eft un error Quan estem desenvolupant un programa gran, \u00e9s una bona pr\u00e0ctica col\u00b7locar totes les excepcions definides per l'usuari que el nostre programa definix en un fitxer separat exceptions.py o errors.py . Activitat 12 Anem a implementar un xicotet joc per consola. El programa generar\u00e0 un n\u00famero aleatori entre 0 i 100 (utilitzeu randint() del m\u00f2dul random) i demanar\u00e0 a l'usuari que introdu\u00efsca un n\u00famero. Mentre el n\u00famero siga massa menut, llan\u00e7ar\u00e0 una excepci\u00f3 ErrorEnterMassaMenut indicant-li-ho. Si per contra \u00e9s massa gran llan\u00e7ar\u00e0 ErrorEnterMassaGran. Si s'introdueix un valor no num\u00e8ric, es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus ErrorNoEsEnter. El joc acabar\u00e0 quan s'introdu\u00efsca l'enter buscat, felicitant a l'usuari. Activitat 13 Modifica el codi de l'activitat 11 per a que no es produ\u00efsquen errors en l'execuci\u00f3, ja siga per introd\u00efur valor no definits per a les funcions, valors que no s\u00f3n num\u00e8rics o operacions desconegudes. Controla tamb\u00e9 que no es produ\u00efsquen errors en la lectura/escriptura dels arxius.","title":"Errors i excepcions"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#errors-i-excepcions","text":"Podem cometre errors mentre programem. Estos errors es poden classificar b\u00e0sicament en dos tipus: Errors de sintaxi Errors en la l\u00f2gica (Excepcions) Els erros de sintaxi es produixen abans de l'execuci\u00f3, mentre que els erros l\u00f2gics es produixen en temps d'execuci\u00f3.","title":"Errors i excepcions"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#excepcions","text":"Algun exemple d'excepci\u00f3 s\u00f3n els seg\u00fcents: Quan intentem obrir un fitxer (per llegir) que no existeix (FileNotFoundError) Quan intentem dividir un nombre per zero (ZeroDivisionError) Quan intentem importar un m\u00f2dul que no existeix (ImportError). Sempre que es produeixen aquests tipus d\u2019errors d\u2019execuci\u00f3, Python crea un objecte d\u2019excepci\u00f3. Si no el tractem, interrumpeix l'execuci\u00f3 i imprimeix una tra\u00e7a de l'error juntament amb alguns detalls sobre per qu\u00e8 ha produ\u00eft aquest error.","title":"Excepcions"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#excepcions-definides-en-python","text":"Per a consultar totes les excepcions definides podem utilitzar: Python 1 >>> print ( dir ( locals ()[ '__builtins__' ])) ArithmeticError AssertionError AttributeError BaseException BlockingIOError BrokenPipeError BufferError ChildProcessError ConnectionAbortedError ConnectionError ConnectionRefusedError ConnectionResetError EOFError EnvironmentError Exception FileExistsError FileNotFoundError FloatingPointError GeneratorExit IOError ImportError IndentationError IndexError InterruptedError IsADirectoryError KeyError LookupError MemoryError ModuleNotFoundError NameError NotADirectoryError NotImplementedError OSError OverflowError PermissionError ProcessLookupError RecursionError ReferenceError RuntimeError StopAsyncIteration SyntaxError SystemError TabError TimeoutError TypeError UnboundLocalError UnicodeDecodeError UnicodeEncodeError UnicodeError UnicodeTranslateError ValueError","title":"Excepcions definides en Python"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#com-funcionen-les-excepcions","text":"Python llan\u00e7a una d'aquestes excepcions en executar una instrucci\u00f3 que provoca un error. Quan es produeixen aquestes excepcions, l'int\u00e8rpret de Python det\u00e9n l'execuci\u00f3 del proc\u00e9s actual i el passa al proc\u00e9s que ha fet la crida, fins que alg\u00fa la tracte. Si ning\u00fan proc\u00e9s la tracta, el programa es detendr\u00e0. Per exemple, considerem un programa en qu\u00e8 tenim una funci\u00f3 A que crida a la funci\u00f3 B, que al seu torn crida a la funci\u00f3 C. Si es produeix una excepci\u00f3 a la funci\u00f3 C per\u00f2 no es tracta a C, l\u2019excepci\u00f3 passa a B i despr\u00e9s a A. Si no es gestiona mai, es mostrar\u00e0 un missatge d'error i el nostre programa s'aturar\u00e0 de sobte.","title":"Com funcionen les excepcions"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#capturant-excepcions-en-python","text":"A Python, les excepcions es poden gestionar mitjan\u00e7ant una sent\u00e8ncia try. L'operaci\u00f3 cr\u00edtica que pot generar una excepci\u00f3 es col\u00b7loca dins de la cl\u00e0usula try . El codi que gestiona les excepcions s\u2019escriu a la cl\u00e0usula except i s'executar\u00e0 en produ\u00efr-se. Per tant, podem escollir quines operacions es realitzaran una vegada que haguem capturat l'excepci\u00f3. Exemple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # importem el m\u00f2dul sys per veure el tipus d'excepci\u00f3 import sys randomList = [ 'a' , 0 , 2 ] for element in randomList : try : print ( \"Element val \" , element ) r = 1 / int ( element ) break except : print ( \"Oops! Excepci\u00f3 capturada -->\" , sys . exc_info ()[ 0 ]) print ( \"Seg\u00fcent iteraci\u00f3\" ) print () print ( \"L'invers de \" , element , \"\u00e9s\" , r ) Com totes les excepcions hereden de la superclasse Exception, podem reescriure el programa com: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # importem el m\u00f2dul sys per veure el tipus d'excepci\u00f3 import sys randomList = [ 'a' , 0 , 2 ] for element in randomList : try : print ( \"Element val \" , element ) r = 1 / int ( element ) break except Exception as e : print ( \"Oops! Excepci\u00f3 capturada -->\" , e . __class__ ) print ( \"Seg\u00fcent iteraci\u00f3\" ) print () print ( \"L'invers de \" , element , \"\u00e9s\" , r ) A l'exemple anterior, no hem utilitzat cap excepci\u00f3 espec\u00edfica a la cl\u00e0usula except. No \u00e9s una bona pr\u00e0ctica de programaci\u00f3, ja que capturar\u00e0 totes les excepcions i gestionar\u00e0 tots els casos de la mateixa manera. Podem especificar quines excepcions hauria de capturar una cl\u00e0usula except. Una cl\u00e0usula try pot tindre un nombre indeterminat de cl\u00e0usules except per gestionar diferents excepcions, per\u00f2, nom\u00e9s s'executar\u00e0 una en cas que es produeixi una excepci\u00f3. Podem utilitzar una tupla de valors per especificar diverses excepcions en una cl\u00e0usula except. Exemple: Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 try : # fer alguna cosa pass except ValueError : # manegem ValueError pass except ( TypeError , ZeroDivisionError ): # manegem m\u00faltiples excepcions # TypeError i ZeroDivisionError pass except : # manegem totes les altres excepcions pass","title":"Capturant excepcions en Python"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#try-except-finally","text":"La sent\u00e8ncia try de Python pot tindre una cl\u00e0usula final opcional. Aquesta cl\u00e0usula s\u2019executa independentment de si es produix una excepci\u00f3 o no i s\u2019utilitza generalment per alliberar recursos. Per exemple, podem estar connectats a un centre de dades remot a trav\u00e9s de la xarxa o treballar amb un fitxer o una interf\u00edcie gr\u00e0fica d'usuari (GUI). En totes aquestes circumst\u00e0ncies, hem de netejar recursos abans que el programa ature la seua execuci\u00f3, tant si ho fa de forma controlada com si es para bruscament. Aquestes accions (tancar un fitxer, GUI o desconnectar de la xarxa) es realitzen normalment a la cl\u00e0usula final. Exemple: Python 1 2 3 4 5 try : f = open ( \"test.txt\" , encoding = 'utf-8' ) # operacions amb el fitxer finally : f . close ()","title":"Try ... except ... finally"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#llancant-excepcions-en-python","text":"Les excepcions es generen normalment quan es produeixen errors en temps d'execuci\u00f3, per\u00f2 tamb\u00e9 podem generar/llan\u00e7ar excepcions manualment mitjan\u00e7ant la paraula reservada raise . Opcionalment, podem passar arguments a l\u2019excepci\u00f3 per aclarir per qu\u00e8 s\u2019ha generat aquesta excepci\u00f3. Python 1 2 3 4 5 6 7 8 9 10 11 import sys try : nombre = int ( input ( \"Dona'm un n\u00famero positiu: \" )) if nombre <= 0 : raise ValueError ( str ( nombre ) + \" no \u00e9s un n\u00famero positiu!\" ) 1 / 0 except ValueError as ve : print ( \"Excepci\u00f3 capturada:\" , ve ) except : print ( \"Unexpected error:\" , sys . exc_info ()[ 0 ]) raise","title":"Llan\u00e7ant excepcions en Python"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#assert","text":"Amb la paraula reservada assert llancem una excepci\u00f3 sempre i quan l'expressi\u00f3 que la segueix s'avalua a Fals . Si s'avalua a True , es continua l'execuci\u00f3 del programa de forma seq\u00fcencial. Python 1 2 3 4 5 6 7 8 9 try : num = int ( input ( \"Introdueix un nombre positiu: \" )) assert num > 0 except AssertionError : print ( \"AssertionError: No \u00e9s positiu!\" ) except ValueError : print ( \"ValueError: No has introd\u00eft un n\u00famero!\" ) else : print ( \"\u00c9s positiu\" )","title":"Assert"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#excepcions-definides-per-lusuari","text":"De vegades necessitem definir excepcions que no estan disponibles a Python quan es d\u00f3na alguna condici\u00f3. En este cas, hem de crear les nostres propies excepcions. Per a fer-ho, hem de definir noves classes que hereden de Exception , ja siga directa o indirectament. Esta nova excepci\u00f3 que hem creat tamb\u00e9 podr\u00e0 ser llan\u00e7ada amb raise . Python 1 2 3 4 5 6 7 8 9 10 11 12 >>> class CustomError ( Exception ): ... pass >>> raise CustomError Traceback ( most recent call last ): ... __main__ . CustomError >>> raise CustomError ( \"S'ha produ\u00eft un error\" ) Traceback ( most recent call last ): ... __main__ . CustomError : S 'ha produ\u00eft un error Quan estem desenvolupant un programa gran, \u00e9s una bona pr\u00e0ctica col\u00b7locar totes les excepcions definides per l'usuari que el nostre programa definix en un fitxer separat exceptions.py o errors.py .","title":"Excepcions definides per l'usuari"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#activitat-12","text":"Anem a implementar un xicotet joc per consola. El programa generar\u00e0 un n\u00famero aleatori entre 0 i 100 (utilitzeu randint() del m\u00f2dul random) i demanar\u00e0 a l'usuari que introdu\u00efsca un n\u00famero. Mentre el n\u00famero siga massa menut, llan\u00e7ar\u00e0 una excepci\u00f3 ErrorEnterMassaMenut indicant-li-ho. Si per contra \u00e9s massa gran llan\u00e7ar\u00e0 ErrorEnterMassaGran. Si s'introdueix un valor no num\u00e8ric, es llan\u00e7ar\u00e0 una excepci\u00f3 de tipus ErrorNoEsEnter. El joc acabar\u00e0 quan s'introdu\u00efsca l'enter buscat, felicitant a l'usuari.","title":"Activitat 12"},{"location":"unitats/1-python/teoria/5%20-%20Excepcions/#activitat-13","text":"Modifica el codi de l'activitat 11 per a que no es produ\u00efsquen errors en l'execuci\u00f3, ja siga per introd\u00efur valor no definits per a les funcions, valors que no s\u00f3n num\u00e8rics o operacions desconegudes. Controla tamb\u00e9 que no es produ\u00efsquen errors en la lectura/escriptura dels arxius.","title":"Activitat 13"},{"location":"unitats/1-python/teoria/6%20-%20POO/","text":"Programaci\u00f3 orientada a objectes amb Python \u00c9s un dels paradigmes m\u00e9s populars per resoldre problemes a trav\u00e9s de la programaci\u00f3. Un objecte t\u00e9 dues caracter\u00edstiques: atributs (estat) funcions (comportament) Per exemple: Una persona pot ser un objecte, ja que t\u00e9 les propietats seg\u00fcents: nom, edat com a atributs cantar, ballar com a comportament El concepte de POO a Python se centra en la reutilitzaci\u00f3 de codi. Aquest concepte tamb\u00e9 es coneix com DRY (Don't Repeat Yourself). Classes Una classe \u00e9s una definici\u00f3 d'un objecte abstracte, que representa algun ent de la realitat al nostre programa. Cont\u00e9 tots els detalls comuns sobre tots els objectes del mateix tipus. L'exemple de classe de lloro pot ser: Python 1 2 class Parrot (): pass Ac\u00ed fem servir la paraula clau class per definir una classe Loro buida. Objectes Quan es defineix la classe, nom\u00e9s es defineix la descripci\u00f3 de l'objecte. Per tant, no s\u2019assignen recursos per a la seua execuci\u00f3, ni s'assignen valors als seus atributs. Quan este fet es produeix, aleshores tenim un objecte en mem\u00f2ria sobre el que podem actuar. L'exemple d'objecte de classe lloro pot ser: Python 1 obj = Loro () Aqu\u00ed, obj \u00e9s un objecte de la classe Loro. Suposem que tenim detalls de lloros. Ara, podem construir la classe i crear un objecte per a cada lloro. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Parrot : # class attribute species = \"bird\" # instance attribute def __init__ ( self , name , age ): self . name = name self . age = age # instantiate the Parrot class blu = Parrot ( \"Blu\" , 10 ) woo = Parrot ( \"Woo\" , 15 ) # access the class attributes print ( \"Blu is a {} \" . format ( blu . __class__ . species )) print ( \"Woo is also a {} \" . format ( woo . __class__ . species )) # access the instance attributes print ( \" {} is {} years old\" . format ( blu . name , blu . age )) print ( \" {} is {} years old\" . format ( woo . name , woo . age )) --- Eixida Blu is a bird Woo is also a bird Blu is 10 years old Woo is 15 years old Al programa anterior, hem creat una classe Parrot. A continuaci\u00f3, hem definit uns atributs, que prendran valors diferents en la instanciaci\u00f3 d'objectes diferents. Aquests atributs es defineixen dins del m\u00e8tode init de la classe, que \u00e9s el m\u00e8tode inicialitzador que s\u2019executar\u00e0 nom\u00e9s creem objectes. Despr\u00e9s, creem inst\u00e0ncies de la classe Parrot. blu i woo s\u00f3n refer\u00e8ncies (valor) als nostres objectes nous. Podem accedir als atributs de classe mitjan\u00e7ant __class__.species . Els atributs de classe s\u00f3n els mateixos per a totes les inst\u00e0ncies d\u2019una classe. De la mateixa manera, accedim als atributs de la inst\u00e0ncia mitjan\u00e7ant objecte.nom_atribut . Els atributs d\u2019inst\u00e0ncia (valors) s\u00f3n diferents per a cada inst\u00e0ncia d\u2019una classe. M\u00e8todes S\u00f3n funcions definides dins el cos d'una classe. S'utilitzen per a definir el comportament de l'objecte. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Parrot : # instance attributes def __init__ ( self , name , age ): self . name = name self . age = age # instance method def sing ( self , song ): return \" {} sings {} \" . format ( self . name , song ) def dance ( self ): return \" {} is now dancing\" . format ( self . name ) # instantiate the object blu = Parrot ( \"Blu\" , 10 ) # call our instance methods print ( blu . sing ( \"'Happy'\" )) print ( blu . dance ()) --- Blu sings 'Happy' Blu is now dancing Hem definit dos m\u00e8todes sing() i dance(), que s\u00f3n m\u00e8todes d'inst\u00e0ncia, ja que es criden sobre un objecte. Her\u00e8ncia L'her\u00e8ncia \u00e9s una forma de reutilitzar codi sense tindre-lo que reescriure. A\u00e7\u00f2 facilita el manteniment de les aplicacions. Les noves classes s'anomenen classes derivades (o classe filla). La classes de les que deriven s\u00f3n les classes base (o classe pare). Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # parent class class Bird : def __init__ ( self ): print ( \"Bird is ready\" ) def who_is_this ( self ): print ( \"Bird\" ) def swim ( self ): print ( \"Swim faster\" ) # child class class Penguin ( Bird ): def __init__ ( self ): # call super() function super () . __init__ () print ( \"Penguin is ready\" ) def who_is_this ( self ): print ( \"Penguin\" ) def run ( self ): print ( \"Run faster\" ) peggy = Penguin () peggy . whoisThis () peggy . swim () peggy . run () --- Bird is ready Penguin is ready Penguin Swim faster Run faster En l'anterior programa, la classe Penguin hereda de la classe Bird. La classe derivada hereda el m\u00e8tode swim() , modifica el m\u00e8tode who_is_this() i ext\u00e9n amb un nou m\u00e8tode run() . Utilitzem super().__init__() dins de l' __init()__ per a inicialitzar la classe pare. Encapsulament Podem restringir l\u2019acc\u00e9s a m\u00e8todes i variables, \u00e9s a dir, definir-los com a privats. Aix\u00f2 impedeix que les dades es modifiquen directament accedint als atributs, \u00e9s el que anomenem encapsulament. Definim atributs o m\u00e8todes privats utilitzant el gui\u00f3 baix com a prefix, \u00e9s a dir, simple _ o doble __. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Computer : def __init__ ( self ): self . __maxprice = 900 def sell ( self ): print ( \"Selling Price: {} \" . format ( self . __maxprice )) def setMaxPrice ( self , price ): self . __maxprice = price c = Computer () c . sell () # change the price c . __maxprice = 1000 c . sell () # using setter function c . setMaxPrice ( 1000 ) c . sell () Text Only 1 2 3 4 Eixida Selling Price: 900 Selling Price: 900 Selling Price: 1000 Com vegem, per canviar el valor, hem d\u2019utilitzar una funci\u00f3 modificadora setter , \u00e9s a dir, setMaxPrice (), que pren el preu com a par\u00e0metre. Polimorfisme El polimorfisme \u00e9s la capacitat d\u2019utilitzar una interf\u00edcie comuna (crides amb els mateixos noms) en diferents classes derivades. Suposem que hem de pintar una forma i que hi ha diverses opcions: rectangle, quadrat, cercle, ... Podr\u00edem utilitzar el mateix m\u00e8tode per a pintar qualsevol forma. Aquest concepte s\u2019anomena polimorfisme. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Parrot : def fly ( self ): print ( \"Parrot can fly\" ) def swim ( self ): print ( \"Parrot can't swim\" ) class Penguin : def fly ( self ): print ( \"Penguin can't fly\" ) def swim ( self ): print ( \"Penguin can swim\" ) # common interface def flying_test ( bird ): bird . fly () #instantiate objects blu = Parrot () peggy = Penguin () # passing the object flying_test ( blu ) flying_test ( peggy ) Text Only 1 2 Parrot can fly Penguin can't fly Al programa anterior, hem definit dues classes Parrot i Penguin. Cadascun d'elles t\u00e9 un m\u00e8tode com\u00fa fly(). No obstant aix\u00f2, les seues funcions s\u00f3n diferents. Per utilitzar el polimorfisme, hem creat una interf\u00edcie comuna, \u00e9s a dir, la funci\u00f3 flying_test() que pren com a par\u00e0metre qualsevol objecte i crida al m\u00e8tode fly() de l\u2019objecte. Aix\u00ed, quan passem els objectes blu i peggy a la funci\u00f3 flying_test(), s'executa el m\u00e8tode corresponent a cadascuna. Activitat 14 Defineix una jerarquia de figures amb les classes Figura , Cercle , Triangle , Rectangle i Quadrat . La clase Figura tindr\u00e1 dos m\u00e9todes abstractes area i perimetre , que implementar\u00e1n la resta de classes. La classe figura ser\u00e0 el que s'anomena una interf\u00edcie informal, ja que tots els seus m\u00e8todes s\u00f3n abstractes. Per a definir que s\u00f3n abstractes, simplement utilitzeu la instrucci\u00f3 pass al bloc de la funci\u00f3. Python 1 2 3 def area () -> int : \"\"\"Torna l'\u00e0rea d'una Figura\"\"\" pass El Cercle rebr\u00e1 el radi com a argument al seu constructor, el Triangle el costat i el Rectangle la base i l'altura. Cercle, Triangle i Rectangle heredar\u00e1n de Figura directament. Quadrat heredar\u00e1 de Rectangle, per\u00f2 al constructor sols rebr\u00e1 un argument, el costat. Crea un objecte de cada tipus i imprimeix les seues caracter\u00edstiques. Info En realitat la classe Figura es pot implementar com a una classe interf\u00edcie , on tots els seus m\u00e8todes siguen abstractes. En Python existeixen dos tipus d'interf\u00edcies, formals i informals. Per altra banda, podem declarar els atributs de les classes com a atributs privats i utilitzar els decoradors @property i @ atribut .setter per a indicar els m\u00e8todes getters i setters, que seran p\u00fablics. Fer-ho d'esta forma t\u00e9 alguns avantatges que veurem m\u00e9s endavant.","title":"Programaci\u00f3 oorientada a objectes"},{"location":"unitats/1-python/teoria/6%20-%20POO/#programacio-orientada-a-objectes-amb-python","text":"\u00c9s un dels paradigmes m\u00e9s populars per resoldre problemes a trav\u00e9s de la programaci\u00f3. Un objecte t\u00e9 dues caracter\u00edstiques: atributs (estat) funcions (comportament) Per exemple: Una persona pot ser un objecte, ja que t\u00e9 les propietats seg\u00fcents: nom, edat com a atributs cantar, ballar com a comportament El concepte de POO a Python se centra en la reutilitzaci\u00f3 de codi. Aquest concepte tamb\u00e9 es coneix com DRY (Don't Repeat Yourself).","title":"Programaci\u00f3 orientada a objectes amb Python"},{"location":"unitats/1-python/teoria/6%20-%20POO/#classes","text":"Una classe \u00e9s una definici\u00f3 d'un objecte abstracte, que representa algun ent de la realitat al nostre programa. Cont\u00e9 tots els detalls comuns sobre tots els objectes del mateix tipus. L'exemple de classe de lloro pot ser: Python 1 2 class Parrot (): pass Ac\u00ed fem servir la paraula clau class per definir una classe Loro buida.","title":"Classes"},{"location":"unitats/1-python/teoria/6%20-%20POO/#objectes","text":"Quan es defineix la classe, nom\u00e9s es defineix la descripci\u00f3 de l'objecte. Per tant, no s\u2019assignen recursos per a la seua execuci\u00f3, ni s'assignen valors als seus atributs. Quan este fet es produeix, aleshores tenim un objecte en mem\u00f2ria sobre el que podem actuar. L'exemple d'objecte de classe lloro pot ser: Python 1 obj = Loro () Aqu\u00ed, obj \u00e9s un objecte de la classe Loro. Suposem que tenim detalls de lloros. Ara, podem construir la classe i crear un objecte per a cada lloro. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Parrot : # class attribute species = \"bird\" # instance attribute def __init__ ( self , name , age ): self . name = name self . age = age # instantiate the Parrot class blu = Parrot ( \"Blu\" , 10 ) woo = Parrot ( \"Woo\" , 15 ) # access the class attributes print ( \"Blu is a {} \" . format ( blu . __class__ . species )) print ( \"Woo is also a {} \" . format ( woo . __class__ . species )) # access the instance attributes print ( \" {} is {} years old\" . format ( blu . name , blu . age )) print ( \" {} is {} years old\" . format ( woo . name , woo . age )) --- Eixida Blu is a bird Woo is also a bird Blu is 10 years old Woo is 15 years old Al programa anterior, hem creat una classe Parrot. A continuaci\u00f3, hem definit uns atributs, que prendran valors diferents en la instanciaci\u00f3 d'objectes diferents. Aquests atributs es defineixen dins del m\u00e8tode init de la classe, que \u00e9s el m\u00e8tode inicialitzador que s\u2019executar\u00e0 nom\u00e9s creem objectes. Despr\u00e9s, creem inst\u00e0ncies de la classe Parrot. blu i woo s\u00f3n refer\u00e8ncies (valor) als nostres objectes nous. Podem accedir als atributs de classe mitjan\u00e7ant __class__.species . Els atributs de classe s\u00f3n els mateixos per a totes les inst\u00e0ncies d\u2019una classe. De la mateixa manera, accedim als atributs de la inst\u00e0ncia mitjan\u00e7ant objecte.nom_atribut . Els atributs d\u2019inst\u00e0ncia (valors) s\u00f3n diferents per a cada inst\u00e0ncia d\u2019una classe.","title":"Objectes"},{"location":"unitats/1-python/teoria/6%20-%20POO/#metodes","text":"S\u00f3n funcions definides dins el cos d'una classe. S'utilitzen per a definir el comportament de l'objecte. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Parrot : # instance attributes def __init__ ( self , name , age ): self . name = name self . age = age # instance method def sing ( self , song ): return \" {} sings {} \" . format ( self . name , song ) def dance ( self ): return \" {} is now dancing\" . format ( self . name ) # instantiate the object blu = Parrot ( \"Blu\" , 10 ) # call our instance methods print ( blu . sing ( \"'Happy'\" )) print ( blu . dance ()) --- Blu sings 'Happy' Blu is now dancing Hem definit dos m\u00e8todes sing() i dance(), que s\u00f3n m\u00e8todes d'inst\u00e0ncia, ja que es criden sobre un objecte.","title":"M\u00e8todes"},{"location":"unitats/1-python/teoria/6%20-%20POO/#herencia","text":"L'her\u00e8ncia \u00e9s una forma de reutilitzar codi sense tindre-lo que reescriure. A\u00e7\u00f2 facilita el manteniment de les aplicacions. Les noves classes s'anomenen classes derivades (o classe filla). La classes de les que deriven s\u00f3n les classes base (o classe pare). Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # parent class class Bird : def __init__ ( self ): print ( \"Bird is ready\" ) def who_is_this ( self ): print ( \"Bird\" ) def swim ( self ): print ( \"Swim faster\" ) # child class class Penguin ( Bird ): def __init__ ( self ): # call super() function super () . __init__ () print ( \"Penguin is ready\" ) def who_is_this ( self ): print ( \"Penguin\" ) def run ( self ): print ( \"Run faster\" ) peggy = Penguin () peggy . whoisThis () peggy . swim () peggy . run () --- Bird is ready Penguin is ready Penguin Swim faster Run faster En l'anterior programa, la classe Penguin hereda de la classe Bird. La classe derivada hereda el m\u00e8tode swim() , modifica el m\u00e8tode who_is_this() i ext\u00e9n amb un nou m\u00e8tode run() . Utilitzem super().__init__() dins de l' __init()__ per a inicialitzar la classe pare.","title":"Her\u00e8ncia"},{"location":"unitats/1-python/teoria/6%20-%20POO/#encapsulament","text":"Podem restringir l\u2019acc\u00e9s a m\u00e8todes i variables, \u00e9s a dir, definir-los com a privats. Aix\u00f2 impedeix que les dades es modifiquen directament accedint als atributs, \u00e9s el que anomenem encapsulament. Definim atributs o m\u00e8todes privats utilitzant el gui\u00f3 baix com a prefix, \u00e9s a dir, simple _ o doble __. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Computer : def __init__ ( self ): self . __maxprice = 900 def sell ( self ): print ( \"Selling Price: {} \" . format ( self . __maxprice )) def setMaxPrice ( self , price ): self . __maxprice = price c = Computer () c . sell () # change the price c . __maxprice = 1000 c . sell () # using setter function c . setMaxPrice ( 1000 ) c . sell () Text Only 1 2 3 4 Eixida Selling Price: 900 Selling Price: 900 Selling Price: 1000 Com vegem, per canviar el valor, hem d\u2019utilitzar una funci\u00f3 modificadora setter , \u00e9s a dir, setMaxPrice (), que pren el preu com a par\u00e0metre.","title":"Encapsulament"},{"location":"unitats/1-python/teoria/6%20-%20POO/#polimorfisme","text":"El polimorfisme \u00e9s la capacitat d\u2019utilitzar una interf\u00edcie comuna (crides amb els mateixos noms) en diferents classes derivades. Suposem que hem de pintar una forma i que hi ha diverses opcions: rectangle, quadrat, cercle, ... Podr\u00edem utilitzar el mateix m\u00e8tode per a pintar qualsevol forma. Aquest concepte s\u2019anomena polimorfisme. Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Parrot : def fly ( self ): print ( \"Parrot can fly\" ) def swim ( self ): print ( \"Parrot can't swim\" ) class Penguin : def fly ( self ): print ( \"Penguin can't fly\" ) def swim ( self ): print ( \"Penguin can swim\" ) # common interface def flying_test ( bird ): bird . fly () #instantiate objects blu = Parrot () peggy = Penguin () # passing the object flying_test ( blu ) flying_test ( peggy ) Text Only 1 2 Parrot can fly Penguin can't fly Al programa anterior, hem definit dues classes Parrot i Penguin. Cadascun d'elles t\u00e9 un m\u00e8tode com\u00fa fly(). No obstant aix\u00f2, les seues funcions s\u00f3n diferents. Per utilitzar el polimorfisme, hem creat una interf\u00edcie comuna, \u00e9s a dir, la funci\u00f3 flying_test() que pren com a par\u00e0metre qualsevol objecte i crida al m\u00e8tode fly() de l\u2019objecte. Aix\u00ed, quan passem els objectes blu i peggy a la funci\u00f3 flying_test(), s'executa el m\u00e8tode corresponent a cadascuna.","title":"Polimorfisme"},{"location":"unitats/1-python/teoria/6%20-%20POO/#activitat-14","text":"Defineix una jerarquia de figures amb les classes Figura , Cercle , Triangle , Rectangle i Quadrat . La clase Figura tindr\u00e1 dos m\u00e9todes abstractes area i perimetre , que implementar\u00e1n la resta de classes. La classe figura ser\u00e0 el que s'anomena una interf\u00edcie informal, ja que tots els seus m\u00e8todes s\u00f3n abstractes. Per a definir que s\u00f3n abstractes, simplement utilitzeu la instrucci\u00f3 pass al bloc de la funci\u00f3. Python 1 2 3 def area () -> int : \"\"\"Torna l'\u00e0rea d'una Figura\"\"\" pass El Cercle rebr\u00e1 el radi com a argument al seu constructor, el Triangle el costat i el Rectangle la base i l'altura. Cercle, Triangle i Rectangle heredar\u00e1n de Figura directament. Quadrat heredar\u00e1 de Rectangle, per\u00f2 al constructor sols rebr\u00e1 un argument, el costat. Crea un objecte de cada tipus i imprimeix les seues caracter\u00edstiques. Info En realitat la classe Figura es pot implementar com a una classe interf\u00edcie , on tots els seus m\u00e8todes siguen abstractes. En Python existeixen dos tipus d'interf\u00edcies, formals i informals. Per altra banda, podem declarar els atributs de les classes com a atributs privats i utilitzar els decoradors @property i @ atribut .setter per a indicar els m\u00e8todes getters i setters, que seran p\u00fablics. Fer-ho d'esta forma t\u00e9 alguns avantatges que veurem m\u00e9s endavant.","title":"Activitat 14"},{"location":"unitats/2-intro-interficies/tasques/1%20-%20Activitats/","text":"1. Interf\u00edcies d'usuari Activitat 1 T'han encarregat que faces el disseny de la interf\u00edcie d'usuari per a l'aplicaci\u00f3 d'una empresa de lloguer de cotxes amb oficina a l'aeroport. L'aplicaci\u00f3 ser\u00e0 utilitzada pels empleats de l'oficina situada a la terminal d'arribades de l'aeroport, que atenen directament els viatgers que volen llogar un cotxe de manera presencial. \u00c9s habitual que a l'oficina hi haja alumnes de pr\u00e0ctiques de Formaci\u00f3 Professional realitzant les FCTs. La primera decisi\u00f3 que has de prendre \u00e9s el tipus d'interf\u00edcie que plantejar\u00e0s en el teu disseny: CLI, GUI o NUI. Justifica la resposta. Activitat 2 - Escola infantil Participes en el projecte de desenvolupament d'una aplicaci\u00f3 per als docents d'una escola bressol, i t'han encarregat elaborar l'an\u00e0lisi del context d'\u00fas (primer pas del disseny centrat en l'usuari). L'aplicaci\u00f3 estar\u00e0 instal\u00b7lada en un ordinador a cada aula i l'objectiu \u00e9s facilitar el m\u00e0xim possible la tasca dels professors del centre. CLAUS DE RESOLUCI\u00d3 Recorda que el context d'\u00fas est\u00e0 format tant per les tasques que realitzen els usuaris, com per les caracter\u00edstiques dels usuaris i de l'entorn d'\u00fas que poden ser rellevants per al disseny de la soluci\u00f3. 2. Usabilitat Activitat 1 No tots els components de la usabilitat vistos en aquest apartat (aprenentatge, record, efic\u00e0cia, errors i satisfacci\u00f3) tenen la mateixa import\u00e0ncia a totes les aplicacions. Segurament, els components de la usabilitat amb m\u00e9s pes en un joc no seran els mateixos que els d'una aplicaci\u00f3 de retoc fotogr\u00e0fic. En aquest cas pr\u00e0ctic haur\u00e0s d'ordenar de m\u00e9s a menys import\u00e0ncia els cinc components de la usabilitat en una aplicaci\u00f3 d'\u00e0mbit empresarial (per exemple, un programari de gesti\u00f3 de la comptabilitat). 3. Pautes de disseny Activitat 1 Durant el disseny d'una aplicaci\u00f3 per a la compra de peces de roba es planteja la q\u00fcesti\u00f3 de quin tipus de controls utilitzar per als camps seg\u00fcents: Quantitat de peces (el m\u00e0xim \u00e9s de 10). Talla (les possibles opcions s\u00f3n S, M i L). Si l'usuari vol que s'embolique la pe\u00e7a per a regal. En cas que siga per a regal, el missatge que es posar\u00e0 a la targeta. Quin tipus de control dels comentats en la teoria seria m\u00e9s adequat per a cada cas? Activitat 2 - Formulari Redissenya el seg\u00fcent formulari de manera que siga m\u00e9s usable per als usuaris.","title":"Activitats"},{"location":"unitats/2-intro-interficies/tasques/1%20-%20Activitats/#1-interficies-dusuari","text":"","title":"1. Interf\u00edcies d'usuari"},{"location":"unitats/2-intro-interficies/tasques/1%20-%20Activitats/#activitat-1","text":"T'han encarregat que faces el disseny de la interf\u00edcie d'usuari per a l'aplicaci\u00f3 d'una empresa de lloguer de cotxes amb oficina a l'aeroport. L'aplicaci\u00f3 ser\u00e0 utilitzada pels empleats de l'oficina situada a la terminal d'arribades de l'aeroport, que atenen directament els viatgers que volen llogar un cotxe de manera presencial. \u00c9s habitual que a l'oficina hi haja alumnes de pr\u00e0ctiques de Formaci\u00f3 Professional realitzant les FCTs. La primera decisi\u00f3 que has de prendre \u00e9s el tipus d'interf\u00edcie que plantejar\u00e0s en el teu disseny: CLI, GUI o NUI. Justifica la resposta.","title":"Activitat 1"},{"location":"unitats/2-intro-interficies/tasques/1%20-%20Activitats/#activitat-2-escola-infantil","text":"Participes en el projecte de desenvolupament d'una aplicaci\u00f3 per als docents d'una escola bressol, i t'han encarregat elaborar l'an\u00e0lisi del context d'\u00fas (primer pas del disseny centrat en l'usuari). L'aplicaci\u00f3 estar\u00e0 instal\u00b7lada en un ordinador a cada aula i l'objectiu \u00e9s facilitar el m\u00e0xim possible la tasca dels professors del centre. CLAUS DE RESOLUCI\u00d3 Recorda que el context d'\u00fas est\u00e0 format tant per les tasques que realitzen els usuaris, com per les caracter\u00edstiques dels usuaris i de l'entorn d'\u00fas que poden ser rellevants per al disseny de la soluci\u00f3.","title":"Activitat 2 - Escola infantil"},{"location":"unitats/2-intro-interficies/tasques/1%20-%20Activitats/#2-usabilitat","text":"","title":"2. Usabilitat"},{"location":"unitats/2-intro-interficies/tasques/1%20-%20Activitats/#activitat-1_1","text":"No tots els components de la usabilitat vistos en aquest apartat (aprenentatge, record, efic\u00e0cia, errors i satisfacci\u00f3) tenen la mateixa import\u00e0ncia a totes les aplicacions. Segurament, els components de la usabilitat amb m\u00e9s pes en un joc no seran els mateixos que els d'una aplicaci\u00f3 de retoc fotogr\u00e0fic. En aquest cas pr\u00e0ctic haur\u00e0s d'ordenar de m\u00e9s a menys import\u00e0ncia els cinc components de la usabilitat en una aplicaci\u00f3 d'\u00e0mbit empresarial (per exemple, un programari de gesti\u00f3 de la comptabilitat).","title":"Activitat 1"},{"location":"unitats/2-intro-interficies/tasques/1%20-%20Activitats/#3-pautes-de-disseny","text":"","title":"3. Pautes de disseny"},{"location":"unitats/2-intro-interficies/tasques/1%20-%20Activitats/#activitat-1_2","text":"Durant el disseny d'una aplicaci\u00f3 per a la compra de peces de roba es planteja la q\u00fcesti\u00f3 de quin tipus de controls utilitzar per als camps seg\u00fcents: Quantitat de peces (el m\u00e0xim \u00e9s de 10). Talla (les possibles opcions s\u00f3n S, M i L). Si l'usuari vol que s'embolique la pe\u00e7a per a regal. En cas que siga per a regal, el missatge que es posar\u00e0 a la targeta. Quin tipus de control dels comentats en la teoria seria m\u00e9s adequat per a cada cas?","title":"Activitat 1"},{"location":"unitats/2-intro-interficies/tasques/1%20-%20Activitats/#activitat-2-formulari","text":"Redissenya el seg\u00fcent formulari de manera que siga m\u00e9s usable per als usuaris.","title":"Activitat 2 - Formulari"},{"location":"unitats/2-intro-interficies/tasques/2%20-%20Pr%C3%A0ctiques/","text":"Pr\u00e0ctica 1 - Heur\u00edstiques d'usabilitat L'any 1994, el guru de la usabilitat Jakob Nielsen va proposar 10 heur\u00edstiques per al disseny d'interf\u00edcies d'usuari basant-se en la seua experi\u00e8ncia personal en aquest camp. Tot i el temps transcorregut des del seu plantejament, les heur\u00edstiques de Nielsen segueixen vigents i s\u00f3n utilitzades per la majoria dels professionals del disseny. Heur\u00edstica Una heur\u00edstica es pot definir com un m\u00e8tode o principi basat en l'experi\u00e8ncia, que es pot utilitzar com a ajuda per resoldre un problema m\u00e9s complex. A continuaci\u00f3 detallem les 10 heur\u00edstiques de Nielsen: 1. Visibilitat de l'estat del sistema : sempre hem de mantenir informats els usuaris del que est\u00e0 passant a l'aplicaci\u00f3, tan aviat com siga possible. 2. Relaci\u00f3 entre el sistema i el m\u00f3n real : la interf\u00edcie ha d'utilitzar expressions i conceptes propers a l'usuari i a l'entorn real on es desenvolupa la seua activitat. 3. Donar llibertat i el control a l'usuari : l'usuari ha de tenir el control de qu\u00e8 passa a l'aplicaci\u00f3 en tot moment, fins i tot podent canviar d'opini\u00f3 respecte a una acci\u00f3 anterior. 4. Consist\u00e8ncia i est\u00e0ndards : el nostre disseny ha de ser consistent amb all\u00f2 que l'usuari acostuma a trobar en altres productes, i respectar els est\u00e0ndards establerts per a la plataforma o el tipus d'aplicaci\u00f3. 5. Prevenci\u00f3 d'errors : la interf\u00edcie que plantegem ha d'ajudar l'usuari a no cometre errors, anticipant-nos a les accions i comportaments que els poden ocasionar. 6. Recon\u00e8ixer en comptes de recordar : la nostra aplicaci\u00f3 ha de minimitzar l'esfor\u00e7 de memoritzaci\u00f3 de l'usuari, facilitant l'acc\u00e9s a la informaci\u00f3 que necessite a cada moment. 7. Flexibilitat i efici\u00e8ncia d'\u00fas : hem d'oferir diferents maneres de fer les coses, de manera que els usuaris amb caracter\u00edstiques diferents o diferents nivells d'experi\u00e8ncia puguen utilitzar el nostre disseny de forma eficient. 8. Est\u00e8tica i disseny minimalista : tots els elements visuals que utilitzem a la interf\u00edcie han de tenir un prop\u00f2sit i ajudar els objectius de l'usuari, evitant elements purament decoratius. 9. Ajudar amb els errors : quan es produesca un error haurem d'informar amb un llenguatge familiar a l'usuari, evitant expressions i termes t\u00e8cnics, i oferint una soluci\u00f3. 10. Documentaci\u00f3 i ajuda : conv\u00e9 oferir a l'usuari fonts d'informaci\u00f3 i ajuda que us permeten resoldre dubtes sobre l'aplicaci\u00f3. Important En els projectes de disseny d'interf\u00edcies \u00e9s habitual fer sessions d'avaluaci\u00f3 de les heur\u00edstiques sobre els prototips que es plantegen. A difer\u00e8ncia de les avaluacions de la usabilitat comentades a la teoria de l'apartat, a les sessions d'avaluaci\u00f3 de les heur\u00edstiques no participen usuaris, sin\u00f3 que s\u00f3n professionals de la usabilitat els que avaluen el disseny. En aquest cas pr\u00e0ctic haur\u00e0s de plantejar un exemple de cada heur\u00edstica en aplicacions o productes que conegues (no han de ser necess\u00e0riament tecnol\u00f2gics). Tamb\u00e9 pots plantejar un contraexemple, \u00e9s a dir, un cas en qu\u00e8 no s'estiga respectant l'heur\u00edstica. Pr\u00e0ctica 2 - Disseny d'un prototip Com hem vist al llarg de la unitat, el disseny de la interf\u00edcie d'usuari d'una aplicaci\u00f3 comporta tenir en compte m\u00faltiples aspectes, sempre amb l'usuari com a referent. A m\u00e9s, \u00e9s un proc\u00e9s iteratiu, en qu\u00e8 el disseny inicial (molt allunyat de la soluci\u00f3 final) evolucionar\u00e0 fins a la versi\u00f3 final (sobre la qual es basar\u00e0 la construcci\u00f3 de l'aplicaci\u00f3). Les propostes de disseny que es van elaborant i que s'avaluen amb els usuaris s'anomenen prototips. Segons es va avan\u00e7ant en el proc\u00e9s de disseny, els prototips van guanyant en fidelitat, \u00e9s a dir, es van semblant cada cop m\u00e9s a la soluci\u00f3 final. Segons el grau de fidelitat es pot distingir entre els tipus de prototips seg\u00fcents: Prototip de molt baixa fidelitat (en angl\u00e9s, sketch ): s\u00f3n els primers esbossos que es fan en iniciar el disseny, i representen les idees generals del projecte. Moltes vegades s'elaboren en paper. Prototip de baixa fidelitat (en angl\u00e9s, wireframe ): aquest tipus de prototips se centra en l'estructura i l'organitzaci\u00f3 dels continguts del disseny. No incorpora aspectes visuals com ara colors, fonts o imatges, per centrar-se en la funcionalitat i no en la part est\u00e8tica. Prototip de mitja fidelitat (en angl\u00e9s, mockup ): en aquest prototip s'incorporen aspectes visuals al prototip de baixa fidelitat obtingut, obtenint un prototip molt proper visualment al producte final, per\u00f2 sense funcionalitat. Prototip d'alta fidelitat (en angl\u00e9s, prototype ): es realitza en les darreres etapes del disseny, i ja s'hi incorporen algunes funcionalitats, com ara la navegaci\u00f3 entre les parts de l'aplicaci\u00f3. Important Encara que \u00e9s important fer avaluacions dels prototips amb els usuaris des de les primeres versions, els tests d'usabilitat i les avaluacions de les heur\u00edstiques solen intensificar-se i formalitzar-se amb els prototips d'alta fidelitat. En aquest cas pr\u00e0ctic haur\u00e0s de dissenyar un prototip de baixa fidelitat per a una cadena de restaurants de menjar r\u00e0pid, utilitzant l'eina online diagrams.net. La descripci\u00f3 de la funcionalitat que ens ha donat el nostre client \u00e9s la seg\u00fcent: \u201cVolem una aplicaci\u00f3 perqu\u00e8 els nostres clients puguen fer la comanda de manera aut\u00f2noma utilitzant una pantalla t\u00e0ctil situada a l'entrada del restaurant. El client ha de poder afegir a la seua comanda tots els productes que desitge, i els trobareu organitzats per categories (entrants, plats principals, begudes i postres). Quan finalitze la comanda podr\u00e0 decidir si vol pagar amb targeta de cr\u00e8dit al mateix terminal o en efectiu en recollir-lo al taulell. Tamb\u00e9 podran triar entre prendre la seua comanda al restaurant o endur-se'l a casa\u201d Recorda que un prototip de baixa fidelitat no inclou aspectes est\u00e8tics com ara colors o imatges, i intenta aplicar tot all\u00f2 que hem apr\u00e9s a la unitat a l'hora de plantejar la teua proposta.","title":"Pr\u00e0ctiques"},{"location":"unitats/2-intro-interficies/tasques/2%20-%20Pr%C3%A0ctiques/#practica-1-heuristiques-dusabilitat","text":"L'any 1994, el guru de la usabilitat Jakob Nielsen va proposar 10 heur\u00edstiques per al disseny d'interf\u00edcies d'usuari basant-se en la seua experi\u00e8ncia personal en aquest camp. Tot i el temps transcorregut des del seu plantejament, les heur\u00edstiques de Nielsen segueixen vigents i s\u00f3n utilitzades per la majoria dels professionals del disseny. Heur\u00edstica Una heur\u00edstica es pot definir com un m\u00e8tode o principi basat en l'experi\u00e8ncia, que es pot utilitzar com a ajuda per resoldre un problema m\u00e9s complex. A continuaci\u00f3 detallem les 10 heur\u00edstiques de Nielsen: 1. Visibilitat de l'estat del sistema : sempre hem de mantenir informats els usuaris del que est\u00e0 passant a l'aplicaci\u00f3, tan aviat com siga possible. 2. Relaci\u00f3 entre el sistema i el m\u00f3n real : la interf\u00edcie ha d'utilitzar expressions i conceptes propers a l'usuari i a l'entorn real on es desenvolupa la seua activitat. 3. Donar llibertat i el control a l'usuari : l'usuari ha de tenir el control de qu\u00e8 passa a l'aplicaci\u00f3 en tot moment, fins i tot podent canviar d'opini\u00f3 respecte a una acci\u00f3 anterior. 4. Consist\u00e8ncia i est\u00e0ndards : el nostre disseny ha de ser consistent amb all\u00f2 que l'usuari acostuma a trobar en altres productes, i respectar els est\u00e0ndards establerts per a la plataforma o el tipus d'aplicaci\u00f3. 5. Prevenci\u00f3 d'errors : la interf\u00edcie que plantegem ha d'ajudar l'usuari a no cometre errors, anticipant-nos a les accions i comportaments que els poden ocasionar. 6. Recon\u00e8ixer en comptes de recordar : la nostra aplicaci\u00f3 ha de minimitzar l'esfor\u00e7 de memoritzaci\u00f3 de l'usuari, facilitant l'acc\u00e9s a la informaci\u00f3 que necessite a cada moment. 7. Flexibilitat i efici\u00e8ncia d'\u00fas : hem d'oferir diferents maneres de fer les coses, de manera que els usuaris amb caracter\u00edstiques diferents o diferents nivells d'experi\u00e8ncia puguen utilitzar el nostre disseny de forma eficient. 8. Est\u00e8tica i disseny minimalista : tots els elements visuals que utilitzem a la interf\u00edcie han de tenir un prop\u00f2sit i ajudar els objectius de l'usuari, evitant elements purament decoratius. 9. Ajudar amb els errors : quan es produesca un error haurem d'informar amb un llenguatge familiar a l'usuari, evitant expressions i termes t\u00e8cnics, i oferint una soluci\u00f3. 10. Documentaci\u00f3 i ajuda : conv\u00e9 oferir a l'usuari fonts d'informaci\u00f3 i ajuda que us permeten resoldre dubtes sobre l'aplicaci\u00f3. Important En els projectes de disseny d'interf\u00edcies \u00e9s habitual fer sessions d'avaluaci\u00f3 de les heur\u00edstiques sobre els prototips que es plantegen. A difer\u00e8ncia de les avaluacions de la usabilitat comentades a la teoria de l'apartat, a les sessions d'avaluaci\u00f3 de les heur\u00edstiques no participen usuaris, sin\u00f3 que s\u00f3n professionals de la usabilitat els que avaluen el disseny. En aquest cas pr\u00e0ctic haur\u00e0s de plantejar un exemple de cada heur\u00edstica en aplicacions o productes que conegues (no han de ser necess\u00e0riament tecnol\u00f2gics). Tamb\u00e9 pots plantejar un contraexemple, \u00e9s a dir, un cas en qu\u00e8 no s'estiga respectant l'heur\u00edstica.","title":"Pr\u00e0ctica 1 - Heur\u00edstiques d'usabilitat"},{"location":"unitats/2-intro-interficies/tasques/2%20-%20Pr%C3%A0ctiques/#practica-2-disseny-dun-prototip","text":"Com hem vist al llarg de la unitat, el disseny de la interf\u00edcie d'usuari d'una aplicaci\u00f3 comporta tenir en compte m\u00faltiples aspectes, sempre amb l'usuari com a referent. A m\u00e9s, \u00e9s un proc\u00e9s iteratiu, en qu\u00e8 el disseny inicial (molt allunyat de la soluci\u00f3 final) evolucionar\u00e0 fins a la versi\u00f3 final (sobre la qual es basar\u00e0 la construcci\u00f3 de l'aplicaci\u00f3). Les propostes de disseny que es van elaborant i que s'avaluen amb els usuaris s'anomenen prototips. Segons es va avan\u00e7ant en el proc\u00e9s de disseny, els prototips van guanyant en fidelitat, \u00e9s a dir, es van semblant cada cop m\u00e9s a la soluci\u00f3 final. Segons el grau de fidelitat es pot distingir entre els tipus de prototips seg\u00fcents: Prototip de molt baixa fidelitat (en angl\u00e9s, sketch ): s\u00f3n els primers esbossos que es fan en iniciar el disseny, i representen les idees generals del projecte. Moltes vegades s'elaboren en paper. Prototip de baixa fidelitat (en angl\u00e9s, wireframe ): aquest tipus de prototips se centra en l'estructura i l'organitzaci\u00f3 dels continguts del disseny. No incorpora aspectes visuals com ara colors, fonts o imatges, per centrar-se en la funcionalitat i no en la part est\u00e8tica. Prototip de mitja fidelitat (en angl\u00e9s, mockup ): en aquest prototip s'incorporen aspectes visuals al prototip de baixa fidelitat obtingut, obtenint un prototip molt proper visualment al producte final, per\u00f2 sense funcionalitat. Prototip d'alta fidelitat (en angl\u00e9s, prototype ): es realitza en les darreres etapes del disseny, i ja s'hi incorporen algunes funcionalitats, com ara la navegaci\u00f3 entre les parts de l'aplicaci\u00f3. Important Encara que \u00e9s important fer avaluacions dels prototips amb els usuaris des de les primeres versions, els tests d'usabilitat i les avaluacions de les heur\u00edstiques solen intensificar-se i formalitzar-se amb els prototips d'alta fidelitat. En aquest cas pr\u00e0ctic haur\u00e0s de dissenyar un prototip de baixa fidelitat per a una cadena de restaurants de menjar r\u00e0pid, utilitzant l'eina online diagrams.net. La descripci\u00f3 de la funcionalitat que ens ha donat el nostre client \u00e9s la seg\u00fcent: \u201cVolem una aplicaci\u00f3 perqu\u00e8 els nostres clients puguen fer la comanda de manera aut\u00f2noma utilitzant una pantalla t\u00e0ctil situada a l'entrada del restaurant. El client ha de poder afegir a la seua comanda tots els productes que desitge, i els trobareu organitzats per categories (entrants, plats principals, begudes i postres). Quan finalitze la comanda podr\u00e0 decidir si vol pagar amb targeta de cr\u00e8dit al mateix terminal o en efectiu en recollir-lo al taulell. Tamb\u00e9 podran triar entre prendre la seua comanda al restaurant o endur-se'l a casa\u201d Recorda que un prototip de baixa fidelitat no inclou aspectes est\u00e8tics com ara colors o imatges, i intenta aplicar tot all\u00f2 que hem apr\u00e9s a la unitat a l'hora de plantejar la teua proposta.","title":"Pr\u00e0ctica 2 - Disseny d'un prototip"},{"location":"unitats/2-intro-interficies/teoria/1%20-%20Introduccio/","text":"1. Interf\u00edcies d'usuari La interf\u00edcie d'usuari d'un sistema est\u00e0 definida per la manera com els usuaris interactuen amb els components del sistema. Quan parlem de sistemes inform\u00e0tics, podem distingir dos tipus d'interf\u00edcies d'usuari: Interf\u00edcies de maquinari : els components f\u00edsics que permeten a l'usuari introduir ordres i dades al sistema, i obtenir els resultats (com ara el teclat, el ratol\u00ed o el monitor). Interf\u00edcies programari : les aplicacions utilitzades pels usuaris per dur a terme una tasca concreta. HCI La Interacci\u00f3 Persona-Ordinador (en angl\u00e9s Human-Computer Interaction o HCI ) \u00e9s la disciplina cient\u00edfica que s'encarrega de l'estudi de les interf\u00edcies entre els humans i els ordinadors en l'\u00fas de sistemes interactius. Al m\u00f2dul de Desenvolupament d'Interf\u00edcies abordarem diferents q\u00fcestions relacionades amb la construcci\u00f3 d'interf\u00edcies de programari, aix\u00ed com alguns aspectes relacionats amb la implantaci\u00f3 de les aplicacions. 1.1 Disseny centrat en l'usuari El disseny d'interf\u00edcies d'usuari actualment es regeix per l'anomenat disseny centrat en l'usuari, una filosofia de disseny on el focus se centra en les caracter\u00edstiques i necessitats de les persones a qui va dirigit un producte o servei. Aquest corrent sorgeix en contraposici\u00f3 a altres com el disseny centrat en el producte, en qu\u00e8 tot el proc\u00e9s gira al voltant del producte que es desenvolupa, i s\u00f3n els usuaris els que s'hi han d'adaptar. Disseny centrat en l'usuari L'enginyer americ\u00e0 Donald Norman va popularitzar el concepte de disseny centrat en l'usuari als anys 80 i 90. L'any 1999 es va crear la norma ISO 13407, que estandarditza el proc\u00e9s de disseny centrat en l'usuari per a sistemes interactius. L'any 2010, es va revisar i actualitzar com a ISO 9241-210. El proc\u00e9s que s'associa al disseny centrat en l'usuari es resumeix en l'esquema seg\u00fcent: An\u00e0lisi del context d'\u00fas : s'investiguen totes les caracter\u00edstiques del context d\u00fas del producte o servei, que inclou tant la tasca a realitzar com les particularitats dels usuaris i de l'entorn d'\u00fas. Detallar els requisits : tenint en compte l'an\u00e0lisi realitzat al pas anterior, s'especifiquen els requisits que el producte o servei ha de complir. Dissenyar solucions : a continuaci\u00f3, es comen\u00e7ar\u00e0 amb el disseny de possibles solucions (prototips) que complisquen els requisits detallats. S'evolucionar\u00e0 des d'un disseny inicial aproximat fins a un disseny complet i detallat. Avaluar amb els usuaris : l'avaluaci\u00f3 de les solucions pels usuaris \u00e9s un punt de vital import\u00e0ncia en el disseny centrat en l'usuari i s'ha de fer des de les primeres versions de la soluci\u00f3. Com a resultat de l'avaluaci\u00f3, \u00e9s probable que s'haja de tornar a una etapa anterior del proc\u00e9s. Important Tot i que l'aplicaci\u00f3 del disseny centrat en l'usuari consumeix recursos i comporta un esfor\u00e7 extra en el desenvolupament d'un projecte, contribueix a assegurar l'\u00e8xit final i, per tant, s'ha de prendre sempre com a guia. 1.2 Evoluci\u00f3 de les interf\u00edcies d'usuari Tenint en compte l'evoluci\u00f3 en el temps de les interf\u00edcies programari d'usuari, podem distingir tres grans tipus d'interf\u00edcies: CLI, GUI i NUI. A. Interf\u00edcies tipus CLI Les interf\u00edcies tipus CLI (de l'angl\u00e9s, Command Line Interface ) o interf\u00edcies de l\u00ednia d'ordres s\u00f3n les primeres que van sorgir, amb l'objectiu que l'usuari d'un ordinador pogu\u00e9s interactuar amb el sistema operatiu. Aquest tipus d'interf\u00edcies es basa en la introducci\u00f3 d'ordres mitjan\u00e7ant l\u00ednies de text, i implica que l'usuari conega les regles sint\u00e0ctiques per construir aquestes ordres. Actualment es continuen utilitzant interf\u00edcies tipus CLI en diferents \u00e0mbits. I no nom\u00e9s per interactuar amb els sistemes operatius, sin\u00f3 que multitud d'entorns i aplicacions ofereixen la possibilitat a l'usuari d'interactuar mitjan\u00e7ant ordres de text. L'efici\u00e8ncia que s'aconsegueix amb aquest tipus d'interf\u00edcies, a m\u00e9s de les possibilitats d'automatitzaci\u00f3, s\u00f3n algunes de les raons perqu\u00e8 seguisquen tenint vig\u00e8ncia. git Un exemple clar d\u00fas actual d'interf\u00edcies de tipus CLI \u00e9s el gestor de versions git, utilitzat en multitud de projectes de desenvolupament de programari. Tot i que hi ha diferents interf\u00edcies gr\u00e0fiques per a git, el m\u00e9s habitual \u00e9s utilitzar-lo per mitj\u00e0 d'ordres. Cloud La majoria de plataformes de n\u00favol p\u00fablic (com Amazon Web Services, Microsoft Azure o Google Cloud ) ofereixen una interf\u00edcie de tipus CLI per crear i mantenir la infraestructura de serveis al n\u00favol. Aquesta possibilitat permet automatitzar tasques relacionades amb el n\u00favol dins dels processos de desplegament de les aplicacions. B. Interf\u00edcies tipus GUI Les interf\u00edcies gr\u00e0fiques d'usuari (de l'angl\u00e9s, Graphical User Interface ) s\u00f3n aquelles que utilitzen imatges i objectes gr\u00e0fics per representar la informaci\u00f3 i les accions que els usuaris poden realitzar. Solen utilitzar met\u00e0fores del m\u00f3n real (com les finestres o els botons) i, a difer\u00e8ncia de les interf\u00edcies CLI, donen llibertat d'exploraci\u00f3 a l'usuari, que no necessita con\u00e9ixer una estricta sintaxi. Les interf\u00edcies tipus GUI es van popularitzar durant els anys 80 gr\u00e0cies a la seua introducci\u00f3 als sistemes operatius d'Apple i Microsoft, encara que el seu origen real es remunta a l'any 1973. Aquest any es va presentar l'ordinador Xerox Alto , el primer a utilitzar la met\u00e0fora de l'escriptori i un dispositiu apuntador (el ratol\u00ed). GUIs Actualment, les interf\u00edcies de tipus GUI s\u00f3n les m\u00e9s comunes a les aplicacions destinades a l'\u00e0mbit empresarial, i per aix\u00f2 el m\u00f2dul de Desenvolupament d'Interf\u00edcies se centra en la construcci\u00f3 d'aquest tipus d'interf\u00edcies. C. Interf\u00edcies tipus NUI Les interf\u00edcies NUI o interf\u00edcies naturals d'usuari (de l'angl\u00e8s, Natural User Interface ) es caracteritzen per oferir a l'usuari un estil d'interacci\u00f3 molt m\u00e9s directe i intu\u00eftiu que amb els tipus d'interf\u00edcies anteriors. Solen mancar de dispositiu f\u00edsic d'entrada (com teclat o ratol\u00ed), i en el seu lloc fan \u00fas d'habilitats naturals com el moviment, els gestos o la veu. Les interf\u00edcies t\u00e0ctils dels dispositius m\u00f2bils (com els tel\u00e8fons intel\u00b7ligents o les tauletes) s\u00f3n un clar exemple d'interf\u00edcies NUI, ja que permeten a l'usuari realitzar accions per mitj\u00e0 de gestos naturals (per exemple, navegar entre imatges fent-les lliscar a la pantalla del dispositiu). Tamb\u00e9 els assistents de veu (com Google Assistant o Amazon Alexa) s\u00f3n exemples d'interf\u00edcies naturals, en aquest cas controlades per mitj\u00e0 de la veu.","title":"1 - Introducci\u00f3 a les interf\u00edcies d'usuari"},{"location":"unitats/2-intro-interficies/teoria/1%20-%20Introduccio/#1-interficies-dusuari","text":"La interf\u00edcie d'usuari d'un sistema est\u00e0 definida per la manera com els usuaris interactuen amb els components del sistema. Quan parlem de sistemes inform\u00e0tics, podem distingir dos tipus d'interf\u00edcies d'usuari: Interf\u00edcies de maquinari : els components f\u00edsics que permeten a l'usuari introduir ordres i dades al sistema, i obtenir els resultats (com ara el teclat, el ratol\u00ed o el monitor). Interf\u00edcies programari : les aplicacions utilitzades pels usuaris per dur a terme una tasca concreta. HCI La Interacci\u00f3 Persona-Ordinador (en angl\u00e9s Human-Computer Interaction o HCI ) \u00e9s la disciplina cient\u00edfica que s'encarrega de l'estudi de les interf\u00edcies entre els humans i els ordinadors en l'\u00fas de sistemes interactius. Al m\u00f2dul de Desenvolupament d'Interf\u00edcies abordarem diferents q\u00fcestions relacionades amb la construcci\u00f3 d'interf\u00edcies de programari, aix\u00ed com alguns aspectes relacionats amb la implantaci\u00f3 de les aplicacions.","title":"1. Interf\u00edcies d'usuari"},{"location":"unitats/2-intro-interficies/teoria/1%20-%20Introduccio/#11-disseny-centrat-en-lusuari","text":"El disseny d'interf\u00edcies d'usuari actualment es regeix per l'anomenat disseny centrat en l'usuari, una filosofia de disseny on el focus se centra en les caracter\u00edstiques i necessitats de les persones a qui va dirigit un producte o servei. Aquest corrent sorgeix en contraposici\u00f3 a altres com el disseny centrat en el producte, en qu\u00e8 tot el proc\u00e9s gira al voltant del producte que es desenvolupa, i s\u00f3n els usuaris els que s'hi han d'adaptar. Disseny centrat en l'usuari L'enginyer americ\u00e0 Donald Norman va popularitzar el concepte de disseny centrat en l'usuari als anys 80 i 90. L'any 1999 es va crear la norma ISO 13407, que estandarditza el proc\u00e9s de disseny centrat en l'usuari per a sistemes interactius. L'any 2010, es va revisar i actualitzar com a ISO 9241-210. El proc\u00e9s que s'associa al disseny centrat en l'usuari es resumeix en l'esquema seg\u00fcent: An\u00e0lisi del context d'\u00fas : s'investiguen totes les caracter\u00edstiques del context d\u00fas del producte o servei, que inclou tant la tasca a realitzar com les particularitats dels usuaris i de l'entorn d'\u00fas. Detallar els requisits : tenint en compte l'an\u00e0lisi realitzat al pas anterior, s'especifiquen els requisits que el producte o servei ha de complir. Dissenyar solucions : a continuaci\u00f3, es comen\u00e7ar\u00e0 amb el disseny de possibles solucions (prototips) que complisquen els requisits detallats. S'evolucionar\u00e0 des d'un disseny inicial aproximat fins a un disseny complet i detallat. Avaluar amb els usuaris : l'avaluaci\u00f3 de les solucions pels usuaris \u00e9s un punt de vital import\u00e0ncia en el disseny centrat en l'usuari i s'ha de fer des de les primeres versions de la soluci\u00f3. Com a resultat de l'avaluaci\u00f3, \u00e9s probable que s'haja de tornar a una etapa anterior del proc\u00e9s. Important Tot i que l'aplicaci\u00f3 del disseny centrat en l'usuari consumeix recursos i comporta un esfor\u00e7 extra en el desenvolupament d'un projecte, contribueix a assegurar l'\u00e8xit final i, per tant, s'ha de prendre sempre com a guia.","title":"1.1 Disseny centrat en l'usuari"},{"location":"unitats/2-intro-interficies/teoria/1%20-%20Introduccio/#12-evolucio-de-les-interficies-dusuari","text":"Tenint en compte l'evoluci\u00f3 en el temps de les interf\u00edcies programari d'usuari, podem distingir tres grans tipus d'interf\u00edcies: CLI, GUI i NUI.","title":"1.2 Evoluci\u00f3 de les interf\u00edcies d'usuari"},{"location":"unitats/2-intro-interficies/teoria/1%20-%20Introduccio/#a-interficies-tipus-cli","text":"Les interf\u00edcies tipus CLI (de l'angl\u00e9s, Command Line Interface ) o interf\u00edcies de l\u00ednia d'ordres s\u00f3n les primeres que van sorgir, amb l'objectiu que l'usuari d'un ordinador pogu\u00e9s interactuar amb el sistema operatiu. Aquest tipus d'interf\u00edcies es basa en la introducci\u00f3 d'ordres mitjan\u00e7ant l\u00ednies de text, i implica que l'usuari conega les regles sint\u00e0ctiques per construir aquestes ordres. Actualment es continuen utilitzant interf\u00edcies tipus CLI en diferents \u00e0mbits. I no nom\u00e9s per interactuar amb els sistemes operatius, sin\u00f3 que multitud d'entorns i aplicacions ofereixen la possibilitat a l'usuari d'interactuar mitjan\u00e7ant ordres de text. L'efici\u00e8ncia que s'aconsegueix amb aquest tipus d'interf\u00edcies, a m\u00e9s de les possibilitats d'automatitzaci\u00f3, s\u00f3n algunes de les raons perqu\u00e8 seguisquen tenint vig\u00e8ncia. git Un exemple clar d\u00fas actual d'interf\u00edcies de tipus CLI \u00e9s el gestor de versions git, utilitzat en multitud de projectes de desenvolupament de programari. Tot i que hi ha diferents interf\u00edcies gr\u00e0fiques per a git, el m\u00e9s habitual \u00e9s utilitzar-lo per mitj\u00e0 d'ordres. Cloud La majoria de plataformes de n\u00favol p\u00fablic (com Amazon Web Services, Microsoft Azure o Google Cloud ) ofereixen una interf\u00edcie de tipus CLI per crear i mantenir la infraestructura de serveis al n\u00favol. Aquesta possibilitat permet automatitzar tasques relacionades amb el n\u00favol dins dels processos de desplegament de les aplicacions.","title":"A. Interf\u00edcies tipus CLI"},{"location":"unitats/2-intro-interficies/teoria/1%20-%20Introduccio/#b-interficies-tipus-gui","text":"Les interf\u00edcies gr\u00e0fiques d'usuari (de l'angl\u00e9s, Graphical User Interface ) s\u00f3n aquelles que utilitzen imatges i objectes gr\u00e0fics per representar la informaci\u00f3 i les accions que els usuaris poden realitzar. Solen utilitzar met\u00e0fores del m\u00f3n real (com les finestres o els botons) i, a difer\u00e8ncia de les interf\u00edcies CLI, donen llibertat d'exploraci\u00f3 a l'usuari, que no necessita con\u00e9ixer una estricta sintaxi. Les interf\u00edcies tipus GUI es van popularitzar durant els anys 80 gr\u00e0cies a la seua introducci\u00f3 als sistemes operatius d'Apple i Microsoft, encara que el seu origen real es remunta a l'any 1973. Aquest any es va presentar l'ordinador Xerox Alto , el primer a utilitzar la met\u00e0fora de l'escriptori i un dispositiu apuntador (el ratol\u00ed). GUIs Actualment, les interf\u00edcies de tipus GUI s\u00f3n les m\u00e9s comunes a les aplicacions destinades a l'\u00e0mbit empresarial, i per aix\u00f2 el m\u00f2dul de Desenvolupament d'Interf\u00edcies se centra en la construcci\u00f3 d'aquest tipus d'interf\u00edcies.","title":"B. Interf\u00edcies tipus GUI"},{"location":"unitats/2-intro-interficies/teoria/1%20-%20Introduccio/#c-interficies-tipus-nui","text":"Les interf\u00edcies NUI o interf\u00edcies naturals d'usuari (de l'angl\u00e8s, Natural User Interface ) es caracteritzen per oferir a l'usuari un estil d'interacci\u00f3 molt m\u00e9s directe i intu\u00eftiu que amb els tipus d'interf\u00edcies anteriors. Solen mancar de dispositiu f\u00edsic d'entrada (com teclat o ratol\u00ed), i en el seu lloc fan \u00fas d'habilitats naturals com el moviment, els gestos o la veu. Les interf\u00edcies t\u00e0ctils dels dispositius m\u00f2bils (com els tel\u00e8fons intel\u00b7ligents o les tauletes) s\u00f3n un clar exemple d'interf\u00edcies NUI, ja que permeten a l'usuari realitzar accions per mitj\u00e0 de gestos naturals (per exemple, navegar entre imatges fent-les lliscar a la pantalla del dispositiu). Tamb\u00e9 els assistents de veu (com Google Assistant o Amazon Alexa) s\u00f3n exemples d'interf\u00edcies naturals, en aquest cas controlades per mitj\u00e0 de la veu.","title":"C. Interf\u00edcies tipus NUI"},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/","text":"2. Usabilitat No \u00e9s senzill trobar una definici\u00f3 exacta d'usabilitat, per\u00f2 en termes generals es podria dir que la usabilitat d'un sistema \u00e9s la facilitat amb qu\u00e8 els usuaris poden fer servir aquest sistema per a dur a terme una tasca concreta. Per\u00f2 no hem de pensar que la usabilitat \u00e9s simplement un sin\u00f2nim de facilitat, ja que com veurem m\u00e9s endavant, hi ha molts altres factors que influeixen en la usabilitat d'una aplicaci\u00f3. El terme usabilitat \u00e9s un neologisme, adaptat del vocable angl\u00e9s usability . Encara que la Reial Acad\u00e8mia Espanyola (RAE) no ho inclou al seu diccionari, el seu \u00fas est\u00e0 acceptat i \u00e9s molt habitual en l'\u00e0mbit tecnol\u00f2gic. La usabilitat \u00e9s un dels conceptes clau dins del proc\u00e9s de disseny centrat en l'usuari que vam veure a l'apartat anterior, i ha d'estar present tant en el disseny de les possibles solucions com en la seua avaluaci\u00f3 posterior. S\u00f3n diverses les normes internacionals que inclouen recomanacions relacionades amb la usabilitat, com ara: ISO 9241-11 (Usabilitat: definicions i conceptes). ISO/IEC 25010 (Qualitat en programari i sistemes). ISO/TR 16982 (M\u00e8todes d'usabilitat com a base al disseny centrat en l'usuari). 2.1 Components de la usabilitat La usabilitat d'un producte o sistema es considera habitualment formada per cinc components: A. Aprenentatge. Un dels components principals de la usabilitat \u00e9s la facilitat d'aprenentatge, determinada per l'esfor\u00e7 amb qu\u00e8 un nou usuari de la nostra aplicaci\u00f3 pot arribar a completar una tasca espec\u00edfica. Tamb\u00e9 \u00e9s important que en els usos successius de l'aplicaci\u00f3 l'usuari trobe l'aplicaci\u00f3 cada vegada m\u00e9s f\u00e0cil d'utilitzar. Per facilitar l'aprenentatge, un dels aspectes clau \u00e9s la consist\u00e8ncia amb els est\u00e0ndards establerts a la resta d'aplicacions. Per exemple, la majoria de les aplicacions associen la drecera de teclat Ctrl+C amb l'acci\u00f3 de copiar. Si ho fem aix\u00ed tamb\u00e9 al nostre producte, estarem facilitant l'aprenentatge. B. Efici\u00e8ncia. Un altre requisit per a la bona usabilitat de l'aplicaci\u00f3 \u00e9s l'efici\u00e8ncia. L'usuari, un cop ha apr\u00e9s el nostre disseny, ha de ser capa\u00e7 d'executar les tasques per a les quals s'ha creat el producte tan r\u00e0pid com siga possible i sense impediments, seguint el proc\u00e9s m\u00e9s senzill. Moltes aplicacions ofereixen als usuaris experimentats formes alternatives de dur a terme les tasques que ajuden a millorar l'efici\u00e8ncia, com ara la definici\u00f3 de dreceres de teclat personalitzades o la creaci\u00f3 de macros per encadenar diverses accions. C. Record. Tamb\u00e9 \u00e9s important que si un usuari est\u00e0 un temps sense utilitzar el nostre disseny, l'esfor\u00e7 de recordar quan el torna a fer servir el producte siga el m\u00ednim possible. Hem d'evitar que l'usuari haja de memoritzar la manera com es fan les tasques. Un recurs que s'utilitza en algunes aplicacions per evitar memoritzar l'usuari s\u00f3n els assistents, que van guiant pas per pas per fer una tasca llarga o especialment complexa. D. Errors. Una part fonamental de la usabilitat \u00e9s la relacionada amb els errors. L'aplicaci\u00f3 ha de ser capa\u00e7 de tolerar un ampli ventall d'accions realitzades per l'usuari sense generar un error. En cas que l'error es produ\u00efsca, cal informar adequadament l'usuari del tipus d'error i la gravetat, i proporcionar informaci\u00f3 per poder corregir l'error. Per a tal finalitat, ens pot ajudar molt un tractament d'excepcions adequat. Hem de prestar especial atenci\u00f3 al llenguatge utilitzat en els missatges d'error que es mostren a l'usuari, ja que la forma d'expressar la situaci\u00f3 produ\u00efda pot tindre una influ\u00e8ncia negativa. Cal evitar el llenguatge acusatori i intimidador, aix\u00ed com la descripci\u00f3 excessivament t\u00e8cnica de l'error. E. Satisfacci\u00f3. El darrer component de la usabilitat \u00e9s la satisfacci\u00f3 de l'usuari en utilitzar el nostre producte. El disseny ha d'aconseguir que l'experi\u00e8ncia de l'usuari amb la nostra aplicaci\u00f3 siga agradable i la seua sensaci\u00f3 subjectiva despr\u00e9s de l'\u00fas siga positiva. La satisfacci\u00f3 de l'usuari est\u00e0 en gran manera influenciada per la paren\u00e7a visual de la interf\u00edcie, que hauria de ser est\u00e8ticament agradable per\u00f2 minimalista. En aquest sentit \u00e9s important seguir les pautes de disseny que veurem a l'\u00faltim apartat de la unitat. 2.2 Avaluaci\u00f3 de la usabilitat Com vam veure a l'apartat anterior, una de les fases del proc\u00e9s de disseny centrat en l'usuari \u00e9s l'avaluaci\u00f3, i la usabilitat \u00e9s un dels factors clau que cal avaluar. Des dels primers prototips del nostre producte hem de validar el disseny amb els nostres usuaris, cosa que ens aportar\u00e0 informaci\u00f3 molt valuosa per millorar i evolucionar cap a la soluci\u00f3 final. Podem destacar els tres objectius seg\u00fcents de l'avaluaci\u00f3 de la usabilitat: Identificar problemes en el disseny del producte o servei. Descobrir noves oportunitats de millora del disseny que no ens hav\u00edem plantejat. Aprendre sobre el comportament i les prefer\u00e8ncies dels nostres usuaris. A. Qu\u00e8 hem d'avaluar? La primera pregunta que hem de respondre a l'hora de plantejar l'avaluaci\u00f3 de la usabilitat d'un disseny \u00e9s qu\u00e8 avaluarem. Les sessions d'avaluaci\u00f3 de la usabilitat consisteixen a plantejar a un grup d'usuaris la realitzaci\u00f3 d'una s\u00e8rie de tasques realistes que podrien fer a la feina di\u00e0ria amb l'aplicaci\u00f3. Les tasques que es plantegen poden ser molt espec\u00edfiques o amb un resultat obert, depenent dels objectius de la prova. Per\u00f2 sempre haurem de ser molt curosos amb la manera d'especificar la tasca, per evitar malentesos i confusions a l'usuari. Tamb\u00e9 hem d'evitar dirigir l'usuari excessivament, i permetre que utilitze lliurement el disseny. Important A l'hora d'escollir les tasques que els usuaris hauran de realitzar a la sessi\u00f3 d'avaluaci\u00f3 de la usabilitat, hem de prioritzar les m\u00e9s rellevants per a la nostra aplicaci\u00f3. Es recomana que no siguen m\u00e9s de cinc tasques per participant, i que la durada total de la sessi\u00f3 no supere una hora. A m\u00e9s de les tasques que es plantejaran a l'usuari, hem de decidir qu\u00e8 ens interessa mesurar durant la prova. En termes generals, se sol distingir entre dos tipus de m\u00e8triques: Qualitatives : aquest tipus de m\u00e8triques s\u00f3n especialment importants a les primeres fases del disseny, i consisteixen en valoracions subjectives que realitza l'usuari durant la prova o en observacions que podem realitzar del seu comportament . Exemple Exemples de m\u00e8triques qualitatives s\u00f3n el nivell d'estr\u00e8s de l'usuari (determinat pels seus moviments, gestos o expressions) o la satisfacci\u00f3 de l'usuari despr\u00e9s de la prova (que podeu comentar directament o podem recollir amb un q\u00fcestionari). Quantitatives : aquestes m\u00e8triques es basen en par\u00e0metres quantificables, i s'utilitzen m\u00e9s quan el disseny est\u00e0 quasi acabat o fins i tot quan el producte ja est\u00e0 en funcionament. Exemple Algunes m\u00e8triques quantitatives podrien ser el temps que li costa a un usuari dur a terme una tasca, el nombre de tasques que completa en una sessi\u00f3 o la quantitat de vegades que ha hagut d'anar a l'ajuda. B. Qui participa en l'avaluaci\u00f3? A les sessions d'avaluaci\u00f3 de la usabilitat podem distingir els rols seg\u00fcents: Moderador : \u00e9s l'encarregat de guiar els usuaris participants durant la sessi\u00f3 d'avaluaci\u00f3. Presentar\u00e0 les tasques a realitzar, resoldr\u00e0 els dubtes dels usuaris i obtindr\u00e0 informaci\u00f3 mitjan\u00e7ant l'observaci\u00f3 o preguntant als usuaris. \u00c9s recomanable que siga alg\u00fa extern a l'equip de desenvolupament del producte, i fins i tot de vegades es recorre a professionals especialitzats en aquest tipus d'avaluacions. Important El moderador ha de procurar mantenir-se neutral i no influir en els participants. Ha d'intervenir tan poc com siga possible, i quan ho fa\u00e7a ha d'utilitzar un estil d'interacci\u00f3 obert, que permeta a l'usuari expressar-se amb llibertat. Per exemple, en lloc de preguntar si us sembla b\u00e9 una funcionalitat \u00e9s millor preguntar per la vostra opini\u00f3 sobre aquesta funcionalitat. Usuaris : els participants a la sessi\u00f3 han de ser usuaris potencials del producte o servei que estem dissenyant. Es recomana que a cada sessi\u00f3 d'avaluaci\u00f3 participen al voltant de cinc usuaris, ja que a partir d'aquest nombre els problemes d'usabilitat detectats se solen repetir. C. Com es fa l'avaluaci\u00f3? Hi ha diferents opcions a l'hora de plantejar l'avaluaci\u00f3 de la usabilitat: Presencial : el moderador i els usuaris estan f\u00edsicament al mateix lloc. Tot i que el moderador sol prendre notes durant la sessi\u00f3, tamb\u00e9 \u00e9s habitual gravar la sessi\u00f3 en v\u00eddeo per poder fer una an\u00e0lisi m\u00e9s detallada amb posterioritat. Remota : els participants a la sessi\u00f3 estan en llocs diferents. Solen ser menys costoses que les sessions presencials, i en estar els usuaris en el seu propi entorn de treball solen sentir-se m\u00e9s segurs davant de les tasques a realitzar. Podem distingir dos tipus d'avaluacions remotes: Moderades : encara que el moderador i els usuaris estan en ubicacions f\u00edsiques diferents, interactuen de manera semblant a les sessions presencials, utilitzant algun programari de comunicaci\u00f3 que permeta compartir la pantalla de l'usuari. No moderades : es fa servir algun programari especialitzat per a avaluacions d'usabilitat, on es configuren les tasques a realitzar. Un cop acabada la sessi\u00f3, el moderador rep el resultat de l'avaluaci\u00f3 (normalment, l'enregistrament de la sessi\u00f3, un test de valoraci\u00f3 de l'usuari i les m\u00e8triques quantitatives que s'hagen definit). 2.3 Experi\u00e8ncia dusuari (UX) El concepte d'experi\u00e8ncia d'usuari o UX (de l'angl\u00e9s, User Experience ) fa refer\u00e8ncia a l'experi\u00e8ncia completa de l'usuari en relaci\u00f3 amb un producte o servei. Una bona experi\u00e8ncia d'usuari donar\u00e0 com a resultat una percepci\u00f3 subjectiva positiva de l'usuari cap a la nostra aplicaci\u00f3. Important No s'han de confondre els conceptes d'experi\u00e8ncia d'usuari i usabilitat, encara que hi ha relaci\u00f3 entre ells. La usabilitat \u00e9s un dels factors que influeixen en una bona experi\u00e8ncia d'usuari, per\u00f2 tamb\u00e9 seran determinants factors com ara la utilitat (que el producte permeta a l'usuari resoldre un problema concret), la credibilitat (que l'usuari confie en el nostre producte) o l'accessibilitat (que el disseny tinga en compte la varietat d'usuaris i dispositius). Donald Norman (del que ja parl\u00e0rem a l'apartat anterior) juntament amb Jakob Nielsen (un dels principals referents en el m\u00f3n de la usabilitat) van proposar els nivells seg\u00fcents en parlar d'experi\u00e8ncia d'usuari. Com veiem, aconseguir una bona experi\u00e8ncia d'usuari comen\u00e7a creant un producte o servei que siga \u00fatil per a l'usuari i li permeta resoldre un problema concret. El seg\u00fcent pas seria aconseguir que el disseny siga usable, aplicant tot el que hem apr\u00e9s als apartats anteriors. Una vegada tenim un disseny \u00fatil i usable, l'objectiu seria aconseguir un producte atractiu per als usuaris, que han de desitjar utilitzar-lo. L'\u00faltim nivell \u00e9s on s'assoleix una experi\u00e8ncia global positiva, aconseguint que la seua opini\u00f3 subjectiva cap al nostre producte siga bona.","title":"2 - Usabilitat"},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#2-usabilitat","text":"No \u00e9s senzill trobar una definici\u00f3 exacta d'usabilitat, per\u00f2 en termes generals es podria dir que la usabilitat d'un sistema \u00e9s la facilitat amb qu\u00e8 els usuaris poden fer servir aquest sistema per a dur a terme una tasca concreta. Per\u00f2 no hem de pensar que la usabilitat \u00e9s simplement un sin\u00f2nim de facilitat, ja que com veurem m\u00e9s endavant, hi ha molts altres factors que influeixen en la usabilitat d'una aplicaci\u00f3. El terme usabilitat \u00e9s un neologisme, adaptat del vocable angl\u00e9s usability . Encara que la Reial Acad\u00e8mia Espanyola (RAE) no ho inclou al seu diccionari, el seu \u00fas est\u00e0 acceptat i \u00e9s molt habitual en l'\u00e0mbit tecnol\u00f2gic. La usabilitat \u00e9s un dels conceptes clau dins del proc\u00e9s de disseny centrat en l'usuari que vam veure a l'apartat anterior, i ha d'estar present tant en el disseny de les possibles solucions com en la seua avaluaci\u00f3 posterior. S\u00f3n diverses les normes internacionals que inclouen recomanacions relacionades amb la usabilitat, com ara: ISO 9241-11 (Usabilitat: definicions i conceptes). ISO/IEC 25010 (Qualitat en programari i sistemes). ISO/TR 16982 (M\u00e8todes d'usabilitat com a base al disseny centrat en l'usuari).","title":"2. Usabilitat"},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#21-components-de-la-usabilitat","text":"La usabilitat d'un producte o sistema es considera habitualment formada per cinc components:","title":"2.1 Components de la usabilitat"},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#a-aprenentatge","text":"Un dels components principals de la usabilitat \u00e9s la facilitat d'aprenentatge, determinada per l'esfor\u00e7 amb qu\u00e8 un nou usuari de la nostra aplicaci\u00f3 pot arribar a completar una tasca espec\u00edfica. Tamb\u00e9 \u00e9s important que en els usos successius de l'aplicaci\u00f3 l'usuari trobe l'aplicaci\u00f3 cada vegada m\u00e9s f\u00e0cil d'utilitzar. Per facilitar l'aprenentatge, un dels aspectes clau \u00e9s la consist\u00e8ncia amb els est\u00e0ndards establerts a la resta d'aplicacions. Per exemple, la majoria de les aplicacions associen la drecera de teclat Ctrl+C amb l'acci\u00f3 de copiar. Si ho fem aix\u00ed tamb\u00e9 al nostre producte, estarem facilitant l'aprenentatge.","title":"A. Aprenentatge."},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#b-eficiencia","text":"Un altre requisit per a la bona usabilitat de l'aplicaci\u00f3 \u00e9s l'efici\u00e8ncia. L'usuari, un cop ha apr\u00e9s el nostre disseny, ha de ser capa\u00e7 d'executar les tasques per a les quals s'ha creat el producte tan r\u00e0pid com siga possible i sense impediments, seguint el proc\u00e9s m\u00e9s senzill. Moltes aplicacions ofereixen als usuaris experimentats formes alternatives de dur a terme les tasques que ajuden a millorar l'efici\u00e8ncia, com ara la definici\u00f3 de dreceres de teclat personalitzades o la creaci\u00f3 de macros per encadenar diverses accions.","title":"B. Efici\u00e8ncia."},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#c-record","text":"Tamb\u00e9 \u00e9s important que si un usuari est\u00e0 un temps sense utilitzar el nostre disseny, l'esfor\u00e7 de recordar quan el torna a fer servir el producte siga el m\u00ednim possible. Hem d'evitar que l'usuari haja de memoritzar la manera com es fan les tasques. Un recurs que s'utilitza en algunes aplicacions per evitar memoritzar l'usuari s\u00f3n els assistents, que van guiant pas per pas per fer una tasca llarga o especialment complexa.","title":"C. Record."},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#d-errors","text":"Una part fonamental de la usabilitat \u00e9s la relacionada amb els errors. L'aplicaci\u00f3 ha de ser capa\u00e7 de tolerar un ampli ventall d'accions realitzades per l'usuari sense generar un error. En cas que l'error es produ\u00efsca, cal informar adequadament l'usuari del tipus d'error i la gravetat, i proporcionar informaci\u00f3 per poder corregir l'error. Per a tal finalitat, ens pot ajudar molt un tractament d'excepcions adequat. Hem de prestar especial atenci\u00f3 al llenguatge utilitzat en els missatges d'error que es mostren a l'usuari, ja que la forma d'expressar la situaci\u00f3 produ\u00efda pot tindre una influ\u00e8ncia negativa. Cal evitar el llenguatge acusatori i intimidador, aix\u00ed com la descripci\u00f3 excessivament t\u00e8cnica de l'error.","title":"D. Errors."},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#e-satisfaccio","text":"El darrer component de la usabilitat \u00e9s la satisfacci\u00f3 de l'usuari en utilitzar el nostre producte. El disseny ha d'aconseguir que l'experi\u00e8ncia de l'usuari amb la nostra aplicaci\u00f3 siga agradable i la seua sensaci\u00f3 subjectiva despr\u00e9s de l'\u00fas siga positiva. La satisfacci\u00f3 de l'usuari est\u00e0 en gran manera influenciada per la paren\u00e7a visual de la interf\u00edcie, que hauria de ser est\u00e8ticament agradable per\u00f2 minimalista. En aquest sentit \u00e9s important seguir les pautes de disseny que veurem a l'\u00faltim apartat de la unitat.","title":"E. Satisfacci\u00f3."},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#22-avaluacio-de-la-usabilitat","text":"Com vam veure a l'apartat anterior, una de les fases del proc\u00e9s de disseny centrat en l'usuari \u00e9s l'avaluaci\u00f3, i la usabilitat \u00e9s un dels factors clau que cal avaluar. Des dels primers prototips del nostre producte hem de validar el disseny amb els nostres usuaris, cosa que ens aportar\u00e0 informaci\u00f3 molt valuosa per millorar i evolucionar cap a la soluci\u00f3 final. Podem destacar els tres objectius seg\u00fcents de l'avaluaci\u00f3 de la usabilitat: Identificar problemes en el disseny del producte o servei. Descobrir noves oportunitats de millora del disseny que no ens hav\u00edem plantejat. Aprendre sobre el comportament i les prefer\u00e8ncies dels nostres usuaris.","title":"2.2 Avaluaci\u00f3 de la usabilitat"},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#a-que-hem-davaluar","text":"La primera pregunta que hem de respondre a l'hora de plantejar l'avaluaci\u00f3 de la usabilitat d'un disseny \u00e9s qu\u00e8 avaluarem. Les sessions d'avaluaci\u00f3 de la usabilitat consisteixen a plantejar a un grup d'usuaris la realitzaci\u00f3 d'una s\u00e8rie de tasques realistes que podrien fer a la feina di\u00e0ria amb l'aplicaci\u00f3. Les tasques que es plantegen poden ser molt espec\u00edfiques o amb un resultat obert, depenent dels objectius de la prova. Per\u00f2 sempre haurem de ser molt curosos amb la manera d'especificar la tasca, per evitar malentesos i confusions a l'usuari. Tamb\u00e9 hem d'evitar dirigir l'usuari excessivament, i permetre que utilitze lliurement el disseny. Important A l'hora d'escollir les tasques que els usuaris hauran de realitzar a la sessi\u00f3 d'avaluaci\u00f3 de la usabilitat, hem de prioritzar les m\u00e9s rellevants per a la nostra aplicaci\u00f3. Es recomana que no siguen m\u00e9s de cinc tasques per participant, i que la durada total de la sessi\u00f3 no supere una hora. A m\u00e9s de les tasques que es plantejaran a l'usuari, hem de decidir qu\u00e8 ens interessa mesurar durant la prova. En termes generals, se sol distingir entre dos tipus de m\u00e8triques: Qualitatives : aquest tipus de m\u00e8triques s\u00f3n especialment importants a les primeres fases del disseny, i consisteixen en valoracions subjectives que realitza l'usuari durant la prova o en observacions que podem realitzar del seu comportament . Exemple Exemples de m\u00e8triques qualitatives s\u00f3n el nivell d'estr\u00e8s de l'usuari (determinat pels seus moviments, gestos o expressions) o la satisfacci\u00f3 de l'usuari despr\u00e9s de la prova (que podeu comentar directament o podem recollir amb un q\u00fcestionari). Quantitatives : aquestes m\u00e8triques es basen en par\u00e0metres quantificables, i s'utilitzen m\u00e9s quan el disseny est\u00e0 quasi acabat o fins i tot quan el producte ja est\u00e0 en funcionament. Exemple Algunes m\u00e8triques quantitatives podrien ser el temps que li costa a un usuari dur a terme una tasca, el nombre de tasques que completa en una sessi\u00f3 o la quantitat de vegades que ha hagut d'anar a l'ajuda.","title":"A. Qu\u00e8 hem d'avaluar?"},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#b-qui-participa-en-lavaluacio","text":"A les sessions d'avaluaci\u00f3 de la usabilitat podem distingir els rols seg\u00fcents: Moderador : \u00e9s l'encarregat de guiar els usuaris participants durant la sessi\u00f3 d'avaluaci\u00f3. Presentar\u00e0 les tasques a realitzar, resoldr\u00e0 els dubtes dels usuaris i obtindr\u00e0 informaci\u00f3 mitjan\u00e7ant l'observaci\u00f3 o preguntant als usuaris. \u00c9s recomanable que siga alg\u00fa extern a l'equip de desenvolupament del producte, i fins i tot de vegades es recorre a professionals especialitzats en aquest tipus d'avaluacions. Important El moderador ha de procurar mantenir-se neutral i no influir en els participants. Ha d'intervenir tan poc com siga possible, i quan ho fa\u00e7a ha d'utilitzar un estil d'interacci\u00f3 obert, que permeta a l'usuari expressar-se amb llibertat. Per exemple, en lloc de preguntar si us sembla b\u00e9 una funcionalitat \u00e9s millor preguntar per la vostra opini\u00f3 sobre aquesta funcionalitat. Usuaris : els participants a la sessi\u00f3 han de ser usuaris potencials del producte o servei que estem dissenyant. Es recomana que a cada sessi\u00f3 d'avaluaci\u00f3 participen al voltant de cinc usuaris, ja que a partir d'aquest nombre els problemes d'usabilitat detectats se solen repetir.","title":"B. Qui participa en l'avaluaci\u00f3?"},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#c-com-es-fa-lavaluacio","text":"Hi ha diferents opcions a l'hora de plantejar l'avaluaci\u00f3 de la usabilitat: Presencial : el moderador i els usuaris estan f\u00edsicament al mateix lloc. Tot i que el moderador sol prendre notes durant la sessi\u00f3, tamb\u00e9 \u00e9s habitual gravar la sessi\u00f3 en v\u00eddeo per poder fer una an\u00e0lisi m\u00e9s detallada amb posterioritat. Remota : els participants a la sessi\u00f3 estan en llocs diferents. Solen ser menys costoses que les sessions presencials, i en estar els usuaris en el seu propi entorn de treball solen sentir-se m\u00e9s segurs davant de les tasques a realitzar. Podem distingir dos tipus d'avaluacions remotes: Moderades : encara que el moderador i els usuaris estan en ubicacions f\u00edsiques diferents, interactuen de manera semblant a les sessions presencials, utilitzant algun programari de comunicaci\u00f3 que permeta compartir la pantalla de l'usuari. No moderades : es fa servir algun programari especialitzat per a avaluacions d'usabilitat, on es configuren les tasques a realitzar. Un cop acabada la sessi\u00f3, el moderador rep el resultat de l'avaluaci\u00f3 (normalment, l'enregistrament de la sessi\u00f3, un test de valoraci\u00f3 de l'usuari i les m\u00e8triques quantitatives que s'hagen definit).","title":"C. Com es fa l'avaluaci\u00f3?"},{"location":"unitats/2-intro-interficies/teoria/2%20-%20Usabilitat/#23-experiencia-dusuari-ux","text":"El concepte d'experi\u00e8ncia d'usuari o UX (de l'angl\u00e9s, User Experience ) fa refer\u00e8ncia a l'experi\u00e8ncia completa de l'usuari en relaci\u00f3 amb un producte o servei. Una bona experi\u00e8ncia d'usuari donar\u00e0 com a resultat una percepci\u00f3 subjectiva positiva de l'usuari cap a la nostra aplicaci\u00f3. Important No s'han de confondre els conceptes d'experi\u00e8ncia d'usuari i usabilitat, encara que hi ha relaci\u00f3 entre ells. La usabilitat \u00e9s un dels factors que influeixen en una bona experi\u00e8ncia d'usuari, per\u00f2 tamb\u00e9 seran determinants factors com ara la utilitat (que el producte permeta a l'usuari resoldre un problema concret), la credibilitat (que l'usuari confie en el nostre producte) o l'accessibilitat (que el disseny tinga en compte la varietat d'usuaris i dispositius). Donald Norman (del que ja parl\u00e0rem a l'apartat anterior) juntament amb Jakob Nielsen (un dels principals referents en el m\u00f3n de la usabilitat) van proposar els nivells seg\u00fcents en parlar d'experi\u00e8ncia d'usuari. Com veiem, aconseguir una bona experi\u00e8ncia d'usuari comen\u00e7a creant un producte o servei que siga \u00fatil per a l'usuari i li permeta resoldre un problema concret. El seg\u00fcent pas seria aconseguir que el disseny siga usable, aplicant tot el que hem apr\u00e9s als apartats anteriors. Una vegada tenim un disseny \u00fatil i usable, l'objectiu seria aconseguir un producte atractiu per als usuaris, que han de desitjar utilitzar-lo. L'\u00faltim nivell \u00e9s on s'assoleix una experi\u00e8ncia global positiva, aconseguint que la seua opini\u00f3 subjectiva cap al nostre producte siga bona.","title":"2.3 Experi\u00e8ncia dusuari (UX)"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/","text":"3. Pautes de disseny Com hem vist als apartats anteriors, la interf\u00edcie d'usuari d'una aplicaci\u00f3 ha de ser dissenyada amb l'usuari sempre en ment, i tenir com a objectiu que l'experi\u00e8ncia global dels usuaris amb la nostra aplicaci\u00f3 siga la m\u00e9s satisfact\u00f2ria possible. Per aconseguir-ho, \u00e9s de vital import\u00e0ncia con\u00e9ixer les pautes i recomanacions existents per a cadascun dels components de la interf\u00edcie, que ens ajudaran sobre manera a aconseguir un disseny exit\u00f3s. Les pautes de disseny es troben en diferents tipus de documents, que podem organitzar en els seg\u00fcents nivells: Al nivell m\u00e9s baix tenim els est\u00e0ndards internacionals, com les normes ISO comentades en apartats anteriors. Serveixen de base per a la resta de pautes, encara que no s\u00f3n documents amb qu\u00e8 els dissenyadors d'interf\u00edcies treballen habitualment. Prenent com a refer\u00e8ncia els est\u00e0ndards internacionals s'elaboren les guies de cada plataforma. Per exemple, Microsoft ha desenvolupat una guia de disseny per a aplicacions d'escriptori per al sistema operatiu Windows i Apple una guia per a cadascuna de les seues plataformes (com macOS o iOS). A l'entorn de les aplicacions per a Linux, hi ha una guia per al GNOME i una altra per al KDE. Important Les guies de disseny de cada plataforma contenen informaci\u00f3 molt \u00fatil a l'hora de plantejar el disseny de la interf\u00edcie d'usuari, i s'han de con\u00e9ixer i utilitzar per part dels dissenyadors. A les refer\u00e8ncies de la unitat es pot trobar un enlla\u00e7 a cadascuna de les guies comentades. En algunes organitzacions, s'elaboren est\u00e0ndards corporatius propis relatius al disseny de la interf\u00edcie, que solen incloure aspectes com la tipografia a utilitzar o les paletes de colors permeses. I respectant aquests est\u00e0ndards corporatius, de vegades es desenvolupen fins i tot guies de disseny per a aplicacions concretes dins una organitzaci\u00f3. Els apartats seg\u00fcents recullen algunes pautes generals que cal tenir en compte a l'hora de fer el disseny de la nostra interf\u00edcie. 3.1 Estructura de la interf\u00edcie A. Principis de disseny Pel que fa a com estructurar i organitzar els elements que formen la interf\u00edcie de la nostra aplicaci\u00f3, s'han de tenir presents en tot moment els principis de disseny seg\u00fcents: Contrast : cal utilitzar els contrastos de color i mida per organitzar la informaci\u00f3 i dirigir l'atenci\u00f3 de l'usuari. Exemple S'utilitza habitualment el color roig per advertir l'usuari d'una acci\u00f3 destructiva o que no es pot desfer, ja que contrasta fortament amb els colors que se solen utilitzar com a fons. Jerarquia : agrupar els elements que formen la interf\u00edcie, ordenant-los segons la seua import\u00e0ncia. Exemple Els men\u00fas s\u00f3n un exemple t\u00edpic de jer\u00e0rquica a la interf\u00edcie, ja que ens permeten organitzar les funcionalitats de l'aplicaci\u00f3 en categories i subcategories. Proximitat : podem crear una relaci\u00f3 entre diferents elements de la interf\u00edcie si els situem a prop els uns dels altres. De la mateixa manera, quan dos components de la interf\u00edcie estan allunyats, l'usuari entendr\u00e0 que no hi ha relaci\u00f3 entre ells. Exemple A les barres de ferramentes els diferents botons solen estar agrupats segons la seva funcionalitat, de manera que els usuaris els poden localitzar m\u00e9s f\u00e0cilment. Per exemple, les opcions de negreta, cursiva i subratllat en un processador de text sempre estan juntes. Alineaci\u00f3 : la correcta alineaci\u00f3 dels diferents components de la interf\u00edcie facilita a l'usuari processar la informaci\u00f3 i ens permet guiar-los m\u00e9s f\u00e0cilment per les diferents zones de la interf\u00edcie. L'alineaci\u00f3 entre els elements propers \u00e9s especialment important per evitar errors i sobreesfor\u00e7os a l'usuari. Exemple Quan dissenyem un formulari perqu\u00e8 l'usuari introdueixi informaci\u00f3, \u00e9s especialment important l'alineaci\u00f3 entre els diferents elements. D'una banda, les etiquetes han d'estar correctament alineades amb els controls que acompanyen. I de l'altra, hem d'alinear uns camps amb els altres per facilitar a l'usuari la seva tasca. B. Men\u00fas, men\u00fas contextuals i barres de ferramentes Gran part de les aplicacions amb interf\u00edcie gr\u00e0fica d'usuari compten amb men\u00fas i barres de ferramentes per permetre a l'usuari accedir a les diferents funcionalitats de l'aplicaci\u00f3. Veurem algunes de les pautes m\u00e9s importants a tenir en compte quan fem servir aquests elements: Men\u00fas Si el men\u00fa t\u00e9 poques opcions principals (tres o menys) \u00e9s millor considerar una altra alternativa, com ara una barra amb botons. Si teniu massa opcions principals (m\u00e9s de 10) cal intentar reorganitzar les opcions de men\u00fa per reduir-les. Cal intentar simplificar l'estructura de men\u00fas i de submen\u00fas, ja que compliquen a l'usuari trobar l'opci\u00f3 desitjada. Si la jerarquia \u00e9s massa profunda haurem d'intentar reorganitzar les opcions. Les etiquetes han de ser tan simples com siga possible, recomanant-se una sola paraula a les opcions principals del men\u00fa. Si l'acci\u00f3 associada a una opci\u00f3 de men\u00fa requereix obrir una finestra o di\u00e0leg, la vostra etiqueta ha d'acabar amb punts suspensius (per exemple, Desa com\u2026). Men\u00fas contextuals Han d'apar\u00e9ixer en pr\u00e9mer amb el bot\u00f3 dret del ratol\u00ed sobre una zona de la interf\u00edcie, i oferiran un xicotet conjunt d'opcions (no m\u00e9s de 10) relacionades amb l'element sobre el qual heu premut. Les opcions del men\u00fa contextual tamb\u00e9 han d'estar disponibles des del men\u00fa principal de l'aplicaci\u00f3. Ordenar les opcions de m\u00e9s a menys rellev\u00e0ncia per a l'usuari. Evitar l'\u00fas de submen\u00fas als men\u00fas contextuals. Barres de ferramentes Incloure a la barra de ferramentes nom\u00e9s les opcions m\u00e9s utilitzades pels usuaris. \u00c9s recomanable permetre a l'usuari personalitzar els botons presents a les barres de ferramentes. Com que, en la majoria de les aplicacions, les barres de ferramentes es poden ocultar, les opcions han de ser accessibles d'altres maneres (per exemple, amb el men\u00fa principal de l'aplicaci\u00f3). Les icones utilitzades han de ser consistents amb les que l'usuari sol trobar a la majoria de les aplicacions (per exemple, un disquet per a l'opci\u00f3 de guardar). Tamb\u00e9 \u00e9s recomanable afegir una descripci\u00f3 de cada acci\u00f3 a manera de tooltip . 3.2 Controls Els controls s\u00f3n els components b\u00e0sics amb qu\u00e8 constru\u00efm la interf\u00edcie gr\u00e0fica d'una aplicaci\u00f3. Exemple Alguns exemples de controls s\u00f3n els botons, les caselles de selecci\u00f3 o les llistes desplegables. La taula seg\u00fcent recull informaci\u00f3 sobre l'\u00fas dels principals controls, indicant quan han de ser usats i algunes pautes importants en cadascun. Pautes d'\u00fas dels controls Botons Entrada de text Llista desplegable Casella de selecci\u00f3 Bot\u00f3 de r\u00e0dio Els botons permeten a l'usuari iniciar una acci\u00f3 de manera immediata. Utilitzar etiquetes descriptives de lacci\u00f3. Ser consistent en tota l'aplicaci\u00f3 (posici\u00f3, colors, icones, mida,...). Situar-los a prop d'altres controls relacionats. Agrupar-los de manera l\u00f2gica. Permet introduir text de forma lliure. No ho utilitzarem quan hi hagi un control especialitzat m\u00e9s adequat (per exemple, un selector de dates) o quan els possibles valors estiguin restringits (per exemple, la prov\u00edncia d'una adre\u00e7a). L'etiqueta ha d'indicar clarament a l'usuari qu\u00e8 ha d'introduir i ser tan curta com siga possible. \u00c9s preferible situar l\u02bbetiqueta sobre el control, encara que tamb\u00e9 es pot posar a la seva esquerra. L'amplada del control ha de ser adequada al tipus de dada que cont\u00e9. S'utilitzen per triar un valor d'una llista de valors possibles. S\u00f3n especialment \u00fatils quan una de les opcions \u00e9s la predeterminada, o quan lespai disponible \u00e9s limitat. Cadascuna de les opcions ha d'estar formada per poques paraules. Les opcions han d'estar ordenades de manera l\u00f2gica. Les meta-opcions (com Cap) s'han de situar a l'inici de la llista i entre par\u00e8ntesis. S'utilitzen per activar o desactivar una opci\u00f3, o per seleccionar o deseleccionar una opci\u00f3 dins d'un grup d'opcions. \u00c9s molt \u00fatil quan lusuari pot triar diverses opcions, o no triar cap opci\u00f3. Les diferents caselles d\u201fun grup han d\u201festar alineades verticalment. Limitar a 10 el n\u00famero de caselles en un grup. En un grup de caselles totes les etiquetes han de ser homog\u00e8nies en extensi\u00f3 i en format. Permet a l'usuari seleccionar una \u00fanica opci\u00f3 dins d'un grup d'opcions. S\u00f3n recomanables quan volem que l'usuari vegi totes les opcions alhora, i quan les etiquetes de les opcions sigan extenses. El nombre d'opcions ha de ser inferior a 7. Ordenar les diferents opcions en un ordre l\u00f2gic per a l'usuari. Seleccionar per defecte l'opci\u00f3 m\u00e9s adequada per a l'usuari. A les guies de disseny de cada plataforma s'ofereix informaci\u00f3 per a altres tipus de controls m\u00e9s espec\u00edfics, com ara les barres de progr\u00e9s, els controls lliscants o els selectors de data i hora. 3.3 Aspecte visual En aquest apartat es mostren algunes pautes de disseny importants relacionades amb l'aspecte visual de l'aplicaci\u00f3, concretament relatives al color, el text i les icones. A. Color L'\u00fas de diferents colors a la interf\u00edcie amb fins est\u00e8tics ha de ser redu\u00eft, i s'utilitzar\u00e0 principalment per comunicar alguna cosa a l'usuari (per exemple, utilitzarem el color roig per comunicar un error o situaci\u00f3 perillosa). No obstant aix\u00f2, mai no ha de ser l'\u00fanica via per comunicar alguna cosa. Mai referenciar un element de la interf\u00edcie pel seu color (per exemple, seria incorrecte indicar a l'usuari \u201cHa de pr\u00e9mer el bot\u00f3 roig\u201d). La interpretaci\u00f3 que fem dels diferents colors pot variar depenent de la cultura dels usuaris, per la qual cosa ens haurem d'assegurar que el significat dels colors siga el que pretenem. El conjunt de colors que utilitzem en el nostre disseny (conegut com a esquema de color o paleta) han de contrastar de forma adequada. Paleta de colors S'aconsella utilitzar les paletes del sistema, o un generador de paletes de colors com el que s'inclou a les refer\u00e8ncies de la unitat. B. Text Es recomana utilitzar les fonts predeterminades de la plataforma a qu\u00e8 va destinada l'aplicaci\u00f3 (per exemple, les fonts Segoe UI a Microsoft Windows o San Francisco a Apple macOS ). La mida del text s'ha de determinar de manera que ajude l'usuari a establir la jerarquia entre els elements de la interf\u00edcie. Utilitzar les propietats del text (com la negreta, la cursiva o el subratllat) de forma consistent dins de l'aplicaci\u00f3, i tamb\u00e9 amb la resta d'aplicacions. Per exemple, els enlla\u00e7os sempre han d'estar subratllats. C. Icones Com a regla general, no s'han d'usar etiquetes i icones alhora al mateix control. Cal triar una de les dues opcions. Es recomana utilitzar icones f\u00e0cilment identificables per l'usuari, que seguisquen les convencions de la resta d'aplicacions (per exemple, una paperera per a l'acci\u00f3 d'esborrar). Algunes icones s\u00f3n f\u00e0cilment reconeixibles dins d'un grup d'icones, per\u00f2 no fora del grup. Per exemple, una icona amb un quadrat negre representa l'acci\u00f3 de parar en un reproductor multim\u00e8dia, per\u00f2 dif\u00edcilment ser\u00e0 associada a aquesta acci\u00f3 fora del context. Conv\u00e9 adaptar-se a l'estil visual de les icones de cada plataforma, encara que actualment el m\u00e9s habitual \u00e9s utilitzar icones amb un disseny simple que representen clarament una acci\u00f3. 3.4 Missatges a l'usuari La majoria de les aplicacions necessiten mostrar diferents tipus de missatges a l'usuari amb diferents prop\u00f2sits. S\u00f3n molt habituals els missatges de confirmaci\u00f3, error o advert\u00e8ncia i les notificacions. A continuaci\u00f3 es llisten algunes recomanacions relacionades amb els missatges a l'usuari: Missatges a l'usuari Cal avisar l'usuari abans de comen\u00e7ar una acci\u00f3 irreversible i que podria causar una p\u00e8rdua d'informaci\u00f3. Cal evitar interrompre l'usuari amb missatges que no siguen importants. Sempre hem d'utilitzar un llenguatge proper a l'usuari, sense incloure informaci\u00f3 interna de l'aplicaci\u00f3 (com ara codis d'error que no siguen \u00fatils per a l'usuari). La manera d'expressar els missatges ha de ser respectuosa amb l'usuari, i utilitzar un estil d'escriptura directe i conc\u00eds.","title":"3 - Pautes de disseny"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#3-pautes-de-disseny","text":"Com hem vist als apartats anteriors, la interf\u00edcie d'usuari d'una aplicaci\u00f3 ha de ser dissenyada amb l'usuari sempre en ment, i tenir com a objectiu que l'experi\u00e8ncia global dels usuaris amb la nostra aplicaci\u00f3 siga la m\u00e9s satisfact\u00f2ria possible. Per aconseguir-ho, \u00e9s de vital import\u00e0ncia con\u00e9ixer les pautes i recomanacions existents per a cadascun dels components de la interf\u00edcie, que ens ajudaran sobre manera a aconseguir un disseny exit\u00f3s. Les pautes de disseny es troben en diferents tipus de documents, que podem organitzar en els seg\u00fcents nivells: Al nivell m\u00e9s baix tenim els est\u00e0ndards internacionals, com les normes ISO comentades en apartats anteriors. Serveixen de base per a la resta de pautes, encara que no s\u00f3n documents amb qu\u00e8 els dissenyadors d'interf\u00edcies treballen habitualment. Prenent com a refer\u00e8ncia els est\u00e0ndards internacionals s'elaboren les guies de cada plataforma. Per exemple, Microsoft ha desenvolupat una guia de disseny per a aplicacions d'escriptori per al sistema operatiu Windows i Apple una guia per a cadascuna de les seues plataformes (com macOS o iOS). A l'entorn de les aplicacions per a Linux, hi ha una guia per al GNOME i una altra per al KDE. Important Les guies de disseny de cada plataforma contenen informaci\u00f3 molt \u00fatil a l'hora de plantejar el disseny de la interf\u00edcie d'usuari, i s'han de con\u00e9ixer i utilitzar per part dels dissenyadors. A les refer\u00e8ncies de la unitat es pot trobar un enlla\u00e7 a cadascuna de les guies comentades. En algunes organitzacions, s'elaboren est\u00e0ndards corporatius propis relatius al disseny de la interf\u00edcie, que solen incloure aspectes com la tipografia a utilitzar o les paletes de colors permeses. I respectant aquests est\u00e0ndards corporatius, de vegades es desenvolupen fins i tot guies de disseny per a aplicacions concretes dins una organitzaci\u00f3. Els apartats seg\u00fcents recullen algunes pautes generals que cal tenir en compte a l'hora de fer el disseny de la nostra interf\u00edcie.","title":"3. Pautes de disseny"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#31-estructura-de-la-interficie","text":"","title":"3.1 Estructura de la interf\u00edcie"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#a-principis-de-disseny","text":"Pel que fa a com estructurar i organitzar els elements que formen la interf\u00edcie de la nostra aplicaci\u00f3, s'han de tenir presents en tot moment els principis de disseny seg\u00fcents: Contrast : cal utilitzar els contrastos de color i mida per organitzar la informaci\u00f3 i dirigir l'atenci\u00f3 de l'usuari. Exemple S'utilitza habitualment el color roig per advertir l'usuari d'una acci\u00f3 destructiva o que no es pot desfer, ja que contrasta fortament amb els colors que se solen utilitzar com a fons. Jerarquia : agrupar els elements que formen la interf\u00edcie, ordenant-los segons la seua import\u00e0ncia. Exemple Els men\u00fas s\u00f3n un exemple t\u00edpic de jer\u00e0rquica a la interf\u00edcie, ja que ens permeten organitzar les funcionalitats de l'aplicaci\u00f3 en categories i subcategories. Proximitat : podem crear una relaci\u00f3 entre diferents elements de la interf\u00edcie si els situem a prop els uns dels altres. De la mateixa manera, quan dos components de la interf\u00edcie estan allunyats, l'usuari entendr\u00e0 que no hi ha relaci\u00f3 entre ells. Exemple A les barres de ferramentes els diferents botons solen estar agrupats segons la seva funcionalitat, de manera que els usuaris els poden localitzar m\u00e9s f\u00e0cilment. Per exemple, les opcions de negreta, cursiva i subratllat en un processador de text sempre estan juntes. Alineaci\u00f3 : la correcta alineaci\u00f3 dels diferents components de la interf\u00edcie facilita a l'usuari processar la informaci\u00f3 i ens permet guiar-los m\u00e9s f\u00e0cilment per les diferents zones de la interf\u00edcie. L'alineaci\u00f3 entre els elements propers \u00e9s especialment important per evitar errors i sobreesfor\u00e7os a l'usuari. Exemple Quan dissenyem un formulari perqu\u00e8 l'usuari introdueixi informaci\u00f3, \u00e9s especialment important l'alineaci\u00f3 entre els diferents elements. D'una banda, les etiquetes han d'estar correctament alineades amb els controls que acompanyen. I de l'altra, hem d'alinear uns camps amb els altres per facilitar a l'usuari la seva tasca.","title":"A. Principis de disseny"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#b-menus-menus-contextuals-i-barres-de-ferramentes","text":"Gran part de les aplicacions amb interf\u00edcie gr\u00e0fica d'usuari compten amb men\u00fas i barres de ferramentes per permetre a l'usuari accedir a les diferents funcionalitats de l'aplicaci\u00f3. Veurem algunes de les pautes m\u00e9s importants a tenir en compte quan fem servir aquests elements:","title":"B. Men\u00fas, men\u00fas contextuals i barres de ferramentes"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#menus","text":"Si el men\u00fa t\u00e9 poques opcions principals (tres o menys) \u00e9s millor considerar una altra alternativa, com ara una barra amb botons. Si teniu massa opcions principals (m\u00e9s de 10) cal intentar reorganitzar les opcions de men\u00fa per reduir-les. Cal intentar simplificar l'estructura de men\u00fas i de submen\u00fas, ja que compliquen a l'usuari trobar l'opci\u00f3 desitjada. Si la jerarquia \u00e9s massa profunda haurem d'intentar reorganitzar les opcions. Les etiquetes han de ser tan simples com siga possible, recomanant-se una sola paraula a les opcions principals del men\u00fa. Si l'acci\u00f3 associada a una opci\u00f3 de men\u00fa requereix obrir una finestra o di\u00e0leg, la vostra etiqueta ha d'acabar amb punts suspensius (per exemple, Desa com\u2026).","title":"Men\u00fas"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#menus-contextuals","text":"Han d'apar\u00e9ixer en pr\u00e9mer amb el bot\u00f3 dret del ratol\u00ed sobre una zona de la interf\u00edcie, i oferiran un xicotet conjunt d'opcions (no m\u00e9s de 10) relacionades amb l'element sobre el qual heu premut. Les opcions del men\u00fa contextual tamb\u00e9 han d'estar disponibles des del men\u00fa principal de l'aplicaci\u00f3. Ordenar les opcions de m\u00e9s a menys rellev\u00e0ncia per a l'usuari. Evitar l'\u00fas de submen\u00fas als men\u00fas contextuals.","title":"Men\u00fas contextuals"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#barres-de-ferramentes","text":"Incloure a la barra de ferramentes nom\u00e9s les opcions m\u00e9s utilitzades pels usuaris. \u00c9s recomanable permetre a l'usuari personalitzar els botons presents a les barres de ferramentes. Com que, en la majoria de les aplicacions, les barres de ferramentes es poden ocultar, les opcions han de ser accessibles d'altres maneres (per exemple, amb el men\u00fa principal de l'aplicaci\u00f3). Les icones utilitzades han de ser consistents amb les que l'usuari sol trobar a la majoria de les aplicacions (per exemple, un disquet per a l'opci\u00f3 de guardar). Tamb\u00e9 \u00e9s recomanable afegir una descripci\u00f3 de cada acci\u00f3 a manera de tooltip .","title":"Barres de ferramentes"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#32-controls","text":"Els controls s\u00f3n els components b\u00e0sics amb qu\u00e8 constru\u00efm la interf\u00edcie gr\u00e0fica d'una aplicaci\u00f3. Exemple Alguns exemples de controls s\u00f3n els botons, les caselles de selecci\u00f3 o les llistes desplegables. La taula seg\u00fcent recull informaci\u00f3 sobre l'\u00fas dels principals controls, indicant quan han de ser usats i algunes pautes importants en cadascun. Pautes d'\u00fas dels controls Botons Entrada de text Llista desplegable Casella de selecci\u00f3 Bot\u00f3 de r\u00e0dio Els botons permeten a l'usuari iniciar una acci\u00f3 de manera immediata. Utilitzar etiquetes descriptives de lacci\u00f3. Ser consistent en tota l'aplicaci\u00f3 (posici\u00f3, colors, icones, mida,...). Situar-los a prop d'altres controls relacionats. Agrupar-los de manera l\u00f2gica. Permet introduir text de forma lliure. No ho utilitzarem quan hi hagi un control especialitzat m\u00e9s adequat (per exemple, un selector de dates) o quan els possibles valors estiguin restringits (per exemple, la prov\u00edncia d'una adre\u00e7a). L'etiqueta ha d'indicar clarament a l'usuari qu\u00e8 ha d'introduir i ser tan curta com siga possible. \u00c9s preferible situar l\u02bbetiqueta sobre el control, encara que tamb\u00e9 es pot posar a la seva esquerra. L'amplada del control ha de ser adequada al tipus de dada que cont\u00e9. S'utilitzen per triar un valor d'una llista de valors possibles. S\u00f3n especialment \u00fatils quan una de les opcions \u00e9s la predeterminada, o quan lespai disponible \u00e9s limitat. Cadascuna de les opcions ha d'estar formada per poques paraules. Les opcions han d'estar ordenades de manera l\u00f2gica. Les meta-opcions (com Cap) s'han de situar a l'inici de la llista i entre par\u00e8ntesis. S'utilitzen per activar o desactivar una opci\u00f3, o per seleccionar o deseleccionar una opci\u00f3 dins d'un grup d'opcions. \u00c9s molt \u00fatil quan lusuari pot triar diverses opcions, o no triar cap opci\u00f3. Les diferents caselles d\u201fun grup han d\u201festar alineades verticalment. Limitar a 10 el n\u00famero de caselles en un grup. En un grup de caselles totes les etiquetes han de ser homog\u00e8nies en extensi\u00f3 i en format. Permet a l'usuari seleccionar una \u00fanica opci\u00f3 dins d'un grup d'opcions. S\u00f3n recomanables quan volem que l'usuari vegi totes les opcions alhora, i quan les etiquetes de les opcions sigan extenses. El nombre d'opcions ha de ser inferior a 7. Ordenar les diferents opcions en un ordre l\u00f2gic per a l'usuari. Seleccionar per defecte l'opci\u00f3 m\u00e9s adequada per a l'usuari. A les guies de disseny de cada plataforma s'ofereix informaci\u00f3 per a altres tipus de controls m\u00e9s espec\u00edfics, com ara les barres de progr\u00e9s, els controls lliscants o els selectors de data i hora.","title":"3.2 Controls"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#33-aspecte-visual","text":"En aquest apartat es mostren algunes pautes de disseny importants relacionades amb l'aspecte visual de l'aplicaci\u00f3, concretament relatives al color, el text i les icones.","title":"3.3 Aspecte visual"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#a-color","text":"L'\u00fas de diferents colors a la interf\u00edcie amb fins est\u00e8tics ha de ser redu\u00eft, i s'utilitzar\u00e0 principalment per comunicar alguna cosa a l'usuari (per exemple, utilitzarem el color roig per comunicar un error o situaci\u00f3 perillosa). No obstant aix\u00f2, mai no ha de ser l'\u00fanica via per comunicar alguna cosa. Mai referenciar un element de la interf\u00edcie pel seu color (per exemple, seria incorrecte indicar a l'usuari \u201cHa de pr\u00e9mer el bot\u00f3 roig\u201d). La interpretaci\u00f3 que fem dels diferents colors pot variar depenent de la cultura dels usuaris, per la qual cosa ens haurem d'assegurar que el significat dels colors siga el que pretenem. El conjunt de colors que utilitzem en el nostre disseny (conegut com a esquema de color o paleta) han de contrastar de forma adequada. Paleta de colors S'aconsella utilitzar les paletes del sistema, o un generador de paletes de colors com el que s'inclou a les refer\u00e8ncies de la unitat.","title":"A. Color"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#b-text","text":"Es recomana utilitzar les fonts predeterminades de la plataforma a qu\u00e8 va destinada l'aplicaci\u00f3 (per exemple, les fonts Segoe UI a Microsoft Windows o San Francisco a Apple macOS ). La mida del text s'ha de determinar de manera que ajude l'usuari a establir la jerarquia entre els elements de la interf\u00edcie. Utilitzar les propietats del text (com la negreta, la cursiva o el subratllat) de forma consistent dins de l'aplicaci\u00f3, i tamb\u00e9 amb la resta d'aplicacions. Per exemple, els enlla\u00e7os sempre han d'estar subratllats.","title":"B. Text"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#c-icones","text":"Com a regla general, no s'han d'usar etiquetes i icones alhora al mateix control. Cal triar una de les dues opcions. Es recomana utilitzar icones f\u00e0cilment identificables per l'usuari, que seguisquen les convencions de la resta d'aplicacions (per exemple, una paperera per a l'acci\u00f3 d'esborrar). Algunes icones s\u00f3n f\u00e0cilment reconeixibles dins d'un grup d'icones, per\u00f2 no fora del grup. Per exemple, una icona amb un quadrat negre representa l'acci\u00f3 de parar en un reproductor multim\u00e8dia, per\u00f2 dif\u00edcilment ser\u00e0 associada a aquesta acci\u00f3 fora del context. Conv\u00e9 adaptar-se a l'estil visual de les icones de cada plataforma, encara que actualment el m\u00e9s habitual \u00e9s utilitzar icones amb un disseny simple que representen clarament una acci\u00f3.","title":"C. Icones"},{"location":"unitats/2-intro-interficies/teoria/3%20-%20Pautes%20de%20Disseny/#34-missatges-a-lusuari","text":"La majoria de les aplicacions necessiten mostrar diferents tipus de missatges a l'usuari amb diferents prop\u00f2sits. S\u00f3n molt habituals els missatges de confirmaci\u00f3, error o advert\u00e8ncia i les notificacions. A continuaci\u00f3 es llisten algunes recomanacions relacionades amb els missatges a l'usuari: Missatges a l'usuari Cal avisar l'usuari abans de comen\u00e7ar una acci\u00f3 irreversible i que podria causar una p\u00e8rdua d'informaci\u00f3. Cal evitar interrompre l'usuari amb missatges que no siguen importants. Sempre hem d'utilitzar un llenguatge proper a l'usuari, sense incloure informaci\u00f3 interna de l'aplicaci\u00f3 (com ara codis d'error que no siguen \u00fatils per a l'usuari). La manera d'expressar els missatges ha de ser respectuosa amb l'usuari, i utilitzar un estil d'escriptura directe i conc\u00eds.","title":"3.4 Missatges a l'usuari"}]}